<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>苍穹之下</title>
  
  <subtitle>a little blog</subtitle>
  <link href="http://mail.zyjcould.ltd/atom.xml" rel="self"/>
  
  <link href="http://mail.zyjcould.ltd/"/>
  <updated>2022-07-14T17:19:44.661Z</updated>
  <id>http://mail.zyjcould.ltd/</id>
  
  <author>
    <name>Jack-zhang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>git-hooks</title>
    <link href="http://mail.zyjcould.ltd/2022/07/09/git-hooks/"/>
    <id>http://mail.zyjcould.ltd/2022/07/09/git-hooks/</id>
    <published>2022-07-08T20:06:56.000Z</published>
    <updated>2022-07-14T17:19:44.661Z</updated>
    
    <content type="html"><![CDATA[<h2 id="hooks"><a href="#hooks" class="headerlink" title="hooks"></a>hooks</h2><p><img src="././githooks.png" alt="git hooks"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;hooks&quot;&gt;&lt;a href=&quot;#hooks&quot; class=&quot;headerlink&quot; title=&quot;hooks&quot;&gt;&lt;/a&gt;hooks&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;././githooks.png&quot; alt=&quot;git hooks&quot;&gt;&lt;/p&gt;
</summary>
      
    
    
    
    <category term="git" scheme="http://mail.zyjcould.ltd/categories/git/"/>
    
    
    <category term="git" scheme="http://mail.zyjcould.ltd/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>git原理分支.md</title>
    <link href="http://mail.zyjcould.ltd/2022/07/02/git-yuan-li-fen-zhi/"/>
    <id>http://mail.zyjcould.ltd/2022/07/02/git-yuan-li-fen-zhi/</id>
    <published>2022-07-01T21:05:03.000Z</published>
    <updated>2022-07-14T17:19:44.528Z</updated>
    
    <content type="html"><![CDATA[<h2 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h2><blockquote><p>通过<code>HEAD</code>文件可以知道当前在哪个分支工作,并且<strong>HEAD指向的分支</strong>总是指向最新的<code>commit</code></p></blockquote><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">                            HEAD                              <span class="token operator">|</span>                            master                              <span class="token operator">|</span>                       ├─---a219fd1e735a  <span class="token operator">&lt;</span>--- 8532d9 <span class="token operator">&lt;</span>--<span class="token operator">|</span>                            ├─---e78125                              <span class="token operator">|</span>                             dev<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>通过切换<code>HEAD</code>的指向可以切换分支</li></ul><blockquote><p>产看当前分支内容</p></blockquote><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">cat</span> .git/HEAD<span class="token comment"># ref: refs/heads/master</span><span class="token function">cat</span> .git/refs/heads/master<span class="token comment"># b27787b75a99a614f3b26fe482f0cd47bc3c186b (当前分支指向最新的 commit)</span><span class="token function">git</span> cat-file -t b27787b<span class="token comment"># commit</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>创建分支</p></blockquote><ul><li><code>git branch dev</code>:创建一个<code>dev</code>的分支</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> log<span class="token comment"># master dev分支刚好指向同一条线上   </span><span class="token comment"># commit b27787b75a99a614f3b26fe482f0cd47bc3c186b (HEAD -> master, dev)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li><code>git checkout dev</code>:切换到<code>dev</code>分支</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> checkout dev<span class="token function">cat</span> .git/HEAD<span class="token comment"># ref: refs/heads/dev</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>如果在dev上做完一次<code>commit</code>之后,分支之间会分叉</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> log<span class="token comment"># commit 609f9e53903da9cc53127619044bb8a02f36519a (HEAD -> dev)</span><span class="token comment"># Author: Jack-Zhang-1314 &lt;zyj17715640603@gmail.com></span><span class="token comment"># Date:   Sat Jul 2 05:25:37 2022 +0800</span><span class="token comment"># </span><span class="token comment">#     dev 1st</span><span class="token comment"># </span><span class="token comment"># commit b27787b75a99a614f3b26fe482f0cd47bc3c186b (master)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>删除分支,只是删除分支的指针,分支上的对象不会被删除</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># D-->强制删除</span><span class="token function">git</span> branch -d dev<span class="token function">git</span> branch -D dev<span class="token comment"># 查看dev删除后的commit内容</span><span class="token function">git</span> cat-file -p 609f9e5<span class="token comment"># tree fd59d47bd5ca961d23037b22377a89bc4debdce0</span><span class="token comment"># parent b27787b75a99a614f3b26fe482f0cd47bc3c186b</span><span class="token comment"># author Jack-Zhang-1314 &lt;zyj17715640603@gmail.com> 1656710737 +0800</span><span class="token comment"># committer Jack-Zhang-1314 &lt;zyj17715640603@gmail.com> 1656710737 +0800</span><span class="token comment"># </span><span class="token comment"># dev 1st</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="git-checkout"><a href="#git-checkout" class="headerlink" title="git checkout"></a>git checkout</h2><blockquote><p>使用<code>git checkout</code>叉出某一次<code>commit</code></p></blockquote><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> checkout a3d91d1<span class="token function">git</span> branch<span class="token comment"># 指向(HEAD detached at a3d91d1)</span><span class="token function">git</span> checkout -b tem<span class="token comment">#将当前的提交叉到新的分支</span><span class="token function">git</span> log <span class="token comment"># commit a3d91d125103f57b7b60d7ebd6502aa0987828ab (HEAD -> tem)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>将删除的分支找回</p></blockquote><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> reflog<span class="token comment"># a3d91d1 (HEAD -> tem) HEAD@&#123;0&#125;: checkout: moving from a3d91d125103f57b7b60d7ebd6502aa0987828ab to tem</span><span class="token comment"># a3d91d1 (HEAD -> tem) HEAD@&#123;1&#125;: checkout: moving from master to a3d91d12</span><span class="token comment"># b27787b (master) HEAD@&#123;2&#125;: checkout: moving from dev to master</span><span class="token comment"># 609f9e5 HEAD@&#123;3&#125;: commit: dev 1st</span><span class="token comment"># b27787b (master) HEAD@&#123;4&#125;: checkout: moving from master to dev</span><span class="token comment"># b27787b (master) HEAD@&#123;5&#125;: commit: 2st commit</span><span class="token comment"># a3d91d1 (HEAD -> tem) HEAD@&#123;6&#125;: commit (initial): 1st commit</span><span class="token function">git</span> checkout 609f9e5<span class="token function">git</span> switch -c dev<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="远程分支"><a href="#远程分支" class="headerlink" title="远程分支"></a>远程分支</h2><blockquote><p>添加远程分支</p></blockquote><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> remote <span class="token function">add</span> origin ssh<span class="token punctuation">..</span>.<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>查看添加的内容<code>cat .git/config</code></p></blockquote><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>remote <span class="token string">"origin"</span><span class="token punctuation">]</span>        url <span class="token operator">=</span> https://github.com/Jack-Zhang-1314/hexoPage.git        fetch <span class="token operator">=</span> +refs/heads/*:refs/remotes/origin/*<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">├─logs│  │  HEAD│  ││  ├─refs│  │    ├─heads│  │    │      dev│  │    │      master│  │    ││  │    └─remotes│  │        └─origin│  │            │  HEAD│  │            └─ master├─origin│  │     HEAD│  └---  master              <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>当提交远程之后,本地分支和远程分支是同步的</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># commit 4a71286c54dc6629322f13cfded0dfcdb417a1aa (HEAD -> master, origin/master, origin/HEAD)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="对象压缩"><a href="#对象压缩" class="headerlink" title="对象压缩"></a>对象压缩</h2><ol><li><p>查看git对象文件的大小</p> <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">du</span> -h .git/objects<span class="token comment"># ...</span><span class="token comment"># 1.1M    .git/objects/fa</span><span class="token comment"># 944K    .git/objects/fd</span><span class="token comment"># 0       .git/objects/info</span><span class="token comment"># 22M     .git/objects/pack</span><span class="token comment"># 42M     .git/objects</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>使用<code>git gc</code>来压缩文件</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> gc<span class="token function">du</span> -h .git/objects<span class="token comment"># 9.0K    .git/objects/info</span><span class="token comment"># 23M     .git/objects/pack</span><span class="token comment"># 23M     .git/objects</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>查看<code>pack</code>文件下文件的大小.文件被压缩到<code>.pack</code>文件中</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">ls</span> -l .git/objects/pack<span class="token comment"># total 23092</span><span class="token comment"># -r--r--r-- 1 15531 197609   122816  7月  2 06:21 pack-04c2ed0bfb1961df8ecdaf3a6a602936173ffc88.idx</span><span class="token comment"># -r--r--r-- 1 15531 197609 23521212  7月  2 06:21 pack-04c2ed0bfb1961df8ecdaf3a6a602936173ffc88.pack</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ol><blockquote><p>解压缩<code>git unpack-objects</code></p></blockquote><ul><li>首先<code>.pack</code>文件不能再<code>objects</code>文件下,将它移到<code>.git</code>下后,使用解压缩的命令</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> unpack-objects <span class="token operator">&lt;</span> .git/pack-04c2ed0bfb1961df8ecdaf3a6a602936173ffc88.pack<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="垃圾对象清理"><a href="#垃圾对象清理" class="headerlink" title="垃圾对象清理"></a>垃圾对象清理</h2><blockquote><p>在大部分时候每次使用<code>git add</code>会产生不必要的垃圾对象,这时候就需要使用<code>git prune</code>去清理这些不必要的对象</p></blockquote><ul><li>不过一般情况下在使用<code>git gc</code>完全足够,他会去调用<code>git prune</code>清理不必要的对象</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> prune -n<span class="token comment"># 查看将会删除的不必要的垃圾对象</span><span class="token function">git</span> <span class="token function">fsck</span><span class="token comment">#查看仓库的垃圾对象</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;分支&quot;&gt;&lt;a href=&quot;#分支&quot; class=&quot;headerlink&quot; title=&quot;分支&quot;&gt;&lt;/a&gt;分支&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;通过&lt;code&gt;HEAD&lt;/code&gt;文件可以知道当前在哪个分支工作,并且&lt;strong&gt;HEAD指向的分支&lt;/s</summary>
      
    
    
    
    <category term="git" scheme="http://mail.zyjcould.ltd/categories/git/"/>
    
    
    <category term="git" scheme="http://mail.zyjcould.ltd/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>git原理(对象)</title>
    <link href="http://mail.zyjcould.ltd/2022/07/02/git-yuan-li-dui-xiang/"/>
    <id>http://mail.zyjcould.ltd/2022/07/02/git-yuan-li-dui-xiang/</id>
    <published>2022-07-01T19:38:49.000Z</published>
    <updated>2022-07-08T19:37:38.208Z</updated>
    
    <content type="html"><![CDATA[<h2 id="初始化git"><a href="#初始化git" class="headerlink" title="初始化git"></a>初始化git</h2><ul><li>git init:初始化本地git仓库</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#四个文件</span>config  description  FETCH_HEAD  HEAD  <span class="token comment">#四个文件夹</span>hooks  info  objects  refs<span class="token comment">#展开的文件</span>├─hooks├─info│     exclude├─objects│  ├─info│  └─pack└─refs    ├─heads    └─tags<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="工作区与暂存区"><a href="#工作区与暂存区" class="headerlink" title="工作区与暂存区"></a>工作区与暂存区</h2><ol><li><p>创建文件的时候,<code>.git</code>文件并不会发生任何变化,因为它是存储在工作区中的</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable"><span class="token variable">`</span><span class="token builtin class-name">echo</span> <span class="token string">"hello"</span> <span class="token operator">></span> hello.txt<span class="token variable">`</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>使用<code>git add hello.txt</code>去将其提交到暂存区</p><ul><li>这时候会多出一个文件<code>index</code>,和一个文件夹<code>2a</code></li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">│  config│  description│  FETCH_HEAD│  HEAD│  index│├─hooks│├─info│      exclude│├─objects│  ├─2a│  │      93d00994fbd8c484f38b0423b7c42e87a55d48│  ││  ├─info│  └─pack└─refs    ├─heads    └─tags<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>查看文件的类型:<strong>文件的目录名称+SHA1前面的四位</strong><ul><li><code>-t</code>:查看对象的类型</li><li><code>-p</code>:查看对象的内容</li><li><code>-s</code>:查看大小</li></ul></li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> cat-file -t 2a93d0<span class="token comment"># blob</span><span class="token function">git</span> cat-file -p 2a93d0<span class="token comment"># ÿþhello</span><span class="token function">git</span> cat-file -s 2a93d0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>git add</code>存储文件:<code>文件类型(这里是blob) + 文件内容</code>,然后进行<code>SHA1</code>加密</li><li>在<code>objects</code>中文件的内容会被压缩后存储到加密之后的文件中</li></ul></li><li><p>查看<code>index</code>文件,使用<code>git ls-files</code>可以查看暂存区(index)的文件情况</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> ls-files -s<span class="token comment"># 权限      blob对象                                        文件名</span><span class="token comment"># 100644 2a93d00994fbd8c484f38b0423b7c42e87a55d48 0       hello.txt</span><span class="token comment"># 100644 190b00d560cb8ac4e17678e8fccc7a2af8057bdd 0       temp.txt</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h2 id="git-commit"><a href="#git-commit" class="headerlink" title="git commit"></a>git commit</h2><ul><li>没有提交前暂存的情况</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">├─info│      exclude│├─objects│  ├─19│  │      0b00d560cb8ac4e17678e8fccc7a2af8057bdd│  ││  ├─2a│  │      93d00994fbd8c484f38b0423b7c42e87a55d48│  ││  ├─info│  └─pack└─refs    ├─heads    └─tags<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>提交之后</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">├─info│      exclude│├─logs│  │  HEAD│  ││  └─refs│      └─heads│              master│├─objects│  ├─19│  │      0b00d560cb8ac4e17678e8fccc7a2af8057bdd│  ││  ├─2a│  │      93d00994fbd8c484f38b0423b7c42e87a55d48│  ││  ├─a0│  │      197cf5327fec251ae14d063fb50d6d3e570674│  ││  ├─a3│  │      d91d125103f57b7b60d7ebd6502aa0987828ab│  ││  ├─info│  └─pack└─refs    ├─heads    │      master    │    └─tags<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>查看<code>commit</code>对象内容和类型</p></blockquote><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> cat-file -t a3d91d12<span class="token comment"># commit</span><span class="token function">git</span> cat-file -p a3d91d12<span class="token comment"># tree a0197cf5327fec251ae14d063fb50d6d3e570674</span><span class="token comment">#                                                   时间戳      时区</span><span class="token comment"># author Jack-Zhang-1314 &lt;zyj17715640603@gmail.com> 1656707371 +0800</span><span class="token comment"># committer Jack-Zhang-1314 &lt;zyj17715640603@gmail.com> 1656707371 +0800</span><span class="token comment"># </span><span class="token comment"># 1st commit</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>查看<code>tree</code>对象的内容和类型</p></blockquote><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> cat-file -t a0197c<span class="token comment">#tree</span><span class="token function">git</span> cat-file -p a0197c<span class="token comment"># 100644 blob 2a93d00994fbd8c484f38b0423b7c42e87a55d48    hello.txt</span><span class="token comment"># 100644 blob 190b00d560cb8ac4e17678e8fccc7a2af8057bdd    temp.txt</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>查看commit对象和指针<code>HEAD</code></p></blockquote><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">cat</span> .<span class="token punctuation">\</span>.git<span class="token punctuation">\</span>refs<span class="token punctuation">\</span>heads<span class="token punctuation">\</span>master<span class="token comment"># a3d91d125103f57b7b60d7ebd6502aa0987828ab</span><span class="token function">cat</span> .git/HEAD<span class="token comment"># ref: refs/heads/master</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">                          ----------<span class="token operator">></span> hello.txt                          <span class="token operator">|</span>commit<span class="token punctuation">(</span>tree中的内容<span class="token punctuation">)</span> ---<span class="token operator">></span> tree<span class="token punctuation">(</span>包含blob对象文件<span class="token punctuation">)</span>                          <span class="token operator">|</span>                          ----------<span class="token operator">></span> temp.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="修改commit"><a href="#修改commit" class="headerlink" title="修改commit"></a>修改commit</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">│├─objects│  ├─19│  │      0b00d560cb8ac4e17678e8fccc7a2af8057bdd│  ││  ├─2a│  │      93d00994fbd8c484f38b0423b7c42e87a55d48│  ││  ├─65│  │      4580c8026cf5b0ab07c5572f353409e3c83792│  ││  ├─80│  │      993781b54ed1b81e47a31e6427940c1a9deafb│  ││  ├─a0│  │      197cf5327fec251ae14d063fb50d6d3e570674│  ││  ├─a3│  │      d91d125103f57b7b60d7ebd6502aa0987828ab│  ││  ├─b2│  │      7787b75a99a614f3b26fe482f0cd47bc3c186b│  ││  ├─info│  └─pack<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>查看最新提交的commit</p></blockquote><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> cat-file -p b27787      <span class="token comment"># tree 654580c8026cf5b0ab07c5572f353409e3c83792</span><span class="token comment"># parent a3d91d125103f57b7b60d7ebd6502aa0987828ab  (上一次提交)</span><span class="token comment"># author Jack-Zhang-1314 &lt;zyj17715640603@gmail.com> 1656708529 +0800</span><span class="token comment"># committer Jack-Zhang-1314 &lt;zyj17715640603@gmail.com> 1656708529 +0800</span><span class="token comment"># </span><span class="token comment"># 2st commit</span><span class="token comment"># tree中的内容依然会指向这两个文件</span><span class="token function">git</span> cat-file -p <span class="token number">654580</span><span class="token comment"># 100644 blob 80993781b54ed1b81e47a31e6427940c1a9deafb    hello.txt</span><span class="token comment"># 100644 blob 190b00d560cb8ac4e17678e8fccc7a2af8057bdd    temp.txt</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>修改暂存区的文件</p></blockquote><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> cat-file -p <span class="token number">8099378</span><span class="token comment"># hello world </span><span class="token function">git</span> cat-file -t <span class="token number">8099378</span><span class="token comment"># blob</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="git的文件状态"><a href="#git的文件状态" class="headerlink" title="git的文件状态"></a>git的文件状态</h2><ol><li><code>Untrack</code>:工作区新创建的文件.使用<code>git add</code>将文件变为<code>Staged</code></li><li><code>Modified</code>:文件已经在<code>index(Staged状态)</code>,然后在工作区修改,也可以使用<code>git add</code>变为<code>Staged</code></li><li><code>Staged</code>:使用<code>git commit</code>将文件变为<code>Unmodified</code></li><li><code>Unmodified</code></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;初始化git&quot;&gt;&lt;a href=&quot;#初始化git&quot; class=&quot;headerlink&quot; title=&quot;初始化git&quot;&gt;&lt;/a&gt;初始化git&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;git init:初始化本地git仓库&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class=&quot;line-</summary>
      
    
    
    
    <category term="git" scheme="http://mail.zyjcould.ltd/categories/git/"/>
    
    
    <category term="git" scheme="http://mail.zyjcould.ltd/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>githubAction元数据</title>
    <link href="http://mail.zyjcould.ltd/2022/05/21/githubaction-yuan-shu-ju/"/>
    <id>http://mail.zyjcould.ltd/2022/05/21/githubaction-yuan-shu-ju/</id>
    <published>2022-05-21T05:53:20.000Z</published>
    <updated>2022-07-08T19:37:38.047Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>创建action和使用workflows是两个不同的操作</p></blockquote><ol><li>使用<a href="https://docs.github.com/cn/actions/using-workflows/about-workflows">workflows</a>是一个自动化的过程<ul><li>由<code>.github/workflows</code>下的<code>yaml</code>文件定义,可以是事件,事件或者手动触发</li></ul></li><li>创建<a href="https://docs.github.com/cn/actions/creating-actions/about-custom-actions">action</a>可以创建自己的操作或者使用和自定义github社区分享的操作<ul><li>在操作主要元数据文件按来定义操作的输入,输出和主要进入点.元数据的文件名必须要<code>action.yml</code></li></ul></li></ol><h2 id="javascript操作"><a href="#javascript操作" class="headerlink" title="javascript操作"></a><a href="https://docs.github.com/cn/actions/creating-actions/creating-a-javascript-action">javascript操作</a></h2><ul><li>这里尝试演示一个使用actions元数据去编写一个issue自动提交</li></ul><blockquote><p><a href="https://docs.github.com/cn/actions/creating-actions/metadata-syntax-for-github-actions">GitHub Actions的元数据语法</a></p></blockquote><ul><li>在根目录下创建一个<code>action.yml</code>文件,并且文件名称只能是这个</li></ul><pre class="line-numbers language-js" data-language="js"><code class="language-js">name<span class="token operator">:</span> <span class="token string">"test one create issues"</span>description<span class="token operator">:</span> <span class="token string">"test create issues"</span>inputs<span class="token operator">:</span>  token<span class="token operator">:</span>    description<span class="token operator">:</span> <span class="token string">"ACTION_ACCESS"</span>    required<span class="token operator">:</span> <span class="token boolean">true</span>runs<span class="token operator">:</span>  using<span class="token operator">:</span> <span class="token string">"node16"</span>  main<span class="token operator">:</span> <span class="token string">"index.mjs"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>inputs</code>是指定从工作流(workflows)中获取对应的输入字段,<code>token</code>是工作流(workflows)中的名称</li><li><code>runs</code>:指定的操作,这里必须指定是JavaScript操作,复合操作还是Docker容器操作以及操作的执行方式<ul><li><p><code>using</code>:<strong>必要</strong>.指定<code>main</code>中代码的执行环境</p></li><li><p><code>main</code>:<strong>必要</strong>.包含操作的文件</p></li><li><p><code>pre</code>:允许您在<code>main:</code>操作开始之前，在作业开始时运行脚本</p></li><li><p><code>pre-if</code>:允许定义<code>pre</code>操作执行的条件.pre操作只会在满足<code>pre-if</code>中的条件运行.如果未设置,则<code>pre-if</code>默认使用<code>always()</code></p> <pre class="line-numbers language-yml" data-language="yml"><code class="language-yml"><span class="token key atrule">pre</span><span class="token punctuation">:</span> <span class="token string">'cleanup.js'</span><span class="token key atrule">pre-if</span><span class="token punctuation">:</span> runner.os == 'linux'<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p><code>post</code>:允许您在<code>main:</code>操作完成后,在作业结束时运行脚本</p><ul><li>例如,您可以使用<code>post:</code>终止某些进程或删除不需要的文件</li></ul></li><li><p><code>post-if</code>:允许定义的<code>post</code>操作执行的条件.和<code>pre-if</code>类似</p> <pre class="line-numbers language-yml" data-language="yml"><code class="language-yml"><span class="token key atrule">runs</span><span class="token punctuation">:</span>  <span class="token key atrule">using</span><span class="token punctuation">:</span> <span class="token string">'node16'</span>  <span class="token key atrule">main</span><span class="token punctuation">:</span> <span class="token string">'index.js'</span>  <span class="token key atrule">post</span><span class="token punctuation">:</span> <span class="token string">'cleanup.js'</span>  <span class="token key atrule">post</span><span class="token punctuation">:</span> <span class="token string">'cleanup.js'</span>  <span class="token key atrule">post-if</span><span class="token punctuation">:</span> runner.os == 'linux'<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><code>steps</code>:操作中的步骤.这里是符合操作,using必须指定–&gt;<code>using:&quot;composite&quot;</code></p><ul><li><code>shell</code>: <span style="color:red">如果有run操作,必须指定<code>shell</code></span></li></ul> <pre class="line-numbers language-js" data-language="js"><code class="language-js">runs<span class="token operator">:</span>  using<span class="token operator">:</span> <span class="token string">"composite"</span>  steps<span class="token operator">:</span>    <span class="token operator">-</span> run<span class="token operator">:</span> $<span class="token punctuation">&#123;</span><span class="token punctuation">&#123;</span> github<span class="token punctuation">.</span>action_path <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token operator">/</span>test<span class="token operator">/</span>script<span class="token punctuation">.</span>sh      shell<span class="token operator">:</span> bash<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>…</p></li></ul></li></ul><blockquote><p>编写index.js文件</p></blockquote><ul><li><p>下载octokit:<code>pnpm add octokit</code>,这里需要使用这个包对github暴露的接口进行操作</p></li><li><p>下载<code>@actions/core</code>:<code>pnpm add @actions/core</code>,该包提供一个接口,用于工作流程命令,输入和输出变量,退出状态以及调试</p> <pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">import</span> <span class="token punctuation">&#123;</span> Octokit <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">"octokit"</span><span class="token keyword">import</span> <span class="token punctuation">&#123;</span> getInput <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">"@actions/core"</span><span class="token keyword">import</span> dayjs <span class="token keyword">from</span> <span class="token string">"dayjs"</span><span class="token punctuation">;</span><span class="token keyword">const</span> token <span class="token operator">=</span> <span class="token function">getInput</span><span class="token punctuation">(</span><span class="token string">"token"</span><span class="token punctuation">)</span><span class="token keyword">const</span> octokit <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Octokit</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>  auth<span class="token operator">:</span> token<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">await</span> octokit<span class="token punctuation">.</span>rest<span class="token punctuation">.</span>issues<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>  owner<span class="token operator">:</span> <span class="token string">"Jack-Zhang-1314"</span><span class="token punctuation">,</span>  repo<span class="token operator">:</span> <span class="token string">"demo"</span><span class="token punctuation">,</span>  title<span class="token operator">:</span> <span class="token function">getTitle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  body<span class="token operator">:</span> <span class="token function">getBody</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">getTitle</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">return</span> <span class="token function">dayjs</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token string">"YYYY-MM-DD"</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">function</span> <span class="token function">getBody</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">return</span> <span class="token string">"* test a new task"</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>这里的<code>auth:token</code>,是获取的<code>workflows</code>中<code>with</code>关键字设置的输入参数</p></li></ul><blockquote><p>编写工作流<code>workflows</code></p></blockquote><pre class="line-numbers language-js" data-language="js"><code class="language-js">on<span class="token operator">:</span> <span class="token punctuation">[</span>push<span class="token punctuation">]</span>jobs<span class="token operator">:</span>  test_one_issues<span class="token operator">:</span>    runs<span class="token operator">-</span>on<span class="token operator">:</span> ubuntu<span class="token operator">-</span>latest    name<span class="token operator">:</span> create issues action    steps<span class="token operator">:</span>      <span class="token operator">-</span> name<span class="token operator">:</span> Checkout        uses<span class="token operator">:</span> actions<span class="token operator">/</span>checkout@v3      <span class="token operator">-</span> name<span class="token operator">:</span> node        uses<span class="token operator">:</span> actions<span class="token operator">/</span>setup<span class="token operator">-</span>node@v3<span class="token punctuation">.</span><span class="token number">0.0</span>        <span class="token keyword">with</span><span class="token operator">:</span>          node<span class="token operator">-</span>version<span class="token operator">:</span> <span class="token string">"16.x"</span>      <span class="token operator">-</span> name<span class="token operator">:</span> install        run<span class="token operator">:</span> npm install      <span class="token operator">-</span> name<span class="token operator">:</span> create issues        uses<span class="token operator">:</span> <span class="token punctuation">.</span><span class="token operator">/</span>        <span class="token keyword">with</span><span class="token operator">:</span>          token<span class="token operator">:</span> $<span class="token punctuation">&#123;</span><span class="token punctuation">&#123;</span>secrets<span class="token punctuation">.</span><span class="token constant">ACTION_ACCESS</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>最后一个<code>create issues</code>中的<code>uses:./</code>就是指定根路径下自己的action元数据<code>action.yml</code></li><li><code>with</code>就是传给<code>action.yml</code>的键值对.并且在index.js中使用了<code>@action/core</code>中的<code>getInput</code>获取</li></ul><blockquote><p>如果只想打包dist文件到仓库,可以使用<code>@vercel/ncc</code>这个包.这个包只会把引用的模块加载到dist包中</p></blockquote><ul><li>下载ncc包:<code>pnpm add @vercel/ncc</code></li><li>然后添加脚本:<code>&quot;build&quot;: &quot;ncc build index.mjs --license licenses.txt&quot;</code></li><li>运行之后就可以使用dist包每天更新issue了</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;创建action和使用workflows是两个不同的操作&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;使用&lt;a href=&quot;https://docs.github.com/cn/actions/using-workflows/about-</summary>
      
    
    
    
    <category term="git" scheme="http://mail.zyjcould.ltd/categories/git/"/>
    
    
    <category term="git" scheme="http://mail.zyjcould.ltd/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>git回滚与撤销</title>
    <link href="http://mail.zyjcould.ltd/2022/04/30/git-hui-gun-yu-che-xiao/"/>
    <id>http://mail.zyjcould.ltd/2022/04/30/git-hui-gun-yu-che-xiao/</id>
    <published>2022-04-30T12:12:52.000Z</published>
    <updated>2022-07-08T19:37:38.135Z</updated>
    
    <content type="html"><![CDATA[<h2 id="撤销"><a href="#撤销" class="headerlink" title="撤销"></a>撤销</h2><ol><li><p>存在工作目录.代码并没有提交到暂存区(没有进行<code>git add</code>操作).在工作树中修改</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 需要撤销的文件或者 .(当前目录)</span><span class="token function">git</span> checkout <span class="token operator">&lt;</span>filname<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>代码提交到暂存区(进行了<code>git add</code>),但是想要撤销提交</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 需要从暂存区撤销的提交</span><span class="token function">git</span> reset HEAD <span class="token operator">&lt;</span>filename<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>代码已经提交(<code>git commit</code>)</p><ul><li>已经进行多次提交,但是在最后一次修改后,不再产生新的提交</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 注释名为最后一次的</span><span class="token function">git</span> commit --amend -m <span class="token string">"最后一次的注释"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ol><blockquote><p>如果想撤销到其中某次commit</p></blockquote><ul><li>这些操作分别是对<strong>工作目录</strong>,<strong>暂存区</strong>,<strong>当前HEAD</strong>的位置的改变</li><li><code>git reset [--hard|soft|mixed|merge|keep] [commit|HEAD]</code><ol><li><code>--hard</code>:重设当前<code>HEAD</code>位置.并将之前commit以来的<strong>工作区目录</strong>和<strong>暂存区</strong>的改变都丢弃<ul><li>彻底回退到某一个版本.本地所欲的源码也会变为上一个版本的内容</li><li>例如<code>git reset --hard HEAD~1</code>:将代码回退到前一次提交,并且将之前的所有改变丢弃</li></ul></li><li><code>--soft</code>:只重设当前<code>HEAD</code>位置.所有更改的文件会回到<strong>工作区目录</strong>和<strong>暂存区</strong><ul><li><code>git status</code>可以查看回退的状态.只是回退了提交的信息,不会回退提交的内容.</li></ul></li><li><code>--mixed</code>:重设当前<code>HEAD</code>位置和<strong>暂存区</strong>位置.但是不会重设<strong>工作区</strong>的内容<ul><li><code>git status</code>:查看回退的状态.已经回退到初始状态(没有使用<code>git add</code>之前)</li><li>例如<code>git reset --mixed HEAD~1</code>:将代码回退到上一次提交.提交内容保留在工作区</li></ul></li></ol></li></ul><h2 id="回滚"><a href="#回滚" class="headerlink" title="回滚"></a>回滚</h2><blockquote><p>如果已经使用<code>git push</code>,推送到远程仓库中.对已经提交到远程仓库的还原操作叫回滚</p></blockquote><ol><li>撤销本地仓库的提交<ul><li><code>revert</code>:放弃指定提交的修改,会生成一次新的提交,并且以前的历史记录都在<ul><li>例如:<code>git revert HEAD~1</code>.将代码回滚到上一次的提交,但是不会销毁之前提交,并且生成一个新的提交</li></ul></li><li><code>reset</code>:是指将HEAD指针指到指定提交,历史记录中不会出现放弃的提交记录(会销毁之前的提交)</li></ul></li><li>对远程仓库的提交进行回滚(撤销远程仓库的提交)<ul><li>需要强制将本地回退的代码推到远程仓库,进行回滚操作</li><li><code>git push origin 本地分支 --force-with-lease</code></li><li><code>--force-with-lease</code>并不会像<code>--force</code>强制将代码覆盖<ul><li>如果远端有其他人推送了新的提交,那么推送将被拒绝,并且和<code>--force</code>参数时的拒绝是一样的</li><li>如果远端没有其他人推送,会直接进行强制推送(<strong>回滚</strong>)</li></ul></li></ul></li></ol><blockquote><p>如果没有其他人推送提交时</p></blockquote><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> reset --hard HEAD~1<span class="token function">git</span> push origin 本地分支 --force-with-lease<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><blockquote><p>当遇到其他人推送新的提交时(产生冲突),需要使用<code>git fetch</code></p></blockquote><ul><li>在<code>git fetch</code>之后需要合并fetch下的分支.需要考虑使用<code>rebase</code>和<code>merge</code>情况<ul><li><code>rebase</code>会将分支合并到一个分支,不会保留被合并分支的提交记录.保证主分支的纯粹<ul><li><img src="./rebase.png" alt=" "></li></ul></li><li><code>merge</code>会将分支合并到一个分支,会保留被合并分支的提交记录<ul><li><img src="./merge.png" alt=" "></li></ul></li></ul></li><li>在开发中尽量选择rebase合并分支,来保证主分支的清晰</li><li>继续推送以达到回滚的效果</li></ul><h3 id="merge和rebase"><a href="#merge和rebase" class="headerlink" title="merge和rebase"></a>merge和rebase</h3><ul><li><code>rebase</code>:下游分支更新上游分支内容的时候使用</li><li><code>merge</code>:上游分支合并下游分支内容的时候使用</li><li><code>git pull origin dev --rebase</code>更新当前分支的内容时一定要使用<code>--rebase</code>参数</li></ul><blockquote><p>例如现有上游分支<code>master</code>,基于<code>master</code>分支拉出来一个开发分支<code>dev</code>,在<code>dev</code>上开发了一段时间后要把<code>master</code>分支提交的新内容更新到 <code>dev</code>分支</p><p>此时切换到<code>dev</code>分支,使用<code>git rebase master</code>等<code>dev</code>分支开发完成了之后,要合并到上游分支<code>master</code>上的时候,切换到<code>master</code>分支,使用<code>git merge dev</code></p></blockquote><h3 id="撤销回退"><a href="#撤销回退" class="headerlink" title="撤销回退"></a>撤销回退</h3><p><img src="./resetback.png" alt=" "></p><blockquote><p>如果在回退的时候回退过了怎么办</p></blockquote><ol><li><p>使用<code>git reflog</code>找到当前的提交记录的<code>commit</code>值(hash值)</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">bf75e3e <span class="token punctuation">(</span>HEAD -<span class="token operator">></span> dev, upstream/master, origin/test, origin/master, origin/dev, origin/HEAD<span class="token punctuation">)</span> HEAD@<span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">&#125;</span>: reset: moving to HEAD~1e87c01a HEAD@<span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">&#125;</span>: reset: moving to HEAD~4<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p><code>git checkout bf75e3e</code>.检出需要撤销到某一版本的提交</p></li><li><p><code>git branch mer</code>为需要找回的版本创建新分支</p></li><li><p><code>git branch dev</code>&amp;&amp;<code>git rebase mer</code>切换分支并且合并分支</p></li><li><p><code>git push origin dev --force-with-lease</code>.强制推送到远程仓库,完成撤销的回退</p></li></ol><h2 id="stash"><a href="#stash" class="headerlink" title="stash"></a>stash</h2><blockquote><p><code>git stash</code>将工作副本暂时搁置到到一个栈(提交越迟,越早弹出,即索引越小)中,以便切换分支处理其他内容</p></blockquote><ul><li><p><code>git stash</code>:如果当前分支中的内容处于已暂存的状态(<code>git add .</code>)</p><ul><li><code>git stash -u</code>:如果当前分支未暂存,则需要添加<code>--include-untracked</code></li><li>**注意:**一些基础配置文件不能暂存,需要立刻提交,如<code>.gitignore</code>等</li></ul><pre class="line-numbers language-.gitignore" data-language=".gitignore"><code class="language-.gitignore">*.js<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>如果此时<code>.gitignore</code>没有提交,这时候忽略<code>.js</code>结尾的文件并不会起作用,<code>.js</code>结尾的文件会和<code>.gitignore</code>一起被搁置到<strong>栈</strong>中(但是此时切换分支忽略文件依然会被切换到另一个分支)</li></ul></li><li><p><code>git stash save &quot;message&quot;</code>:如果需要搁置多个内容到栈中,则可以使用<code>message</code>来命名</p><ul><li>同样,如果没有暂存则需要使用<code>git stash save &quot;message&quot; -u</code></li></ul></li></ul><blockquote><p>重新应用搁置栈中的工作副本</p></blockquote><ol><li><p><code>git stash apply stash@&#123;index&#125;</code>:重新应用搁置栈中的工作副本,但是不会删除当前栈中暂存的状态</p><ul><li><code>git stash drop stash@&#123;index&#125;</code>:删除某个栈中的工工作副本,需要使用索引</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> stash drop stash@<span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p><code>git stash pop</code>:弹出最后一次提交到栈中的工作副本,并且同时删除栈中的工作副本</p><ul><li>或者直接指定需要应用的版本,与<code>apply</code>相同</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># index指索引号,索引越小,离栈顶越近</span> <span class="token function">git</span> stash <span class="token punctuation">(</span> pop <span class="token operator">|</span> apply <span class="token punctuation">)</span> --index index<span class="token comment"># 或者直接使用 stash@&#123;index&#125;</span> <span class="token function">git</span> stash <span class="token punctuation">(</span> pop <span class="token operator">|</span> apply <span class="token punctuation">)</span> stash@<span class="token punctuation">&#123;</span>index<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ol><blockquote><p>清理栈中的内容</p></blockquote><ol><li><code>git stash clear</code>:将栈中的所有内容清理</li><li><code>git stash drop</code>:清理指定版本</li></ol><blockquote><p>查看存储差异(需要暂存之后才可以比较:<code>git add .</code>)</p></blockquote><ol><li><code>git stash show</code>:查看存储的摘要</li><li><code>git stash show -p</code>:查看存储的完整差异(-p&#x3D;–patch)</li></ol><blockquote><p>从stash中创建分支</p></blockquote><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> stash branch <span class="token operator">&lt;</span>name<span class="token operator">></span> stash@<span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>在此分支的基础上:创建一个叫做&lt;name&gt;的分支,同时删除<code>stash&#123;1&#125;</code>的存储.此时指针不会指向原来分支,而是会指向&lt;name&gt;分支</li><li>如果在最新版本中遇到冲突时,这将会很有用<ul><li>例如你搁置了该文件的更改到栈中,但是之后并没有理会,继续在该文件中做更改,这是就可以使用此方法</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;撤销&quot;&gt;&lt;a href=&quot;#撤销&quot; class=&quot;headerlink&quot; title=&quot;撤销&quot;&gt;&lt;/a&gt;撤销&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;存在工作目录.代码并没有提交到暂存区(没有进行&lt;code&gt;git add&lt;/code&gt;操作).在工作树中修改&lt;/p&gt;
&lt;p</summary>
      
    
    
    
    <category term="git" scheme="http://mail.zyjcould.ltd/categories/git/"/>
    
    
    <category term="git" scheme="http://mail.zyjcould.ltd/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>rollup</title>
    <link href="http://mail.zyjcould.ltd/2022/04/23/rollup/"/>
    <id>http://mail.zyjcould.ltd/2022/04/23/rollup/</id>
    <published>2022-04-23T12:32:33.000Z</published>
    <updated>2022-04-24T12:15:42.799Z</updated>
    
    <content type="html"><![CDATA[<h2 id="cli"><a href="#cli" class="headerlink" title="cli"></a>cli</h2><ul><li><code>-c == --config &lt;filname&gt;</code>,指定<code>rollup.config.js</code>配置文件</li><li><code>-i == --input &lt;dirname&gt;</code>:入口文件</li><li><code>-o == --file &lt;output&gt;</code>:单个输出文件</li><li><code>-f == --format &lt;format&gt;</code>:打包风格<ul><li>amd, cjs, es, iife, umd, system</li></ul></li><li><code>-d == --dir &lt;dirname&gt;</code>:将输出文件块打包到目录</li><li><code>-w == --watch</code>:执行监听</li><li><code>--environment &lt;values&gt;</code>:设置环境变量<ul><li><code>--envirment TEST:123</code>可以通过<code>process.env.TEST</code>来获取变量的值</li></ul></li><li><code>-p == --plugin &lt;plugin&gt;</code>:使用插件<ul><li>如果在项目中使用rollup,不使用全局的rollup命令.需要使用npx:<code>npx rollup -c rollup.config.js</code></li></ul></li></ul><h2 id="配置项"><a href="#配置项" class="headerlink" title="配置项"></a><a href="https://rollupjs.org/guide/en/#configuration-files">配置项</a></h2><ul><li>如果想要不同的配置文件,可以使用一个数组,在数组中配置各个对象</li></ul><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">export</span> <span class="token keyword">default</span><span class="token punctuation">[</span>  <span class="token punctuation">&#123;</span>input<span class="token operator">:</span><span class="token operator">...</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span>  <span class="token punctuation">&#123;</span>input<span class="token operator">:</span> <span class="token operator">...</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span>  <span class="token operator">...</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><ul><li>input:指定打包文件的入口</li><li>output:指定输出文件的出口</li></ul></blockquote><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">&#123;</span>  input<span class="token operator">:</span> <span class="token string">"./index.js"</span><span class="token punctuation">,</span>  output<span class="token operator">:</span> <span class="token punctuation">&#123;</span>    <span class="token comment">//直接指定输出的文件夹</span>    file<span class="token operator">:</span> <span class="token string">"./dist/bundle.js"</span><span class="token punctuation">,</span>    format<span class="token operator">:</span> <span class="token string">"es"</span><span class="token punctuation">,</span>    name<span class="token operator">:</span><span class="token string">"bundle"</span><span class="token punctuation">,</span>    banner<span class="token operator">:</span><span class="token string">"/* hello */"</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>name:示bundles(捆绑包)的全局变量名称.例如<code>iife</code>,<code>umd</code>是必要的.同一页面上的其他脚本可以使用此变量名称来访问捆绑包的导出</p></li><li><p>banner:打包文件在最上行的介绍</p></li><li><p><code>output:[&#123;&#125;,&#123;&#125;...]</code>,<code>input</code>也可以写成数组的形式</p></li></ul><blockquote><p>多入口打包:input写成数组的形式</p></blockquote><ul><li>input可以写成数组的形式也可以写成对象的形式</li></ul><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">&#123;</span>  input<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">"./index.js"</span><span class="token punctuation">,</span> <span class="token string">"./test.js"</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  plugins<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token function">json</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  output<span class="token operator">:</span> <span class="token punctuation">&#123;</span>    dir<span class="token operator">:</span> <span class="token string">"dist"</span><span class="token punctuation">,</span>    format<span class="token operator">:</span> <span class="token string">"cjs"</span><span class="token punctuation">,</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>plugins:使用插件.例如<code>@rollup/plugin-json</code></p></blockquote><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">&#123;</span>  <span class="token operator">...</span>  plugins<span class="token operator">:</span><span class="token punctuation">[</span><span class="token function">json</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span>  <span class="token operator">...</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>rollup的插件是按照数组的加载顺序加载的</li><li>对于希望将依赖打包进自己的项目时,需要使用<code>@rollup/plugin-node-resolve</code>插件.并且最好放在第一个位置<ul><li>如果打包的依赖是只支持es项目,那么会和<code>@rollup/plugin-node-resolve</code>产生冲突.这时候最好需要下载<code>@rollup/plugin-commonjs</code></li></ul></li></ul><pre class="line-numbers language-js" data-language="js"><code class="language-js">plugins<span class="token operator">:</span><span class="token punctuation">[</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">commonjs</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">json</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><p><code>externals</code>:如果不想要将某个依赖打包进某个项目中,可以使用<code>externals</code></p><ul><li>可以是一个对象或者是数组.如果是数组,<code>[&quot;react&quot;]</code>默认的名字是<code>[&quot;React&quot;]</code>.如果不是这样命名的内库,可以使用对象的形式<code>&#123;&quot;react&quot;:&quot;React&quot;&#125;</code></li></ul></li><li><p><code>output</code>中的plugins.在编译之后启动,而不是编译之前.一般用于压缩代码.</p><ul><li>例如:<code>rollup-plugin-terser</code></li></ul></li></ul><h3 id="alias"><a href="#alias" class="headerlink" title="alias"></a><a href="https://github.com/rollup/plugins/tree/master/packages/alias">alias</a></h3><blockquote><p>用于别名的映射</p></blockquote><h3 id="babel"><a href="#babel" class="headerlink" title="babel"></a><a href="https://github.com/rollup/plugins/tree/master/packages/babel">babel</a></h3><blockquote><p>用于打包项目</p></blockquote><h3 id="replace"><a href="#replace" class="headerlink" title="replace"></a><a href="https://github.com/rollup/plugins/tree/master/packages/replace">replace</a></h3><blockquote><p>打包时变量替换(只能是数字或者字符串)</p></blockquote><h3 id="typescript"><a href="#typescript" class="headerlink" title="typescript"></a><a href="https://github.com/rollup/plugins/tree/master/packages/typescript">typescript</a></h3><ul><li>使用typescript:<code>npm install @rollup/plugin-typescript tslib typescript --save-dev</code></li></ul><h3 id="eslint"><a href="#eslint" class="headerlink" title="eslint"></a><a href="https://github.com/rollup/plugins/tree/master/packages/eslint">eslint</a></h3><ul><li>使用eslint:<code>yarn add -D @rollup/plugin-eslint eslint</code></li><li>eslint的一些插件<ul><li>eslint-config-standard</li><li>eslint-plugin-import</li><li>eslint-plugin-promise</li><li>eslint-plugin-node</li></ul></li></ul><h3 id="image"><a href="#image" class="headerlink" title="image"></a><a href="https://github.com/rollup/plugins/tree/master/packages/image">image</a></h3><ul><li>显示图像的 Base64 编码表示形式</li><li>静态文件可以使用:<code>rollup-plugin-copy</code></li></ul><h3 id="strip"><a href="#strip" class="headerlink" title="strip"></a><a href="https://github.com/rollup/plugins/tree/master/packages/strip">strip</a></h3><ul><li>打包时删除类似<code>debugger</code>,<code>assert.equal</code>和<code>console.log</code>函数的语句和函数</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;cli&quot;&gt;&lt;a href=&quot;#cli&quot; class=&quot;headerlink&quot; title=&quot;cli&quot;&gt;&lt;/a&gt;cli&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;-c == --config &amp;lt;filname&amp;gt;&lt;/code&gt;,指定&lt;code&gt;rollup.c</summary>
      
    
    
    
    <category term="JS" scheme="http://mail.zyjcould.ltd/categories/JS/"/>
    
    
    <category term="config" scheme="http://mail.zyjcould.ltd/tags/config/"/>
    
    <category term="JS" scheme="http://mail.zyjcould.ltd/tags/JS/"/>
    
    <category term="TS" scheme="http://mail.zyjcould.ltd/tags/TS/"/>
    
    <category term="vue" scheme="http://mail.zyjcould.ltd/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>FLIP</title>
    <link href="http://mail.zyjcould.ltd/2022/04/19/flip/"/>
    <id>http://mail.zyjcould.ltd/2022/04/19/flip/</id>
    <published>2022-04-19T09:02:23.000Z</published>
    <updated>2022-04-19T11:50:41.639Z</updated>
    
    <content type="html"><![CDATA[<h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><blockquote><p><code>Element.getBoundingClientRect()</code>:返回元素的大小及其<strong>相对于视口</strong>的位置</p></blockquote><ul><li><p>如果是标准盒子模型,元素的尺寸等于<code>width/height + padding + border-width</code>的总和.如果<code>box-sizing: border-box</code>,元素的的尺寸等于<code>width/height</code>.</p></li><li><p><code>DOMRect</code>:返回一个DOMRect对象.(DOMRect)代表一个矩形,表示盒子的类型右返回它的属性和方法决定</p></li><li><p><img src="././rect.png" alt=" "></p></li><li><p><strong>原点</strong>:当前视口的左上角(0,0)</p><ul><li><code>x</code>:矩形盒子的左边框(border)距离视口的左边的距离(可能为负数:当视口在盒子右边的时候)</li><li><code>y</code>:矩形盒子的上边框距离视口上边的距离(可能为负数:当漱口在盒子下边的时候)</li><li><code>height</code>:矩形盒子的高度</li><li><code>width</code>:矩形盒子的宽度</li><li><code>left</code>:视口到矩形盒子左边框的距离</li><li><code>right</code>:视口到矩形盒子有边框的距离</li><li><code>top</code>:视口到矩形盒子上边框的距离</li><li><code>bottom</code>:视口到矩形盒子下边框的距离</li></ul></li></ul><blockquote><p><code>Element.getClientRects()</code>:方法返回一个指向客户端中每一个盒子的边界矩形的矩形集合</p></blockquote><ul><li>返回<code>ClientRectList</code>:这是一个DOMRect的集合对象,属性和<code>getBoundingClientRect()</code>返回的方法一样<ul><li>如果是块级元素,只会返回一个数组,数组的内容和<code>getBoundingClientRect</code>一样</li><li>实际上,该方法主要用于内联元素,内联元素有多少行,该方法返回的对象有多少个成员.这个方法主要用于判断<strong>行内元素</strong>是否换行,以及<strong>行内元素</strong>的每一行的位置偏移</li></ul></li></ul><blockquote><p><code>DocumentOrShadowRoot.elementFromPoint(x: number, y: number): Element</code>:方法返回给定坐标点下最上层的<code>element</code>元素</p></blockquote><ul><li><p><strong>DocumentOrShadowRoot</strong>为<code>document</code>或者<code>shadowRoot</code>的接口</p></li><li><p>如果指定的坐标点在文档的可视范围外,或者两个坐标都是负数,那么结果返回null</p></li><li><p>如果该位置有多个元素层叠,则返回最上层的元素</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;API&quot;&gt;&lt;a href=&quot;#API&quot; class=&quot;headerlink&quot; title=&quot;API&quot;&gt;&lt;/a&gt;API&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;Element.getBoundingClientRect()&lt;/code&gt;:返回元素的大小及</summary>
      
    
    
    
    <category term="JS" scheme="http://mail.zyjcould.ltd/categories/JS/"/>
    
    
    <category term="JS" scheme="http://mail.zyjcould.ltd/tags/JS/"/>
    
    <category term="HTML" scheme="http://mail.zyjcould.ltd/tags/HTML/"/>
    
  </entry>
  
  <entry>
    <title>Jest</title>
    <link href="http://mail.zyjcould.ltd/2022/04/16/jest/"/>
    <id>http://mail.zyjcould.ltd/2022/04/16/jest/</id>
    <published>2022-04-16T13:34:37.000Z</published>
    <updated>2022-04-17T06:46:25.700Z</updated>
    
    <content type="html"><![CDATA[<h2 id="初始化一个test项目"><a href="#初始化一个test项目" class="headerlink" title="初始化一个test项目"></a>初始化一个test项目</h2><ol><li><code>npm i jest -D</code>:下载jest测试框架</li><li><code>npx jest --init</code>.初始化一个jest测试文件<ul><li>测试文件可以是ts或者js结尾的<code>jest.config.(js|ts)</code></li></ul></li><li>在<code>package.json</code>的脚本中写入<code>&quot;test&quot;:&quot;jest&quot;</code>配置<ul><li>jest是test本项目中的所有目录的测试文件</li></ul></li></ol><blockquote><p>进行一个commonjs模块的测试</p></blockquote><ol><li><p><code>math.js</code>文件中写入如下待测试代码</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span> b</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">return</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">function</span> <span class="token function">minus</span><span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span> b</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">return</span> a <span class="token operator">-</span> b<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">function</span> <span class="token function">multi</span><span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span> b</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">return</span> a <span class="token operator">*</span> b<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">&#123;</span> add<span class="token punctuation">,</span> minus<span class="token punctuation">,</span> multi <span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><code>math.test.js</code>导入测试代码</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">const</span> <span class="token punctuation">&#123;</span> add<span class="token punctuation">,</span> minus<span class="token punctuation">,</span> multi <span class="token punctuation">&#125;</span> <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">"./math"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token string">"测试加法 3 + 3"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>  <span class="token function">expect</span><span class="token punctuation">(</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toBe</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token string">"测试减法 3 - 3"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>  <span class="token function">expect</span><span class="token punctuation">(</span><span class="token function">minus</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toBe</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token string">"测试乘法 3 * 3"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>  <span class="token function">expect</span><span class="token punctuation">(</span><span class="token function">multi</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toBe</span><span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>运行<code>npm run test</code>可以看到终端有成功运行的样式</p></li></ol><h2 id="jest-config"><a href="#jest-config" class="headerlink" title="jest config"></a>jest config</h2><ol><li><p>jest可以直接使用命令行参数<code>--config &lt;path/to/file.js|cjs|mjs|json&gt;</code></p></li><li><p>jest可以直接在<code>package.json</code>中配置文件</p><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token punctuation">&#123;</span>    <span class="token property">"jest"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>直接使用<code>jest.config.(js|ts)</code>文件,在文件中配置</p></li></ol><blockquote><p>有如下的选项</p></blockquote><ul><li><p><code>automock</code>:<code>bool</code>默认值false.将所有的导入模块都自动mock</p><ul><li>但是当源文件下有<strong>mocks目录</strong>时,会自动mock.核心模块,如fs不会默认fock,需要手动设置<code>jest.mobk(&quot;fs&quot;)</code></li></ul></li><li><p><code>bail</code>:<code>number|bppl</code>.默认值是0.bail选项可以让你配置jest在经历几次失败后停止运行测试</p></li><li><p><code>browser</code>:<code>bool</code>默认值false.解析模块中是否遵循<code>package.json</code>中的<code>browser</code>字段</p><ul><li>有些模块导出的版本会不一样,取决于是在<strong>Node</strong>中还是<strong>浏览器</strong>中进行操作</li></ul></li><li><p><code>cacheDirectory</code>:<code>string</code>.默认值**&#x2F;tmp&#x2F;&lt;path&gt;**.用来储存依赖信息缓存目录</p></li><li><p><code>clearMocks</code>:<code>bool</code>.<strong>默认值false</strong>.在每个而是前自动清理mock的调用和实例instance</p><ul><li>相当于在每一个test之前调用<code>jest.clearAllMocks</code>,但不会删除已经有的mock实现</li></ul></li><li><p><code>collectCoverage</code>: <code>bool</code><strong>默认值false</strong>.是否打开代码覆盖率信息</p></li><li><p><code>collectCoverageFrom</code>:<code>array</code>.<strong>默认值undefined</strong>.表明哪些文件需要收集.如果文件匹配就会手机作为<code>coverage</code>的基数</p><ul><li>收集根目录下所有的js,jsx文件,同时排除node_modules下的所有文件</li><li>并且此参数需要<code>collectCoverage</code>被设置成true</li></ul><pre class="line-numbers language-js" data-language="js"><code class="language-js">collectCoverageFrom<span class="token operator">:</span><span class="token punctuation">[</span><span class="token string">"**/*.&#123;js,jsx&#125;"</span><span class="token punctuation">,</span><span class="token string">"!**/node_modules/**"</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p><code>coverageDirectory</code>:<code>string</code>.<strong>默认值undefined</strong>,输出覆盖信息文件的目录名称</p></li><li><p><code>coveragePathIgnorePatterns</code>:<code>[array&lt;string&gt;]</code>.<strong>默认值[node_modules]</strong>.排除出coverage的文件列表.</p></li><li><p><code>coverageProvider</code>:<code>string</code>.有两个选项,<code>v8</code>或者是<code>babel</code>.声明到底用哪个provider来用于指导代码的覆盖测试</p></li><li><p><code>coverageThreshold</code>:<code>object</code>.<strong>默认值undefined</strong>.该阈值作为覆盖最小阈值来设置.</p><ul><li>可以被设置为<code>global</code>,或者是目录及文件路径</li><li>如果没有达到阈值,则jest失败,如果给了一个正数,就表示最小的百分比值</li></ul><pre class="line-numbers language-js" data-language="js"><code class="language-js">coverageThreshold<span class="token operator">:</span> <span class="token punctuation">&#123;</span>    global<span class="token operator">:</span> <span class="token punctuation">&#123;</span>      <span class="token string">"branches"</span><span class="token operator">:</span> <span class="token number">80</span><span class="token punctuation">,</span>      <span class="token string">"functions"</span><span class="token operator">:</span> <span class="token number">80</span><span class="token punctuation">,</span>      <span class="token string">"lines"</span><span class="token operator">:</span> <span class="token number">80</span><span class="token punctuation">,</span>      <span class="token string">"statements"</span><span class="token operator">:</span> <span class="token operator">-</span><span class="token number">10</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><code>dependencyExtractor</code>:<code>string</code>.<strong>默认值undefined</strong>.允许等地依赖提取器的使用,必须满足是一个node modules,同时导出的object中包含<code>extract</code>函数</p></li><li><p><code>displayName</code>:<code>string | object</code>.<strong>默认值undefined</strong>.允许在测试的时候打印显示标签.这里有多个repo和多个jest配置文件的时候很好用</p> <pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token comment">//string</span>displayName<span class="token operator">:</span> <span class="token string">'CLIENT'</span><span class="token comment">//object</span>displayName<span class="token operator">:</span> <span class="token punctuation">&#123;</span> name<span class="token operator">:</span> <span class="token string">'CLIENT'</span><span class="token punctuation">,</span> color<span class="token operator">:</span> <span class="token string">'blue'</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><code>errorOnDeprecated</code>:<code>bool</code>.<strong>默认值false</strong>.针对国企的API抛出提示性的错误</p></li><li><p><code>extensionsToTreatAsEsm</code>:<code>Array&lt;string&gt;.</code><strong>默认值[]</strong>.将mjs字段视作esm模块.</p><ul><li>如果有其他文件使用ESM运行,需要在此处指定其文件的扩展名称</li></ul> <pre class="line-numbers language-js" data-language="js"><code class="language-js">extensionsToTreatAsEsm<span class="token operator">:</span><span class="token punctuation">[</span><span class="token string">".ts"</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p><code>extraGlobals</code>:<code>array&lt;string&gt;</code><strong>默认值undefined</strong>.测试文件在<a href="https://nodejs.org/api/vm.html">vm</a>中运行,会减慢全局上下文的属性的调用速度</p></li><li><p><code>forceCoverageMatch</code>:<code>array&lt;string&gt;</code>.在收集代码覆盖率的时候,通常会忽略测试文件.使用此选项,可以在coverage包含被忽略的文件</p></li><li><p><code>globals</code>:<code>object</code>.<strong>默认值{}</strong>.全局变量,需要在所有的测试环境中都可以使用</p> <pre class="line-numbers language-js" data-language="js"><code class="language-js">globals<span class="token operator">:</span><span class="token punctuation">&#123;</span>  <span class="token string">"__DEV__"</span><span class="token operator">:</span><span class="token boolean">true</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p><code>rootDir</code>:<code>string</code>.默认值<strong>jest配置文件的根目录</strong>.如果未找到则为<code>pwd</code></p><ul><li>通常可以设置为<code>src</code>或者<code>lib</code>为根目录,对应于代码在存储库中的存储位置</li></ul></li><li><p><code>roots</code>:<code>array&lt;string&gt;</code>.<strong>默认值[“<rootDir>“]</strong>.Jest 应用于在其中搜索文件的目录路径列表</p><ul><li>根据<code>rootDir</code>决定根目录所在的位置</li></ul></li><li><p><code>moduleFileExtensions</code>:<code>array&lt;string&gt;</code>.<strong>默认值[“js”, “jsx”, “ts”, “tsx”, “json”, “node”]</strong></p><ul><li>模块使用的文件扩展数组.如果未指定文件扩展名的模块,则这些事jest将俺从左到有顺序查找的扩展名.建议将常用的扩展名放置左侧</li></ul></li><li><p><code>moduleNameMapper</code>:<code>object&lt;string,string | array&lt;string&gt;&gt;</code>.正则表达式到模块名称或模块名称数组的映射(设置别名)</p></li><li><p><code>modulePathIgnorePatterns</code>:<code>object&lt;string&gt;</code>.<strong>默认值[]</strong>.定模块的路径与任何模式匹配,则它在测试环境中将不可用</p><ul><li>一个正则表达式模式字符串数组,这些字符串与所有模块路径匹配,然后这些路径将被视为对模块加载程序<strong>可见</strong></li><li>这些模式字符串与完整路径匹配<code>[&quot;&lt;rootDir&gt;/build/&quot;]</code></li></ul></li><li><p><code>transform</code>:<code>[object&lt;string, pathToTransformer | [pathToTransformer, object]&gt;]</code>.默认值<code>&#123;&quot;\\.[jt]sx?$&quot;: &quot;babel-jest&quot;&#125;</code></p><ul><li>从正则表达式到转换器路径的映射.这些编译器将<code>JavaScript</code>的未来版本编译为当前版本,或者可以配合ts,webpack使用</li></ul></li><li><p><code>transformIgnorePatterns</code>:<code>array&lt;string&gt;</code>.文件路径与任何模式匹配的时候,忽略这些匹配的文件</p><ul><li><strong>默认值:[“&#x2F;node_modules&#x2F;“, “\.pnp\.[^\/]+$”]</strong></li></ul></li></ul><h2 id="jest中es-ts的配置项"><a href="#jest中es-ts的配置项" class="headerlink" title="jest中es,ts的配置项"></a>jest中es,ts的配置项</h2><blockquote><p><code>npx jest --coverage</code>代码覆盖率</p></blockquote><ul><li>代码覆盖率会在控制台显示一个图表信息.并且有一个默认叫做<code>coverage</code>的文件夹.文件夹中的html文件就是对覆盖率的阐述</li><li>覆盖率就是编写的测试代码对原来的功能代码的占比,全部test,则为100%</li><li><span style="color:red">在配置文件中,初始化的时可以开启代码覆盖率的选项</span>,而不必使用cli的时候添加<code>--coverage</code><ol><li><code>collectCoverage: true</code>:是否打开代码覆盖率</li><li><code>coverageDirectory: &quot;coverage&quot;</code>:代码覆盖率生成的文件目录名称.可以自定义</li><li><code>coverageProvider: &quot;v8&quot;</code>:有两个选项,<code>v8</code>或者是<code>babel</code>.声明到底用哪个provider来用于指导代码的覆盖测试</li></ol></li></ul><blockquote><p><a href="https://jestjs.io/docs/ecmascript-modules">配置esm模块进行测试</a></p></blockquote><ol><li><p>首先需要在<code>package.json</code>中加入<code>&quot;type&quot;:modules</code>.不需要改<code>.js</code>为<code>.mjs</code></p></li><li><p>对于<code>jest.config.js</code>文件,不能使用默认的<code>module.exports</code>导出</p><ul><li>需要使用esm的方式导出配置</li></ul><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">export</span> <span class="token keyword">default</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>执行需要使用<code>NODE_OPTIONS=--experimental-vm-modules</code>这种形式设置环境变量</p><ul><li>在脚本中配置此环境变量并没有成功</li><li>这里我是直接使用<code>NODE_OPTIONS=--experimental-vm-modules npx jest</code>命令来运行此测试</li></ul></li></ol><blockquote><p>如果是ts项目,建议直接使用vitest直接进行TDD开发</p></blockquote><ul><li>vitest基于vite开发,完全适用于<code>vite.config.ts</code>配置</li><li>下载<code>npm i vitest -D</code></li></ul><ol><li><p>基于<code>vite.config.ts</code>配置vitest</p><ul><li>如果你使用<code>vite</code>的<code>defineConfig</code>你还需要将三斜线指令写在配置文件的顶部</li></ul><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">&#x2F;&#x2F;&#x2F; &lt;reference types&#x3D;&quot;vitest&quot; &#x2F;&gt;import &#123; defineConfig &#125; from &#39;vite&#39;export default defineConfig(&#123;  test: &#123;    &#x2F;&#x2F; ...  &#125;,&#125;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>基于<code>vitest.config.ts</code>配置vitest.</p><ul><li>此优先级高于<code>vite.config.ts</code>,可以直接使用vitest中的<code>defineConfig</code>配置</li></ul><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">import &#123; defineConfig &#125; from &#39;vitest&#x2F;config&#39;export default defineConfig(&#123;  test: &#123;    &#x2F;&#x2F; ...  &#125;,&#125;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>排除默认选项,自己配置测试的选项</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">import &#123; configDefaults, defineConfig &#125; from &#39;vitest&#x2F;config&#39;export default defineConfig(&#123;  test: &#123;    exclude: [...configDefaults.exclude, &#39;packages&#x2F;template&#x2F;*&#39;],  &#125;,&#125;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;初始化一个test项目&quot;&gt;&lt;a href=&quot;#初始化一个test项目&quot; class=&quot;headerlink&quot; title=&quot;初始化一个test项目&quot;&gt;&lt;/a&gt;初始化一个test项目&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;code&gt;npm i jest -D&lt;/code&gt;:下</summary>
      
    
    
    
    <category term="config" scheme="http://mail.zyjcould.ltd/categories/config/"/>
    
    
    <category term="config" scheme="http://mail.zyjcould.ltd/tags/config/"/>
    
    <category term="JS" scheme="http://mail.zyjcould.ltd/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>npm中的bin</title>
    <link href="http://mail.zyjcould.ltd/2022/04/16/npm-zhong-de-bin/"/>
    <id>http://mail.zyjcould.ltd/2022/04/16/npm-zhong-de-bin/</id>
    <published>2022-04-16T06:54:05.000Z</published>
    <updated>2022-04-16T08:02:49.842Z</updated>
    
    <content type="html"><![CDATA[<h2 id="bin"><a href="#bin" class="headerlink" title="bin"></a>bin</h2><blockquote><p>bin文件是一个二进制的脚本文件</p></blockquote><ul><li><p>一般文件内会有以下的字样等等,这就是平时运行的脚本文件的解释程序(<code>Shebang</code>)</p><ul><li><code>#!/usr/bin/env node</code>这段话的意思就是启用node进行脚本的解释程序</li><li><code>#!/bin/sh</code>:使用sh进行脚本的执行程序</li><li>并且在windows中同样可以使用(windows会忽略shengban,会根据程序的脚本名来指定运行的解释程序)</li></ul></li><li><p>可以查看一下typescript中的脚本配置</p> <pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token property">"bin"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>    <span class="token property">"tsc"</span><span class="token operator">:</span> <span class="token string">"./bin/tsc"</span><span class="token punctuation">,</span>    <span class="token property">"tsserver"</span><span class="token operator">:</span> <span class="token string">"./bin/tsserver"</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ul><ol><li><p>创建一个node的项目并且创建一个bin目录(用于存放脚本文件)</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">.</span>├── bin│   └── vli.js├── index.js└── package.json<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>在<code>package.json</code>配置bin字段,用于打包生成脚本命令</p><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token property">"bin"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>  <span class="token property">"v-vli"</span><span class="token operator">:</span><span class="token string">"./bin/vli.js"</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>在脚本文件中写入需要的命令<code>vli.js</code></p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token hashbang comment">#!/usr/bin/env node</span><span class="token keyword">function</span> <span class="token function">run</span> <span class="token punctuation">(</span><span class="token parameter">argv</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token string">'-v'</span> <span class="token operator">||</span> argv<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token string">'--version'</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'  version is 0.0.1'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token string">'-h'</span> <span class="token operator">||</span> argv<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token string">'--help'</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'  usage:\n'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'  -v --version [show version]'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token function">run</span><span class="token punctuation">(</span>process<span class="token punctuation">.</span>argv<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>打成全局包才可以使用该命令,打成全局包的命令<code>npm install . -g</code>或者<code>npm link</code></p></li><li><p>使用<code>v-cli -v</code>就可以查看输出的脚本命令了</p></li></ol><h2 id="npm-link"><a href="#npm-link" class="headerlink" title="npm link"></a>npm link</h2><blockquote><p><code>npm link</code>将npm模块链接到对应的运行项目中去,方便地对模块进行调试和测试</p></blockquote><ol><li>如果他是一个<code>bin</code>(二进制文件):他会被链接到全局的<code>&#123;prefix&#125;/bin</code>目录(node的全局目录)下,生成一个脚本文件,供全局使用</li><li>如果他是一个<code>lib</code>(库文件),他会被连接到<code>&#123;prefix&#125;/lib/node_modules/&lt;package&gt;</code>(node的全局目录),生成一个链接文件</li><li>一个文件项目中可能包含多个bin文件,一般通常只有一个lib文件</li></ol><ul><li>通过<code>npm config get prefix</code>命令获取到prefix的值</li></ul><blockquote><p><code>npm unlink &lt;package&gt;</code>:解除链接</p></blockquote><ol><li>如果是bin文件,解除的是bin配置的脚本名称,而不是项目的包名<ul><li>例如上面的脚本<code>npm unlink v-vli</code>.将全局的<code>v-vli</code>脚本移除</li></ul></li><li>如果是<code>lib</code>文件,他本质就是一个软链接,直接移除项目的包名<ul><li><code>npm unlink &lt;package&gt;</code>:将lib下的全局链接移除</li></ul></li></ol><blockquote><p>例子:例如需要开发一个module模块,并且在本地example项目中需要使用module包</p></blockquote><ol><li>在<code>module</code>中使用<code>npm link</code>被链接到全局的lib目录下</li><li>在<code>example</code>项目中使用<code>npm link module</code>后,此项目会软链接到<code>example/node_modules</code></li><li>这种软链接的形式,在module的修改同样会同步到<code>example/modules</code>中的软链接部分</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;bin&quot;&gt;&lt;a href=&quot;#bin&quot; class=&quot;headerlink&quot; title=&quot;bin&quot;&gt;&lt;/a&gt;bin&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;bin文件是一个二进制的脚本文件&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;一般文件内会</summary>
      
    
    
    
    <category term="config" scheme="http://mail.zyjcould.ltd/categories/config/"/>
    
    
    <category term="config" scheme="http://mail.zyjcould.ltd/tags/config/"/>
    
    <category term="JS" scheme="http://mail.zyjcould.ltd/tags/JS/"/>
    
    <category term="npm" scheme="http://mail.zyjcould.ltd/tags/npm/"/>
    
  </entry>
  
  <entry>
    <title>发布npm</title>
    <link href="http://mail.zyjcould.ltd/2022/04/15/fa-bu-npm/"/>
    <id>http://mail.zyjcould.ltd/2022/04/15/fa-bu-npm/</id>
    <published>2022-04-15T14:32:15.000Z</published>
    <updated>2022-07-14T17:19:44.668Z</updated>
    
    <content type="html"><![CDATA[<h2 id="字段"><a href="#字段" class="headerlink" title="字段"></a>字段</h2><ol><li><p>首先需要登录自己的npm账号<code>npm login</code></p></li><li><p>初始化一个项目<code>npm init</code></p><ul><li>最重要的两个字段<code>name</code>和<code>version</code></li></ul><blockquote><p><code>name</code></p></blockquote><ul><li>不要在name中包含js,node字样</li><li>这个名字最终会是URL的一部分,命令行的参数,目录名,所以不能以点号或下划线开头</li><li>这个名字可能在require()方法中被调用,所以应该尽可能短</li><li>并且包的名字不能与npm中的其他包的名字一致</li></ul><blockquote><p><code>version</code>:版本号.版本号基本是由三位数字组成</p></blockquote><ul><li><code>MAJOR</code>:进行不兼容的API更改时的版本</li><li><code>MINOR</code>:以向后兼容的方式添加功能时的版本</li><li><code>PATCH</code>:向后兼容的错误修复程序的版本</li></ul><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token number">1</span>   .   <span class="token number">0</span>   .   <span class="token number">0</span><span class="token punctuation">[</span>MAJOR<span class="token punctuation">]</span>.<span class="token punctuation">[</span>MINOR<span class="token punctuation">]</span>.<span class="token punctuation">[</span>PATCH<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">npm</span> version <span class="token punctuation">[</span><span class="token operator">&lt;</span>newversion<span class="token operator">></span> <span class="token operator">|</span> major <span class="token operator">|</span> minor <span class="token operator">|</span> patch <span class="token operator">|</span> premajor <span class="token operator">|</span> preminor <span class="token operator">|</span> prepatch <span class="token operator">|</span> prerelease <span class="token punctuation">[</span>--preid-<span class="token operator">&lt;</span>prerelease-id<span class="token operator">></span><span class="token punctuation">]</span> <span class="token operator">|</span> from-git<span class="token punctuation">]</span><span class="token string">'npm [-v | --version]'</span> to print <span class="token function">npm</span> version<span class="token string">'npm view &lt;pkg> version'</span> to view a package<span class="token string">'s published version'</span><span class="token function">npm</span> ls' to inspect current package/dependency versions<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><table><thead><tr><th>选项</th><th>描述</th><th>例子</th><th>说明</th></tr></thead><tbody><tr><td>major</td><td>重大更新版本</td><td>npm version major</td><td>0.2.0 -&gt;1.0.0</td></tr><tr><td>minor</td><td>主要更新版本</td><td>npm version minor</td><td>0.2.0 -&gt;0.3.0</td></tr><tr><td>patch</td><td>补丁更新版本</td><td>npm version patch</td><td>0.2.0 -&gt;0.2.1</td></tr><tr><td>premajor</td><td>重大更新预发布版本</td><td>npm version premajor</td><td>0.2.0 -&gt;1.0.0-0</td></tr><tr><td>preminor</td><td>主要更新预发布版本</td><td>npm version preminor</td><td>0.2.0 -&gt;0.3.0-0</td></tr><tr><td>prepatch</td><td>补丁更新预发布版本</td><td>npm version prepatch</td><td>0.2.0 -&gt;0.2.1-0</td></tr><tr><td>prerelease</td><td>预发布版本</td><td>npm version prerelease</td><td>当前版本不是预发布版本的会出错</td></tr><tr><td>from-git</td><td>取git的tag作为版本号设置至<code>package.json</code></td><td>npm version from-git</td><td>git的tag标签没有设置的情况下,会抛出错误</td></tr></tbody></table><ul><li>限定符<ul><li><code>^</code>:从左侧的第一个非<code>0</code>位置开始限定,例如<code>1.2.3&lt;=^1.2.3&lt;2.0.0</code>,<code>0.2.3&lt;=^0.2.3&lt;0.3.0</code></li><li><code>~</code>:从次版本号开始限定,例如<code>1.2.3&lt;=~1.2.3&lt;1.3.0</code>,但是如<code>~1.0.0</code>就没有此版本号</li><li><code>*</code>:不限定任何版本</li><li><code>-</code>:<code>1.2.3-1.2.6</code>,限定区间</li></ul></li></ul><blockquote><p><code>description</code>:对包进行描述,便于<code>npm search</code></p><p><code>repository</code>:本项目中代码的源地址位置</p></blockquote><ol><li><p>可以分层写出项目地址</p><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token punctuation">&#123;</span>  <span class="token property">"repository"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>    <span class="token property">"type"</span><span class="token operator">:</span> <span class="token string">"git"</span><span class="token punctuation">,</span>    <span class="token property">"url"</span><span class="token operator">:</span> <span class="token string">"https://github.com/npm/cli.git"</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>同时可以指定仓库名的形式</p><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token punctuation">&#123;</span>  <span class="token property">"repository"</span><span class="token operator">:</span> <span class="token string">"npm/npm"</span><span class="token punctuation">,</span>  <span class="token property">"repository"</span><span class="token operator">:</span> <span class="token string">"github:user/repo"</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ol><blockquote><p><code>keywords</code>:将关键字放入其中.它是一个字符串数组.便于使用<code>npm search</code></p></blockquote><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token punctuation">&#123;</span>   <span class="token property">"keywords"</span><span class="token operator">:</span> <span class="token punctuation">[</span>   <span class="token string">"test"</span><span class="token punctuation">,</span>   <span class="token string">"npm"</span><span class="token punctuation">,</span>   <span class="token string">"app"</span>   <span class="token punctuation">]</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><code>homepage</code>:项目的主页.用于展示项目</p></blockquote><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token property">"homepage"</span><span class="token operator">:</span> <span class="token string">"https://github.com/owner/project#readme"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p><code>main</code>:程序的主要入口点.一般用于require的引入</p></blockquote><ul><li>也就是说,如果您的包被命名为foo,并且用户安装了它,然后会执行<code>require(&quot;foo&quot;)</code>,则将返回主模块的exports 对象</li></ul><blockquote><p><code>module</code>:一般是esm模块的入口点,用于import的引入</p></blockquote><ul><li>如果包module被命名为foo,用户安装之后,然后执行<code>import...from &quot;foo&quot;</code>,会返回主模块</li></ul><blockquote><p><code>author</code>:作者信息</p></blockquote><ol><li><p>每个字段的形式分开展现</p><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token punctuation">&#123;</span>  <span class="token property">"name"</span> <span class="token operator">:</span> <span class="token string">"Barney Rubble"</span><span class="token punctuation">,</span>  <span class="token property">"email"</span> <span class="token operator">:</span> <span class="token string">"b@rubble.com"</span><span class="token punctuation">,</span>  <span class="token property">"url"</span> <span class="token operator">:</span> <span class="token string">"http://barnyrubble.tumblr.com/"</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>以<code>author</code>合并展示</p><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token punctuation">&#123;</span>  <span class="token property">"author"</span><span class="token operator">:</span> <span class="token string">"Barney Rubble &lt;b@rubble.com> (http://barnyrubble.tumblr.com/)"</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ol><blockquote><p><code>license</code>:许可证.让人知道使用的权利和限制的</p></blockquote><ul><li><a href="https://docs.github.com/en/communities/setting-up-your-project-for-healthy-contributions/adding-a-license-to-a-repository">参考github</a></li></ul></li></ol><h3 id="发布javascript版本的包"><a href="#发布javascript版本的包" class="headerlink" title="发布javascript版本的包"></a>发布javascript版本的包</h3><ol><li><p><code>name</code>:字段必须是仓库拥有者的名称,即<code>npm login</code>的名称</p><ul><li>由于作用域内包安装到作用域文件夹中,因此在代码中需要作用域时,必须包含作用域的名称</li><li>每个 npm 用户&#x2F;组织都有自己的作用域,只有你可以在作用域中添加包</li></ul><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'@myorg/mypackage'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p><code>npm publish</code>:npm中发布<strong>公共的作用域包</strong>需要使用<code>npm publish --access=public</code>(私有是收费的)</p></li><li><p><code>npm unpublish 包名</code>:即可将 npm 上的包删除</p></li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">npm</span> publish <span class="token punctuation">[</span><span class="token operator">&lt;</span>tarball<span class="token operator">>|</span><span class="token operator">&lt;</span>folder<span class="token operator">></span><span class="token punctuation">]</span> <span class="token punctuation">[</span>--tag <span class="token operator">&lt;</span>tag<span class="token operator">></span><span class="token punctuation">]</span> <span class="token punctuation">[</span>--access <span class="token operator">&lt;</span>public<span class="token operator">|</span>restricted<span class="token operator">></span><span class="token punctuation">]</span> <span class="token punctuation">[</span>--otp otpcode<span class="token punctuation">]</span> <span class="token punctuation">[</span>--dry-run<span class="token punctuation">]</span>Publishes <span class="token string">'.'</span> <span class="token keyword">if</span> no argument suppliedSets tag <span class="token string">'latest'</span> <span class="token keyword">if</span> no --tag specified<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>&lt;folder&gt;</code>:包含<code>package.json</code>文件的文件夹</li><li><code>&lt;tarball&gt;</code>:指向gzip压缩tar存档的url或文件路径,其中包含一个包含package.json文件的文件夹.</li><li><code>[--tag &lt;tag&gt;]</code>:使用给定标记注册已发布的包,以便安装此版本.默认情况下,更新并安装标记(参考<code>npm-dist-tag</code>)</li><li><code>[--access &lt;public|restricted&gt;]</code>:告知注册表此包是应发布为公共包还是受限制程序包.仅适用于作用域内包,缺省为<code>restricted --access</code>.如果没有付费帐户,则必须发布<code>public</code>方式才能发布作用域内的程序包.</li><li><code>[--otp &lt;otpcode&gt;]</code>:启用了双因素身份验证,则可以使用此代码提供来自身份验证器的代码.否则系统将提示<code>auth-and-writes</code></li><li><code>[--dry-run]</code>:截至npm@6,除了实际发布到注册表之外,是否所有发布都会执行.报告将要发布的内容的详细信息.</li><li><code>[--workspaces]</code>:在发布时启用工作区上下文.将发布所有工作区包.</li><li><code>[--workspace]</code>:启用工作区上下文,并将结果限制为此配置项指定的结果.将仅发布给定工作区中的包.</li></ul><blockquote><p>发布一个公共的包,不包含私有作用域</p></blockquote><ol><li>设置npm的proxy代理<code>npm config set proxy=&quot;代理地址(如127.0.0.1:7890)&quot;</code></li><li>检查自己的包名,不能与其他人的包名一样</li><li>使用<code>npm publish</code>发布自己的包</li></ol><h3 id="打包typescript版本的包"><a href="#打包typescript版本的包" class="headerlink" title="打包typescript版本的包"></a>打包typescript版本的包</h3><ol><li>下载<code>npm install typescript -D</code></li><li>初始化一个<code>tsconfig.json</code>文件<code>tsc --init</code></li><li>在scripts中添加脚本:<code>npx tsc -p .</code>.打包当前目录下的所有文件</li></ol><blockquote><p>一些typescript中特有的配置</p></blockquote><ol><li><p><code>package.json</code>中的<code>types</code>字段</p><ul><li>这是一个只在TypeScript中生效的字段,如果您的包有一个main.js文件,您还需要在<code>package.json</code>文件中指明主声明文件.将types属性设置为指向捆绑(bundled指main.js)的声明文件</li></ul><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token punctuation">&#123;</span>  <span class="token property">"types"</span><span class="token operator">:</span> <span class="token string">"./lib/main.d.ts"</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p><code>package.json</code>中的<code>typesVersions</code>字段</p><ul><li>控制typescript的版本号</li></ul> <pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token property">"typesVersions"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>    <span class="token property">">=3.1"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span> <span class="token property">"*"</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">"ts3.1/*"</span><span class="token punctuation">]</span> <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>在<code>.d.ts</code>文件中的<code>/// &lt;reference types=&quot;...&quot; /&gt;</code></p><ul><li>当前库依赖于全局库,会导入全局库的<code>.d.ts</code>的名称</li><li>在声明文件里包含<code>/// &lt;reference types=&quot;node&quot; /&gt;</code>，表明这个文件使用了<code>@types/node/index.d.ts</code>里面声明的名字.并且,这个包要在编译阶段与声明文件一起被包含进来</li><li>解析@types包的名字的过程与解析import语句里模块名的过程类似.所以可以简单的把三斜线类型引用指令想像成针对包的import声明</li><li>对于那些<strong>在编译阶段生成的声明文件</strong>,编译器会自动地添加<code>/// &lt;reference types=&quot;...&quot; /&gt;</code>;当且仅当结果文件中使用了引用的<code>@types</code>包里的声明时才会在生成的声明文件里添加<code>/// &lt;reference types=&quot;...&quot; /&gt;</code>语句</li></ul></li></ol><blockquote><p>配置<code>tsconfig.json</code>.</p></blockquote><ol><li>初始化一个tsconfig.json文件:<code>npx tsc --init</code></li><li>介绍几个重要的配置项<ul><li><code>target</code>: 将项目打包成目标兼容的版本</li><li><code>module</code>: 指定要用的模块化标准</li><li><code>lib</code>: lib用于指定要包含在编译中的库文件<ul><li>例如dom中的一些类型所需要的声明文件.或者使用<code>Array&lt;T&gt;</code>指定数组类型</li><li><a href="https://stackoverflow.com/questions/43874096/difference-in-the-lib-property-in-tsconfig-json-between-es6-and-es2017">可以看下这篇文章</a></li></ul></li><li><code>declaration</code>: 为ts或者js项目生成定义文件(<code>.d.ts</code>)</li><li><code>sourceMap</code>: 为源码生成映射文件,方便调试</li><li><code>rootDir</code>: 指定根目录的源文件位置</li><li><code>outDir</code>: 指定根目录的打包位置</li><li><code>esModuleInterop</code>: 是commonjs模块兼容esm模块(意味着两者的方式都可以导出)<ul><li>参考:<a href="https://zhuanlan.zhihu.com/p/148081795">https://zhuanlan.zhihu.com/p/148081795</a></li></ul></li></ul></li></ol><ul><li>最终形成的tsconfig.json文件</li></ul><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token punctuation">&#123;</span>  <span class="token property">"compilerOptions"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>    <span class="token property">"target"</span><span class="token operator">:</span> <span class="token string">"es2016"</span><span class="token punctuation">,</span>      <span class="token property">"module"</span><span class="token operator">:</span> <span class="token string">"CommonJS"</span><span class="token punctuation">,</span>                                    <span class="token property">"rootDir"</span><span class="token operator">:</span> <span class="token string">"./src"</span><span class="token punctuation">,</span>                                     <span class="token property">"declaration"</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>                                  <span class="token property">"sourceMap"</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>                                    <span class="token property">"outDir"</span><span class="token operator">:</span> <span class="token string">"./dist"</span><span class="token punctuation">,</span>     <span class="token property">"esModuleInterop"</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>                                 <span class="token property">"forceConsistentCasingInFileNames"</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>               <span class="token property">"strict"</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>    <span class="token property">"skipLibCheck"</span><span class="token operator">:</span> <span class="token boolean">true</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>对于<code>package.json</code>文件最好把项目放置在源文件<code>src</code>中,此时只需要配置打包生成的目录上传包就可以了</li></ul><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token property">"main"</span><span class="token operator">:</span> <span class="token string">"dist/index.js"</span><span class="token punctuation">,</span><span class="token property">"types"</span><span class="token operator">:</span> <span class="token string">"dist/index.d.ts"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;字段&quot;&gt;&lt;a href=&quot;#字段&quot; class=&quot;headerlink&quot; title=&quot;字段&quot;&gt;&lt;/a&gt;字段&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;首先需要登录自己的npm账号&lt;code&gt;npm login&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;初始化一个项目</summary>
      
    
    
    
    <category term="config" scheme="http://mail.zyjcould.ltd/categories/config/"/>
    
    
    <category term="config" scheme="http://mail.zyjcould.ltd/tags/config/"/>
    
    <category term="JS" scheme="http://mail.zyjcould.ltd/tags/JS/"/>
    
    <category term="npm" scheme="http://mail.zyjcould.ltd/tags/npm/"/>
    
  </entry>
  
  <entry>
    <title>URL</title>
    <link href="http://mail.zyjcould.ltd/2022/03/28/url/"/>
    <id>http://mail.zyjcould.ltd/2022/03/28/url/</id>
    <published>2022-03-28T15:46:36.000Z</published>
    <updated>2022-03-29T05:16:40.651Z</updated>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><blockquote><p>URL用于解析,构造,规范化和编码urls.如果浏览器不支持<code>new URL()</code>构造函数.可以使用<code>new window.URL()</code></p></blockquote><h3 id="new-URL"><a href="#new-URL" class="headerlink" title="new URL()"></a>new URL()</h3><blockquote><p>构造函数:new URL(url[,base])</p></blockquote><ul><li><code>url</code>:表示绝对或者相对的url.如果是绝对的url,无论baseurl有没有参数都会被忽略.如果是相对的url,则参数会添加到baseurl后</li><li><code>base</code>:可选的,表示基准的url.只有url是带协议才可以生效.<span style="color:red">否则报一个TypeError</span></li></ul><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">let</span> baseurl <span class="token operator">=</span> <span class="token string">"https://www.baidu.com/laji"</span><span class="token comment">//忽略参数</span><span class="token keyword">new</span> <span class="token class-name">URL</span><span class="token punctuation">(</span><span class="token string">"/zhenlan"</span><span class="token punctuation">,</span>baseurl<span class="token punctuation">)</span><span class="token comment">//https://www.baidu.com/zhenlan</span><span class="token comment">//TypeError</span><span class="token keyword">new</span> <span class="token class-name">URL</span><span class="token punctuation">(</span><span class="token string">"www.baidu.com"</span><span class="token punctuation">)</span><span class="token keyword">new</span> <span class="token class-name">URL</span><span class="token punctuation">(</span><span class="token string">"https://www.baidu.com"</span><span class="token punctuation">)</span><span class="token comment">//https://www.baidu.com</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>属性</p></blockquote><ul><li><code>hash</code>:返回包含URL标识中的’#’和fragment标识符</li><li><code>host</code>:返回一个主机信息.即<code>hostname</code>,如果URL接口有端口号(如果是默认端口号,则不会包含),也会包含端口号</li><li><code>hostname</code>:不包含端口号的主机信息</li><li><code>href</code>:返回一个完整的url</li><li><code>origin</code>:只读属性.<ul><li>如果是<code>http</code>或者是<code>https</code>,返回<code>协议名+&#39;://&#39;+域名+&#39;:&#39;+端口号</code></li><li>如果是ftp协议,视浏览器而定</li><li>如果是<code>blob:</code>协议,返回的是<code>blob:</code>紧跟的源地址<ul><li><code>&quot;blob:https://mozilla.org&quot;</code>返回<code>https://mozilla.org</code></li></ul></li></ul></li><li><code>pathname</code>返回一个初始<code>/</code>和URL的路径(如果没有路径,则为空字符串)</li><li><code>port</code>:如果url中包含明确的端口信息,则返回一个端口号.否则返回<code>&quot;&quot;</code></li><li><code>protocol</code>:返回一个url的协议值</li><li><code>search</code>:返回一个查询字符串.<code>?</code>紧跟的</li><li><code>searchParams</code>:返回一个<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/URLSearchParams">URLSearchParams</a>.这个对象包含当前URL中解码后的GET查询参数</li></ul><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">const</span> url <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">URL</span><span class="token punctuation">(</span><span class="token string">'https://developer.mozilla.org:3300/en-US/docs/Web/API/URL/href?q=123#Examples'</span><span class="token punctuation">)</span><span class="token keyword">const</span> hash <span class="token operator">=</span> url<span class="token punctuation">.</span>hash <span class="token comment">//#Examples</span><span class="token keyword">const</span> host <span class="token operator">=</span> url<span class="token punctuation">.</span>host <span class="token comment">//developer.mozilla.org:3300</span><span class="token keyword">const</span> host <span class="token operator">=</span> url<span class="token punctuation">.</span>hostname <span class="token comment">//developer.mozilla.org</span><span class="token keyword">const</span> host <span class="token operator">=</span> url<span class="token punctuation">.</span>href <span class="token comment">//https://developer.mozilla.org:3300/en-US/docs/Web/API/URL/href#Examples</span><span class="token keyword">const</span> origin <span class="token operator">=</span> url<span class="token punctuation">.</span>origin <span class="token comment">//https://developer.mozilla.org</span><span class="token keyword">const</span> pathname <span class="token operator">=</span> url<span class="token punctuation">.</span>pathname <span class="token comment">///en-US/docs/Web/API/URL/href</span><span class="token keyword">const</span> port <span class="token operator">=</span> url<span class="token punctuation">.</span>port <span class="token comment">//3300</span><span class="token keyword">const</span> protocol <span class="token operator">=</span> url<span class="token punctuation">.</span>protocol <span class="token comment">//https</span><span class="token keyword">const</span> search <span class="token operator">=</span> url<span class="token punctuation">.</span>search <span class="token comment">//?q=123</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>username</code>:包含域名前指定的username</li><li><code>password</code>:返回域名之前指定的密码</li></ul><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">const</span> url <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">URL</span><span class="token punctuation">(</span><span class="token string">'https://anonymous:flabada@developer.mozilla.org/en-US/docs/Web/API/URL/password'</span><span class="token punctuation">)</span><span class="token keyword">const</span> password <span class="token operator">=</span> url<span class="token punctuation">.</span>password <span class="token comment">//flabada</span><span class="token keyword">const</span> username <span class="token operator">=</span> url<span class="token punctuation">.</span>username <span class="token comment">//anonymous</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p>静态方法</p></blockquote><ol><li><code>URL.createObjectURL(object)</code>:创建一个表示参数中给出的对象的URL<ul><li>这个新的URL对象表示指定的<code>File</code>对象或<code>Blob</code>对象</li><li><code>object</code>:用于创建URL的<code>File</code>对象,<code>Blob</code>对象或者<code>MediaSource</code>对象</li><li>返回一个用于指定源的URL</li></ul></li><li><code>URL.revokeObjectURL(objectURL)</code>:释放一个之前已经存在的,通过调用<code>URL.createObjectURL()</code>创建的URL对象<ul><li><code>objectURL</code>:通过调用<code>URL.createObjectURL()</code>方法产生的URL对象</li></ul></li><li><code>URL.toString()</code>与<code>URL.toJSON()</code>与<code>url.href</code>一样,返回序列化的url</li></ol><h3 id="URLSearchParams"><a href="#URLSearchParams" class="headerlink" title="URLSearchParams"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/URLSearchParams/append">URLSearchParams</a></h3><blockquote><p>接口定义了一些实用的方法来处理URL的查询字符串</p></blockquote><h4 id="new-URLSearchParams"><a href="#new-URLSearchParams" class="headerlink" title="new URLSearchParams()"></a>new URLSearchParams()</h4><blockquote><p><code>URLSearchParams()</code>构造器创建并返回一个新的<code>URLSearchParams</code>对象.并且会忽略<code>?</code></p></blockquote><ul><li><code>const URLSearchParams = new URLSearchParams(init)</code></li><li><code>init</code>:需要USVString(对应 unicode 标量值的所有可能序列的集合)</li></ul><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">new</span> <span class="token class-name">URLSearchParams</span><span class="token punctuation">(</span><span class="token string">'?foo=1&amp;bar=2'</span><span class="token punctuation">)</span><span class="token keyword">new</span> <span class="token class-name">URLSearchParams</span><span class="token punctuation">(</span>url<span class="token punctuation">.</span>search<span class="token punctuation">)</span><span class="token keyword">new</span> <span class="token class-name">URLSearchParams</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token string">"foo"</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token string">"bar"</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">new</span> <span class="token class-name">URLSearchParams</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span><span class="token string">"foo"</span> <span class="token operator">:</span> <span class="token number">1</span> <span class="token punctuation">,</span> <span class="token string">"bar"</span> <span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>方法</p></blockquote><ul><li><code>append(name, value)</code>:可以插入一个新搜索参数</li><li><code>getAll(name)</code>:以数组的形式返回与指定搜索参数对应的所有值</li><li><code>get(name)</code>:返回第一个与搜索参数对应的值</li><li><code>has(name)</code>:返回一个布尔值,表示查找的键名是否存在</li><li><code>set()</code>:设置和搜索参数相关联的值.如果设置前已经存在匹配的值,该方法会删除多余的,如果将要设置的值不存在,则创建它</li><li><code>delete(name)</code>:可以删除指定名称的所有搜索参数</li><li><code>sort()</code>:对对象中的所有键&#x2F;值对进行排序.按unicode编码</li><li><code>entries()</code>:返回一个<code>iterator</code>,允许遍历该对象中包含的所有键&#x2F;值对</li><li><code>forEach(callback)</code>:该回调函数可以接收到3个参数value,key,searchParams</li><li><code>keys()</code>:返回一个iterator,遍历器允许遍历对象中包含的所有键</li><li><code>values()</code>:返回一个iterator,遍历器允许遍历对象中包含的所有值</li><li><code>toString()</code>:返回适用在URL中的查询字符串</li></ul><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">let</span> url <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">URL</span><span class="token punctuation">(</span><span class="token string">'https://example.com?foo=1&amp;bar=2'</span><span class="token punctuation">)</span><span class="token keyword">let</span> params <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">URLSearchParams</span><span class="token punctuation">(</span>url<span class="token punctuation">.</span>search<span class="token punctuation">)</span>params<span class="token punctuation">.</span><span class="token function">getAll</span><span class="token punctuation">(</span><span class="token string">"foo"</span><span class="token punctuation">)</span> <span class="token comment">//['1', '4']</span>params<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"foo"</span><span class="token punctuation">)</span> <span class="token comment">//'1'</span>params<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">'foo'</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token comment">//foo=1&amp;bar=2&amp;foo=4</span>params<span class="token punctuation">.</span><span class="token function">has</span><span class="token punctuation">(</span><span class="token string">'bar'</span><span class="token punctuation">)</span> <span class="token comment">// true</span>params<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">"foo"</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token comment">//foo=2&amp;bar=2</span>params<span class="token punctuation">.</span><span class="token function">delete</span><span class="token punctuation">(</span><span class="token string">"foo"</span><span class="token punctuation">)</span><span class="token comment">//bar=2</span>params<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">'foo'</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token comment">//entries</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">[</span>key<span class="token punctuation">,</span>value<span class="token punctuation">]</span> <span class="token keyword">of</span> params<span class="token punctuation">.</span><span class="token function">entries</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span>value<span class="token punctuation">)</span>  <span class="token comment">//bar 2</span>  <span class="token comment">//foo 4   </span><span class="token punctuation">&#125;</span><span class="token comment">//forEach</span>params<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">item<span class="token punctuation">,</span>key</span><span class="token punctuation">)</span><span class="token operator">=></span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>item<span class="token punctuation">,</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment">//bar 2</span>  <span class="token comment">//foo 4  </span><span class="token comment">//keys()</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token operator">...</span>params<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">//bar foo</span><span class="token comment">//values()</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token operator">...</span>params<span class="token punctuation">.</span><span class="token function">values</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">//2 4</span>params<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">//'bar=2&amp;foo=4'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;URL&quot;&gt;&lt;a href=&quot;#URL&quot; class=&quot;headerlink&quot; title=&quot;URL&quot;&gt;&lt;/a&gt;URL&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;URL用于解析,构造,规范化和编码urls.如果浏览器不支持&lt;code&gt;new URL()&lt;/code&gt;构</summary>
      
    
    
    
    <category term="JS" scheme="http://mail.zyjcould.ltd/categories/JS/"/>
    
    
    <category term="JS" scheme="http://mail.zyjcould.ltd/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>Observer</title>
    <link href="http://mail.zyjcould.ltd/2022/03/15/observer/"/>
    <id>http://mail.zyjcould.ltd/2022/03/15/observer/</id>
    <published>2022-03-15T07:05:01.000Z</published>
    <updated>2022-03-19T08:12:04.882Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Observer"><a href="#Observer" class="headerlink" title="Observer"></a>Observer</h2><blockquote><p>网页开发中经常会和用户交互而使用一些监听事件(例如onclick,onchange等).如果对于一些用户不直接触发的元素(例如渐变等),那就需要使用Observer去监听</p></blockquote><ul><li>浏览器为我们提供了五种<code>Observer</code>(观察者)来监听这些变动:<code>MutationObserver</code>,<code>IntersectionObserver</code>,<code>PerformanceObserver</code>,<code>ResizeObserver</code>,<code>ReportingObserver</code></li><li>以下观察者api都是构造函数</li><li>观察者属于微任务,并且优先级小于Promise</li></ul><h3 id="IntersectionObserver"><a href="#IntersectionObserver" class="headerlink" title="IntersectionObserver"></a>IntersectionObserver</h3><blockquote><p><code>IntersectionObserver</code>(交叉观察者)用于观察一个元素是否在视窗可见.构造函数创建并返回一个新的<code>IntersectionObserver</code>对象</p><p>如果未指定或为空字符串,则缺省的值为属性的默认值</p><p>一般用于<strong>无限滚动</strong>,<strong>图片懒加载</strong>,<strong>埋点</strong>,<strong>控制动画&#x2F;视频执行</strong></p></blockquote><ul><li>无论是使用视口(body)还是其他元素作为根,API 的工作方式都相同,并且会<strong>异步</strong>查询观察目标元素的可见性发生变化,就会执行提供的回调函数</li><li>通过提供一种新方法来<strong>异步</strong>查询元素相对于其他元素或全局视口的位置</li><li><strong>异步处理</strong>消除了昂贵的<code>DOM</code>和样式查询,连续轮询以及使用自定义插件的需求</li><li>Intersection Observer的三个步骤<ol><li>创建观察者</li><li>定义回调事件</li><li>定义要观察的目标对象</li></ol></li></ul><h4 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h4><ol><li><code>IntersectionObserver.observe(target)</code>:告诉要观察的目标元素</li><li><code>IntersectionObserver.takeRecords()</code>:从IntersectionObserver的通知队列中删除所有待处理的通知,并将它们返回到IntersectionObserver对象的新Array对象中</li><li><code>IntersectionObserver.unobserve()</code>指定停止观察特定目标元素</li><li><code>IntersectionObserver.disconnect()</code>:停止IntersectionObserver对象观察任何目标</li></ol><h4 id="创建观察者"><a href="#创建观察者" class="headerlink" title="创建观察者"></a>创建观察者</h4><ul><li>接收一个回调函数.只要目标元素发生变化就会触发回调函数</li><li>第二个参数是一个可选项</li></ul><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">let</span> options <span class="token operator">=</span> <span class="token punctuation">&#123;</span>  root<span class="token operator">:</span> document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">'#scrollArea'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  rootMargin<span class="token operator">:</span> <span class="token string">'0px'</span><span class="token punctuation">,</span>  <span class="token comment">//阈值为1.0表示当100%的目标在选项指定的元素中可见时,将调用回调</span>  <span class="token comment">//每个阈值是观测目标的交集区域与边界框区域的比率</span>  threshold<span class="token operator">:</span> <span class="token number">1.0</span><span class="token punctuation">&#125;</span><span class="token keyword">let</span> observer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">IntersectionObserver</span><span class="token punctuation">(</span>callback<span class="token punctuation">,</span> options<span class="token operator">?</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>option字段</p></blockquote><ol><li><code>root</code>:用作检查<strong>目标可见性的视口的元素</strong>.必须是目标的祖先.<span style="color:red">如果未指定或缺省为浏览器视口(html)</span></li><li><code>rootMargin</code><strong>根周围的边距</strong>(默认全部为0).语法类似于<code>margin</code>可以是百分比或者像素,用于在计算交集之前增大或缩小根元素边界框的矩形偏移量,有效的扩大或者缩小根的判定范围从而满足计算要求.(top,right,bottom,left)</li><li><code>threshold</code>:阈值.<strong>单个数字或数字数组</strong>.默认值为 0(这意味着只要有一个像素可见,就会运行回调)阈值是监听对象的交叉区域和边界区域的比例,每当监听对象超过阈值就会触发回调<ul><li>如果只想检测可见性何时超过 50% 标记,则可以使用值 0.5.</li><li>如果希望每次可见性每次超过 25% 时都运行回调,则应指定数组 [0, 0.25, 0.5, 0.75, 1]</li><li>如果值为 1.0 表示在每个像素可见之前,不会认为阈值已通过.</li></ul></li></ol><h4 id="监听观察的目标对象"><a href="#监听观察的目标对象" class="headerlink" title="监听观察的目标对象"></a>监听观察的目标对象</h4><blockquote><p>开启对目标对象的监听,如果没有</p></blockquote><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">const</span> target <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">".target"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> observer<span class="token punctuation">.</span><span class="token function">observe</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h4><blockquote><p>callback是添加监听后,当监听目标发生滚动变化时触发的回调函数.</p></blockquote><ul><li>第一个参数<code>entries</code>(数组),即<code>IntersectionObserverEntry</code>实例.描述了目标元素与root的交叉状态.</li></ul><table><thead><tr><th>属性</th><th align="center">说明</th></tr></thead><tbody><tr><td>boundingClientRect</td><td align="center">返回包含目标元素的边界信息,返回结果与element.getBoundingClientRect() 相同</td></tr><tr><td><strong>intersectionRatio</strong></td><td align="center">返回目标元素出现在可视区的比例</td></tr><tr><td>intersectionRect</td><td align="center">用来描述root和目标元素的相交区域</td></tr><tr><td><strong>isIntersecting</strong></td><td align="center">返回一个布尔值,下列两种操作均会触发回调:1.如果目标元素出现在root可视区,返回true.2. 如果从root可视区消失,返回false</td></tr><tr><td>rootBounds</td><td align="center">用来描述交叉区域观察者(intersection observer)中的根.</td></tr><tr><td>target</td><td align="center">目标元素:与根出现相交区域改变的元素 (Element)</td></tr><tr><td>time</td><td align="center">返回一个记录从 IntersectionObserver 的时间原点到交叉被触发的时间的时间戳</td></tr></tbody></table><ul><li>第二个参数就是<code>IntersectionObserver</code>这个实例对象本身.可以使用实例上的方法.</li></ul><h4 id="图片懒加载"><a href="#图片懒加载" class="headerlink" title="图片懒加载"></a>图片懒加载</h4><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">width</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>200px<span class="token punctuation">"</span></span> <span class="token attr-name">height</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>200px<span class="token punctuation">"</span></span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>logo.png<span class="token punctuation">"</span></span>    <span class="token attr-name">data-src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>0.jpg<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">width</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>200px<span class="token punctuation">"</span></span> <span class="token attr-name">height</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>200px<span class="token punctuation">"</span></span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>logo.png<span class="token punctuation">"</span></span>    <span class="token attr-name">data-src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>1.jpg<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">width</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>200px<span class="token punctuation">"</span></span> <span class="token attr-name">height</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>200px<span class="token punctuation">"</span></span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>logo.png<span class="token punctuation">"</span></span>    <span class="token attr-name">data-src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>2.jpg<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript">  <span class="token keyword">const</span> img <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementsByTagName</span><span class="token punctuation">(</span><span class="token string">'img'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">let</span> observe <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">IntersectionObserver</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">entries<span class="token punctuation">,</span> observe</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>    entries<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token parameter">item</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>item<span class="token punctuation">.</span>isIntersecting<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        item<span class="token punctuation">.</span>target<span class="token punctuation">.</span>src <span class="token operator">=</span> item<span class="token punctuation">.</span>target<span class="token punctuation">.</span>dataset<span class="token punctuation">.</span>src        observe<span class="token punctuation">.</span><span class="token function">unobserve</span><span class="token punctuation">(</span>item<span class="token punctuation">.</span>target<span class="token punctuation">)</span>      <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span> rootMargin<span class="token operator">:</span> <span class="token string">"0px 600px 0px -600px"</span> <span class="token punctuation">&#125;</span><span class="token punctuation">)</span>  <span class="token comment">// observe遍历监听所有img节点</span>  Array<span class="token punctuation">.</span><span class="token function">from</span><span class="token punctuation">(</span>img<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token parameter">img</span> <span class="token operator">=></span> observe<span class="token punctuation">.</span><span class="token function">observe</span><span class="token punctuation">(</span>img<span class="token punctuation">)</span><span class="token punctuation">)</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>先说一下<code>dataset</code>属性,可以在很多网站中看到这个data-为前缀的属性</p></blockquote><ul><li>dataset:浏览器很早就支持以键(data)-值命名的自定义属性了</li><li>设置属性:<code>Element.dataset.dart=&quot;dark&quot;</code>.例如上图代码(<code>item.target.dataset.dart=&quot;dark&quot;</code>)在挂载到标签时,会自动加上<code>data</code>这个键.就像这样<code>data-dart=&quot;dark&quot;</code></li><li>获取属性:<code>Element.dataset.src</code>,不需要加上<code>data-</code>前缀</li><li>删除属性:<code>delete Element.dataset.src</code></li><li>当然我们完全可以使用<code>getAttribute</code>等属性来进行自定义操作</li></ul><blockquote><p><code>HTMLCollectionOf&lt;&gt;</code>和<code>NodeListOf&lt;&gt;</code>的区别</p></blockquote><ul><li>参考:<a href="https://dom.spec.whatwg.org/#interface-htmlcollection">DOM 标准 (whatwg.org)</a></li><li>由于是历史遗留的产物,<code>HTMLCollectionOf</code>他返回的是一个集合,并不支持任何数组的高级api<ul><li>并且一切由<code>getElements...</code>返回的节点都是动态的集合类型,没有实现forEach等方法</li><li>动态的:如果基本的文档改变时.所有<code>HTMLCollection</code>对象会立即改变</li></ul></li><li><code>NodeListOf</code>是静态的.实现了所有的高级数组都有的api,<code>forEach</code>等<ul><li>了解了这些,使用元素选择的时候也可以使用<code>querySelectAll()</code>来选择元素.他会返回一个NodeListOf的类型</li></ul></li></ul><blockquote><p>理解可视区</p></blockquote><ul><li>重要的一点就是可视区的理解<ul><li><strong>intersectionRatio</strong>对应的是<code>threshold</code></li><li><strong>isIntersecting</strong>对应的是<code>rootMargin</code></li></ul></li><li>只要理解了<code>rootMargin</code>就很容易理解threshold的概念</li><li>理解margin,由于文档流的缘故,在设置margin的<code>top</code>或者<code>bottom</code>任意值的时候会移动盒子.如果设置<code>left</code>或者<code>right</code>必须同时设置才会改变盒子原来的位置,只设置一个值只会撑大盒子</li><li>例如上面图中设置的整体元素会向左移动600px.并且目标元素是相对于视口来说,但是理论上所有的图片都应该移动到视口之外的位置.并且不可以看到图片的懒加载.但是由于浏览器本身有一定的默认值,我们会得到最后一个图片是触发观察者实现懒加载的</li><li>明白了这个,就可以明白<code>threshold</code>,只有目标元素的可见性达到视口的一定比例(threshold的属性值)之后才可以触发观察者模式</li></ul><iframe height="300" style="width: 100%;" scrolling="no" title="IntersectionObserver" src="https://codepen.io/jack-zhang-1314/embed/YzYXYrV?default-tab=html%2Cresult" frameborder="no" loading="lazy" allowtransparency="true" allowfullscreen="true">  See the Pen <a href="https://codepen.io/jack-zhang-1314/pen/YzYXYrV">  IntersectionObserver</a> by Jack-Zhang-1314 (<a href="https://codepen.io/jack-zhang-1314">@jack-zhang-1314</a>)  on <a href="https://codepen.io">CodePen</a>.</iframe><h3 id="MutationObserver"><a href="#MutationObserver" class="headerlink" title="MutationObserver"></a>MutationObserver</h3><ul><li><code>Mutation Observer</code>是<strong>异步</strong>触发,DOM的变动并不会马上触发,而是要等到当前所有DOM&#96;操作都结束才触发</li><li>可以通过配置项,监听目标DOM下子元素的变更记录</li><li>构造函数返回一个新的,包含监听 DOM 变化回调函数的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/MutationObserver"><code>MutationObserver</code></a> 对象</li><li>使用用途<ul><li>一般用于更高性能的数据绑定及响应</li><li>实现视觉差滚动</li><li>图片预加载</li><li>实现富文本编辑器</li></ul></li></ul><h4 id="Mutation实例方法"><a href="#Mutation实例方法" class="headerlink" title="Mutation实例方法"></a>Mutation实例方法</h4><ol><li><code>MutationObserver.observe(dom,options)</code>:阻止<code>MutationObserver</code> 实例继续接收的通知,直到再次调用其<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/MutationObserver/observe"><code>observe()</code></a>方法,该观察者对象包含的回调函数都不会再被调用</li><li><code>MutationObserver.takeRecords()</code>:从MutationObserver的通知队列中删除所有待处理的通知,并将它们返回到<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/MutationRecord"><code>MutationRecord</code></a>(保存每次的变化信息)对象的新<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array"><code>Array</code></a></li><li><code>MutationObserver.disconnect()</code>:停止MutationObserver对象观察任何目标</li></ol><h4 id="Mutation创建观察者和监听目标对象"><a href="#Mutation创建观察者和监听目标对象" class="headerlink" title="Mutation创建观察者和监听目标对象"></a>Mutation创建观察者和监听目标对象</h4><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">const</span> MutationObserver <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MutationObserver</span><span class="token punctuation">(</span>callback<span class="token punctuation">)</span>MutationObserver<span class="token punctuation">.</span><span class="token function">observe</span><span class="token punctuation">(</span>dom<span class="token punctuation">,</span> options<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>第一个参数是一个dom对象,被观察子节点(目标元素)的父节点</li><li>第二个参数options是一个[MutationObserverInit | MDN (mozilla.org)](https:&#x2F;&#x2F;  developer.mozilla.org&#x2F;zh-CN&#x2F;docs&#x2F;conflicting&#x2F;Web&#x2F;API&#x2F;MutationObserver&#x2F;observe_2f2addbfa1019c23a6255648d6526387)对象<ul><li><code>attributeFilter</code>:(无默认值)要监视的特定属性名称的<strong>数组</strong>(如<code>[&#39;src&#39;,&#39;class&#39;]</code>).如果未包含此属性,则对所有属性的更改都会触发变动通知</li><li><code>attributes</code>:默认值false.设置true观察受监视元素的属性值变更</li><li><code>characterData</code>:无默认值.设为true监视指定目标节点或者子节点树中节点所包含的字符数据的变化</li><li><code>characterDataOldValue</code>:无默认值.设为true,是否观察文本的内容(文本节点)</li><li><code>childList</code>:默认值为false.设为true,监视木匾检点添加或删除新的子节点(不包括修改子节点以及子节点后代的变化).如果<code>subtree</code>为true,则包含子节点</li><li><code>subtree</code>:默认值为false,设置true,将监视范围扩展到目标节点以及子节点</li></ul></li><li>属性特定项<ul><li>其中调用 <code>observe()</code>方法时<code>childList</code>,<code>attributes</code>,<code>characterData</code> 或者<code>attributeOldValue</code>,<code>characterDataOldValue</code>两组中,至少有一个必须为 <code>true</code>,否则会抛出异常</li><li><code>attributeFilter/attributeOldValue</code> &gt; <code>attributes</code></li><li><code>characterDataOldValue</code> &gt; <code>characterData</code></li><li>避免重复的特定项,不需要同时设置同样的效果</li></ul></li></ul><h4 id="mutation回调函数"><a href="#mutation回调函数" class="headerlink" title="mutation回调函数"></a>mutation回调函数</h4><blockquote><p>同样是接收两个参数</p></blockquote><ul><li>第一个参数是<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/MutationRecord"><code>MutationRecords</code></a>,依然是一个数组.其中每个<code>MutationRecord</code>对象,记录着<code>DOM</code>每次发生变化的变动记录.<code>MutationRecord</code>对象包含了DOM的相关信息</li></ul><table><thead><tr><th>属性</th><th align="left">描述</th></tr></thead><tbody><tr><td><strong>target</strong></td><td align="left">被修改影响的目标 dom 节点</td></tr><tr><td><strong>type</strong></td><td align="left">变化的类型，也就是MutationObserverInit对象中的三种<code>attributes</code>,<code>characterData</code>或<code>childList</code>,并且返回该类型</td></tr><tr><td><strong>attributeName</strong></td><td align="left">针对<code>attributes</code>类型的变化时,返回被修改属性的名字(或者null)</td></tr><tr><td><strong>attributeNamespace</strong></td><td align="left">针对命名空间的<code>attributes</code>类型的变化.返回被修改属性的命名空间,或者null</td></tr><tr><td><strong>oldValue</strong></td><td align="left">如果在<code>MutationObserverInit</code>对象中启用(<code>attributeOldValue</code>或<code>characterDataOldValue</code>为true).则<code>attributes</code>或<code>characterData</code>的变化事件会返回变化之值或数据.<code>childList</code>类型的变化始终将这个属性设置为null</td></tr><tr><td><strong>addedNodes</strong></td><td align="left">针对<code>childList</code>的变化,返回包含变化中添加节点的<code>NodeList</code>,没有节点被添加,返回空<code>NodeList</code>数组</td></tr><tr><td><strong>previousSibling</strong></td><td align="left">对于<code>childList</code>变化.返回被添加或移除的节点之前的兄弟节点,或者null</td></tr><tr><td><strong>nextSibling</strong></td><td align="left">对于<code>childList</code>变化,返回被添加或移除的节点之后的兄弟节点.或者null</td></tr><tr><td><strong>removedNodes</strong></td><td align="left">对于<code>childList</code>变化,返回被移除的节点(没有则为null)</td></tr></tbody></table><ul><li>第二个参数就是<code>MutationObserver</code>这个实例对象本身.可以使用实例上的方法.</li></ul><blockquote><p><a href="https://juejin.cn/post/7036733000565915655"><code>MutationObserver</code>的引用</a></p></blockquote><ul><li><code>MutationObserver</code>对要观察的目标节点的引用属于<strong>弱引用</strong>,所以不会妨碍垃圾回收程序回收目标节点</li><li>目标节点对于<code>MutationObserver</code>是强引用.如果目标节点从DOM中被移除,随后被垃圾回收,则关联的 MutationObserver 也会被垃圾回收</li></ul><blockquote><p><code>MutationRecord</code>的引用</p></blockquote><ul><li><p><code>MutationRecord</code>实例至少包含对已有DOM节点的一个引用,即里面的target属性,如果变化是<code>childList</code>类型,则会包含多个节点的引用</p></li><li><p>记录队列和回调处理的默认行为是耗尽这个队列,处理每个<code>MutationRecord</code>,然后让它们超出作用域并被垃圾回收</p><ul><li><code>MutationObserver</code>核心是异步回调与记录队列模型.为了在大量变化事件发生时不影响性能,每次变化的信息<strong>由oberver实例决定</strong>.保存在<strong>MutationRecord</strong>实例中,然后添加到记录队列</li><li>记录队列对每个 <strong>MutationObserver</strong> 实例都是唯一的,是所有 <strong>DOM</strong> 变化事件的有序列表(DOM变化事件都会以数组的形式存在MutationRecord中),多次修改的信息会在一次回调中执行</li></ul></li><li><p>有时候需要保存某个观察者的完整变化记录,那么就保存所有的<code>MutationRecord</code> 实例,也就会保存它们引用的节点,而这会妨碍这些节点被回收</p></li><li><p>如果需要尽快地释放内存,可以从每个<code>MutationRecord</code>中抽取出最有用的信息,保存到一个新对象,然后释放<code>MutationRecord</code>中的引用</p></li></ul><h3 id="ResizeObserver-尚在开发"><a href="#ResizeObserver-尚在开发" class="headerlink" title="ResizeObserver(尚在开发)"></a>ResizeObserver(尚在开发)</h3><ul><li><p><strong><code>ResizeObserver</code></strong> 构造器创新一个新的<code>ResizeObserver</code>对象,用于接收<code>Element</code>内容区域的改变或<code>SVGElement</code>的边界框改变改变</p></li><li><p>用途:更智能的响应式布局(取代@media)以及响应式组件</p></li><li><p>由于resize事件会监听视窗的变化而不是元素的大小发生变化.可能一秒内会触发几十次,导致性能问题</p></li></ul><h4 id="Resize实例方法"><a href="#Resize实例方法" class="headerlink" title="Resize实例方法"></a>Resize实例方法</h4><ol><li><code>observe(target,options?)</code>:用于指定观察一个指定的<code>Element</code>或者<code>SVGElement</code></li><li><code>disconnect()</code>:停止和取消目标对象上所有对<code>Element</code>或者<code>SVGElement</code>监视</li><li><code>unobserve()</code>:用于结束一个指定的<code>Element</code>或者<code>SVGElement</code>监视</li></ol><h4 id="创建Resize实例"><a href="#创建Resize实例" class="headerlink" title="创建Resize实例"></a>创建Resize实例</h4><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">const</span> ResizeObserver <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ResizeObserver</span><span class="token punctuation">(</span>callback<span class="token punctuation">)</span>resizeObserver<span class="token punctuation">.</span><span class="token function">observe</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span>options<span class="token operator">?</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>options是一个指定观察设置的可选参数对象.目前只有一个可设置的选项<ul><li><code>box</code>:设置观察者将以哪种盒子模型来观察变动</li><li>可以设置为<code>content-box</code>(默认值),<code>border-box</code>或者<code>device-pixel-content-box</code></li></ul></li></ul><h4 id="Resize回调函数"><a href="#Resize回调函数" class="headerlink" title="Resize回调函数"></a>Resize回调函数</h4><ul><li><p>只接收一个<code>ResizeObserverEntry</code>实例<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/ResizeObserverEntry">ResizeObserverEntry - Web API 接口参考(mozilla.org)</a></p></li><li><p>目前只接受两个属性</p><ol><li><code>target</code>:当前改变尺寸大小的元素的引用</li><li><code>contentRect</code>:对改变尺寸大小的元素的<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/DOMRectReadOnly"><code>DOMRectReadOnly</code></a>引用(包含x,y(坐标),width,height,top,right,bottom,left属性)</li></ol></li></ul><h3 id="PerformanceObserver"><a href="#PerformanceObserver" class="headerlink" title="PerformanceObserver"></a>PerformanceObserver</h3><blockquote><p><strong><code>PerformanceObserver</code></strong> 用于监测性能度量事件,在浏览器的性能时间轴记录下一个新的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/PerformanceEntry">performance entries</a> 的时候将会被通知</p></blockquote><ul><li><p>用途:更细颗粒的性能监控.分析新跟那个对业务的影响(交互快&#x2F;慢是否会影响销量)</p></li><li><p>尽可能使用<code>PerformanceObserver</code>,而不是通过<code>Performance</code>获取性能参数及指标</p><ul><li><p>避免不知道性能事件啥时候会发生,需要重复轮训<code>timeline</code>获取记录。</p></li><li><p>避免产生重复的逻辑去获取不同的性能数据指标</p></li><li><p>避免其他资源需要操作浏览器性能缓冲区时产生竞态关系</p></li></ul></li></ul><blockquote><p>实例方法和MutationsObserver一样,但是<code>observe()</code>只接受<code>options</code></p></blockquote><h4 id="创建Performance实例"><a href="#创建Performance实例" class="headerlink" title="创建Performance实例"></a>创建Performance实例</h4><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">const</span> PerformanceObserver <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PerformanceObserver</span><span class="token punctuation">(</span>callback<span class="token punctuation">)</span>PerformanceObserver<span class="token punctuation">.</span><span class="token function">observe</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>entryTypes<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">"measure"</span><span class="token punctuation">]</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li><code>options</code>只接收一个entryTypes的键,值为一个性能检测数组</li></ul><table><thead><tr><th align="left">属性</th><th align="left">别名</th><th align="left">类型</th><th align="center">描述</th></tr></thead><tbody><tr><td align="left"><code>frame</code>, <code>navigation</code></td><td align="left">&#96;PerformanceFrameTiming, PerformanceNavigationTiming</td><td align="left">URL</td><td align="center">文件的地址</td></tr><tr><td align="left"><code>resource</code></td><td align="left">PerformanceResourceTiming</td><td align="left">URL</td><td align="center">文件请求资源解析的URL.只有在资源加载完毕后才会创建</td></tr><tr><td align="left"><code>mark</code></td><td align="left">PerformanceMark</td><td align="left">DOMString</td><td align="center">通过调用创建标记使用的名称.会在资源获取开始时创建(<code>performance.mark(name)</code>)</td></tr><tr><td align="left"><code>measure</code></td><td align="left">PerformanceMeasure</td><td align="left">DOMString</td><td align="center">通过调用创建度量时使用的名称.会在对资源操作时创建(<code>performance.measure(name)</code>)</td></tr><tr><td align="left"><code>paint</code></td><td align="left">PerformancePaintTiming</td><td align="left">DOMString</td><td align="center">渲染时间点的信息接口.找出那些花费太多时间去绘制的区域</td></tr></tbody></table><h4 id="Performance回调函数"><a href="#Performance回调函数" class="headerlink" title="Performance回调函数"></a>Performance回调函数</h4><blockquote><p>回调函数只接受一个参数,该参数是<code>PerformanceObserverEntryList</code>对象.该对象有三个接口</p></blockquote><ol><li><code>getEntries()</code>:返回所有的<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/PerformanceEntry"><code>PerformanceEntry</code></a>对象组成的数组</li><li><code>getEntriesByType(entryType)</code>:返回指定的<code>entryType</code>类型组合成的<code>PerformanceEntry</code>对象数组</li><li><code>getEntriesByName(name)</code>:返回通过指定的属性名(例如<code>performance.measure(name)</code>的name)组合成<code>PerformanceEntry</code>对象的数组</li></ol><blockquote><p><code>PerformanceEntry</code>对象</p></blockquote><ul><li>属性值:<ul><li><code>name</code>:该性能条目的名字.例如mark,measure通过指定名称name</li><li><code>entryType</code>:上述的options包含所有的entryType属性</li><li><code>startTime</code>:返回<code>PorformanceEntry</code>的第一个时间戳<ol><li><code>frame</code>:当页面开始加载时,返回的时间戳</li><li><code>mark</code>:当使用<code>performance.mark(name)</code>创建mark标记之后返回的时间戳</li><li><code>measure</code>:当使用<code>performance.measure(name)</code>创建measure标记之后返回的时间戳</li><li><code>navigation</code>:返回值为0的时间戳</li><li><code>resource</code>:返回浏览器开始获取资源的时间戳</li></ol></li><li><code>duration</code>:该资源的耗时时间</li></ul></li><li>方法:<code>toJSON()</code>:返回 JSON 格式数据的PerformanceEntry对象</li></ul><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token special-attr"><span class="token attr-name">onclick</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span><span class="token value javascript language-javascript"><span class="token function">measureClick</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span><span class="token punctuation">"</span></span></span><span class="token punctuation">></span></span>Measure<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://zyjcould.ltd/blog/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%A7%86%E5%8F%A3.png<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript">    <span class="token keyword">const</span> performanceObserver <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PerformanceObserver</span><span class="token punctuation">(</span><span class="token parameter">list</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>      list<span class="token punctuation">.</span><span class="token function">getEntries</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token parameter">entry</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>entry<span class="token punctuation">.</span>entryType<span class="token punctuation">)</span><span class="token punctuation">;</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>entry<span class="token punctuation">.</span>startTime<span class="token punctuation">)</span><span class="token punctuation">;</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>entry<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>entry<span class="token punctuation">.</span>duration<span class="token punctuation">)</span><span class="token punctuation">;</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>entry<span class="token punctuation">.</span><span class="token function">toJSON</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    performanceObserver<span class="token punctuation">.</span><span class="token function">observe</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span> entryTypes<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">'resource'</span><span class="token punctuation">,</span> <span class="token string">'mark'</span><span class="token punctuation">,</span> <span class="token string">'measure'</span><span class="token punctuation">]</span> <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    performance<span class="token punctuation">.</span><span class="token function">mark</span><span class="token punctuation">(</span><span class="token string">'registered-observer'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">function</span> <span class="token function">measureClick</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      performance<span class="token punctuation">.</span><span class="token function">measure</span><span class="token punctuation">(</span><span class="token string">'button clicked'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>  </span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="ReportingObserver-实验"><a href="#ReportingObserver-实验" class="headerlink" title="ReportingObserver(实验)"></a>ReportingObserver(实验)</h3><blockquote><p><code>ReportingObserver()</code> 构造函数会创建一个新的 <a href="https://developer.mozilla.org/en-US/docs/Web/API/ReportingObserver"><code>ReportingObserver</code></a> 对象实,该实例可用于收集和获取reports</p></blockquote><ul><li>使用:将浏览器弃用的<code>API</code>或者运行时<strong>浏览器的干预行为</strong>由自己约束<ul><li>违反浏览器的选项时</li><li>JS的异常和错误(替代<code>window.onerror</code>)</li><li>未处理的promise的<code>reject</code>(替代<code>window.onunhandledrejection</code>)</li></ul></li></ul><blockquote><p>ReportingObserver实例方法和<code>MutationObserver</code>的实例方法一样.但是<code>observer()</code>不需要任何参数</p></blockquote><h4 id="创建Reporting实例"><a href="#创建Reporting实例" class="headerlink" title="创建Reporting实例"></a>创建Reporting实例</h4><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">let</span> options <span class="token operator">=</span> <span class="token punctuation">&#123;</span>  types<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">'deprecation'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  buffered<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">&#125;</span><span class="token keyword">const</span> reportingObserver<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">ReportingObserver</span><span class="token punctuation">(</span>callback<span class="token punctuation">,</span> options<span class="token operator">?</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>options提供两个属性,<code>types</code>和<code>buffered</code></li></ul><ol><li><p><code>types</code>:提供三个属性值</p><ul><li><code>deprecation</code>:浏览器运行时遇到弃用的api会打印这个选项</li><li><code>intervention</code>:浏览器自己的干预行为.可能遇到一些不安全的行为(如带有不安全的iframe,过时的api等)</li><li><code>crash</code>:浏览器崩溃时的行为</li></ul></li><li><p><code>buffered</code>:布尔值,如果时true,可以查看创建观察者之前生成的报告(使用于延迟加载的情况,不会错过页面加载之前发生的事情)</p></li></ol><h4 id="Reporting回调函数"><a href="#Reporting回调函数" class="headerlink" title="Reporting回调函数"></a>Reporting回调函数</h4><blockquote><p>提供两个参数,第一个参数是一个<code>reports</code>数组对象.同样也可以通过<code>takeRecords()</code>实例方法获取这些数组</p></blockquote><ul><li><code>report</code>对象有三个属性:<code>body</code>,<code>type</code>,<code>url</code><ul><li><code>type</code>:返回的是report类型,即options选项中的types</li><li><code>url</code>:返回的是生成report的文档</li><li><code>body</code>:返回report正文,包含详细的report对象,目前只有两种<strong>body对象</strong>(却决于type的返回值)<ol><li><a href="https://developer.mozilla.org/en-US/docs/Web/API/DeprecationReportBody"><code>DeprecationReportBody、InterventionReportBody</code></a><ul><li><code>id</code>:已弃用的功能或 API 的字符串</li><li><code>anticipatedRemoval</code>:Data对象,表示应从浏览器中要删除的日期.如果日期位置,返回null</li><li><code>message</code>:字符串,api的弃用说明.包括新功能的取代说明</li><li><code>sourceFile</code>:string类型,使用已弃用api的源文件路径.已知或其他返回null</li><li><code>lineNumber</code>:number类型,表示源文件中使用已弃用的功能的行.已知或其他返回null</li><li><code>columnNumber</code>:number类型,表示源文件中使用已弃用的功能的行&#x3D;列.已知或其他返回null</li></ul></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/API/CrashReportBody"><code>CrashReportBody</code></a><ul><li><code>reason</code>:表示崩溃原因的字符串.如果返回的是<code>oom</code>:浏览器内存不足.如果返回的是<code>unresponsive</code>:页面由于无响应而被终止</li></ul></li></ol></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Observer&quot;&gt;&lt;a href=&quot;#Observer&quot; class=&quot;headerlink&quot; title=&quot;Observer&quot;&gt;&lt;/a&gt;Observer&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;网页开发中经常会和用户交互而使用一些监听事件(例如onclick,</summary>
      
    
    
    
    <category term="JS" scheme="http://mail.zyjcould.ltd/categories/JS/"/>
    
    
    <category term="JS" scheme="http://mail.zyjcould.ltd/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>TS装饰器</title>
    <link href="http://mail.zyjcould.ltd/2022/03/05/ts-zhuang-shi-qi/"/>
    <id>http://mail.zyjcould.ltd/2022/03/05/ts-zhuang-shi-qi/</id>
    <published>2022-03-05T04:00:53.000Z</published>
    <updated>2022-03-19T08:12:04.883Z</updated>
    
    <content type="html"><![CDATA[<h2 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h2><blockquote><p>装饰器是一种特殊的类型声明,他能被附加到类声明,方法,访问符,属性或者参数上,可以修改类的行为.装饰器使用<code>@experssion</code>的形式(更像是<code>defineProperty</code>的语法糖)<span style="color:red">他会在运行时被调用,被装饰器的声明信息做为参数传入</span></p></blockquote><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">function test(target: any) &#123;  console.log(&quot;hello world&quot;)&#125;@testclass A &#123;&#125;&#x2F;&#x2F;hello world<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol><li>类(Class)</li><li>类属性(Class Property)</li><li>类方法(Class Method)</li><li>类访问器(Class Accessor)</li><li>类方法参数(Class Method Parameter)</li></ol><ul><li>因此,应用装饰器很像组成一系列函数,非常像高阶函数或类.使用装饰器,我们可以轻松实现代理模式来减少代码</li><li>对于这几种装饰器,都可以使用工厂模式来达到传入想要修改属性的目的(或者其它)</li></ul><h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a><a href="proxy.md">代理模式</a></h3><blockquote><p>代理模式是在访问真正对象时,提供额外的逻辑,检查对真实对象的操作.例如在对真实对象操作占用大量资源时,进行缓存,或者在调用对真实对象的操作之前检查前提条件</p></blockquote><ul><li>例如javascript中的proxy就是一个典型的代理模式</li></ul><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">const</span> target <span class="token operator">=</span> <span class="token punctuation">&#123;</span>  name<span class="token operator">:</span> <span class="token string">'zhangsan'</span><span class="token punctuation">&#125;</span><span class="token keyword">const</span> handler <span class="token operator">=</span> <span class="token punctuation">&#123;</span>  <span class="token function">get</span> <span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>key<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token string"> 被读取</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span>    <span class="token keyword">return</span> target<span class="token punctuation">[</span>key<span class="token punctuation">]</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>  <span class="token function">set</span> <span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>key<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token string"> 被设置为 </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>value<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span>    target<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> value  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">const</span> proxy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> handler<span class="token punctuation">)</span>proxy<span class="token punctuation">.</span>name<span class="token comment">//name 被读取</span>proxy<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'lisi'</span><span class="token comment">//name 被设置为 lisi</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>target<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token comment">//lisi</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="定义装饰器"><a href="#定义装饰器" class="headerlink" title="定义装饰器"></a>定义装饰器</h3><blockquote><p>由于TypeScript中的装饰器还在实验性语法,需要在<code>tsconfig.json</code>编译选项中开启</p></blockquote><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token punctuation">&#123;</span>  <span class="token property">"compilerOptions"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>      <span class="token property">"experimentalDecorators"</span><span class="token operator">:</span> <span class="token boolean">true</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>装饰器的执行时机:装饰器对类的行为的改变,是<strong>代码编译时发生的</strong>(不是TypeScript编译,而是js在执行机中的编译阶段),并不是在运行是.<span style="color:red">本质就是装饰器是编译时执行的函数</span></li></ul><h4 id="类装饰器"><a href="#类装饰器" class="headerlink" title="类装饰器"></a>类装饰器</h4><ul><li>类装饰器在类声明之前绑定,可以用来监视,或者修改或者替换类定义</li><li>在执行类装饰器函数的时候,会把绑定的类作为器唯一的参数传递给装饰器</li><li>参数:<strong>类的构造器</strong><ul><li>如果装饰器返回一个新的类,他会用新的类替换原有的类的定义</li><li><span style="color:red">类装饰器适合用于继承一个现有类并添加一些属性和方法</span></li></ul></li></ul><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">function test() &#123;  return function (target: any) &#123;    person.prototype.name &#x3D; &quot;jack&quot;    person.prototype.say &#x3D; function () &#123;      console.log(this.name)    &#125;  &#125;&#125;@testclass Person &#123;  name: string  constructor(name: string) &#123;    this.name &#x3D; name  &#125;  say() &#123;    console.log(&quot;lisi&quot;)  &#125;&#125;new Person(&quot;fw&quot;).say()&#x2F;&#x2F;fwconsole.log(new Person(&quot;fw&quot;).name)&#x2F;&#x2F;fw<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>name属性并不会像想象中的那样变为:<strong>jack</strong>.那首先我们得明白他的初始化机制<ol><li>在Person类初始化之后,会先执行装饰器,而不是直接使用new关键字</li><li>name首先被初始化为<code>jack</code>,然后使用new产生对象,传入的<code>fw</code>会覆盖<code>jack</code>属性</li></ol></li></ul><h4 id="方法装饰器"><a href="#方法装饰器" class="headerlink" title="方法装饰器"></a>方法装饰器</h4><ul><li><p>方法装饰器写在一个方法的声明之前</p></li><li><p>方法装饰器可以用来监视,修改或者替换方法定义</p></li><li><p>方法装饰器表达式会在运行时当作函数被调用,传入一下三个参数</p><ol><li>对于静态成员来说是类的构造函数,对于实例成员是类的<strong>原型对象</strong></li><li>被绑定方法的名字</li><li>被绑定方法的属性描述符</li></ol></li><li><p>方法装饰器更像是<code>defineProperty</code>的一个语法糖</p></li></ul><table><thead><tr><th>属性</th><th>描述</th><th>默认值</th></tr></thead><tbody><tr><td>value</td><td>当试图获取属性时所返回的值</td><td>undefined</td></tr><tr><td>writable</td><td>该属性是否可写</td><td>false</td></tr><tr><td>enumerable</td><td>该属性在for in循环中是否会被枚举</td><td>false</td></tr><tr><td>configurable</td><td>该属性是否可被删除</td><td>false</td></tr><tr><td>set()</td><td>属性的更新操作所调用的函数</td><td>false</td></tr><tr><td>get()</td><td>获取属性值时所调用的函数</td><td>false</td></tr></tbody></table><ol><li>数据描述符:enumerable,configurable,value,writable</li><li>存取描述符:enumerable,configurable,set(),get()</li><li>如果定义了set(),get()之后,再定义value,writable会<span style="color:red">报错</span></li></ol><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">function test(target: any, key: string, descriptor: PropertyDescriptor) &#123;  console.log(target)  &#x2F;&#x2F;&#123;  &#125;  console.log(key)&#x2F;&#x2F;say  console.log(descriptor)  &#x2F;&#x2F;&#123;  &#x2F;&#x2F;value: [Function (anonymous)],  &#x2F;&#x2F;writable: true,  &#x2F;&#x2F;enumerable: false,  &#x2F;&#x2F;configurable: true  &#x2F;&#x2F;&#125;  descriptor.value &#x3D; function () &#123;    console.log(&quot;test&quot;)  &#125;&#x2F;&#x2F;输出test,而不是&#96;我是fw&#96;&#125;class Person &#123;  @test  say() &#123;    console.log(&quot;我是fw&quot;)  &#125;  sayName() &#123;    console.log(&quot;我是zhangsan&quot;)  &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>当然使用工厂函数会是更好的选择</li></ul><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">function configurable(value: boolean) &#123;  return function (target: any, propertyKey: string, descriptor: PropertyDescriptor) &#123;    descriptor.configurable &#x3D; value;  &#125;;&#125;@configurable(false)...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="访问器装饰器"><a href="#访问器装饰器" class="headerlink" title="访问器装饰器"></a>访问器装饰器</h4><ul><li>访问器装饰器声明在一个访问器的声明之前.</li><li>访问器装饰器应用于访问器的属性描述符并且可以用来监视,修改或替换一个访问器的定义</li><li>访问器装饰器表达式会在运行时当作函数被调用,传入下列3个参数:<ul><li>对于静态成员来说是类的构造函数,对于实例成员是类的<strong>原型对象</strong>.</li><li>成员的名字.</li><li>成员的属性描述符.</li></ul></li></ul><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">function test() &#123;  return function (target: any, key: string, descriptor: PropertyDescriptor) &#123;    console.log(target) &#x2F;&#x2F;&#123;&#125;,原型对象上并没有任何属性    console.log(key) &#x2F;&#x2F;name.构造器的名称    console.log(descriptor)    &#x2F;&#x2F;&#123;    &#x2F;&#x2F;get: [Function: get name],    &#x2F;&#x2F;set: [Function: set name],    &#x2F;&#x2F;enumerable: false,    &#x2F;&#x2F;configurable: true    &#x2F;&#x2F;&#125;    descriptor.set &#x3D; function (value) &#123;      value &#x3D; value + &quot;fw&quot;      target.myName &#x3D; value    &#125;    descriptor.get &#x3D; function () &#123;      return target.myName    &#125;  &#125;&#125;class Person &#123;  private _name: string  myName!: string  constructor(name: string) &#123;    this._name &#x3D; name  &#125;  @test  get name() &#123;    return this._name  &#125;  set name(value) &#123;    this._name &#x3D; value  &#125;&#125;const p &#x3D; new Person(&quot;zhangsan&quot;)p.name &#x3D; &quot;lisi&quot;console.log(p.name)&#x2F;&#x2F;&quot;lisifw&quot;console.log(p)&#x2F;&#x2F; &#123; _name: &#39;zhangsan&#39; &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>注意:<span style="color:red">TypeScript不允许同时装饰一个成员的get和set访问器</span></li></ul><h4 id="参数装饰器"><a href="#参数装饰器" class="headerlink" title="参数装饰器"></a>参数装饰器</h4><ul><li>参数装饰器写在一个参数声明之前.</li><li>参数装饰器表达式会在运行时当作函数被调用,传入下列3个参数:<ul><li>对于静态成员来说是类的构造函数,对于实例成员是类的<strong>原型对象</strong>.</li><li>参数所在的方法名称.</li><li>参数在参数列表中的索引.</li></ul></li></ul><blockquote><p>注意:属性装饰器,参数装饰器最常见的应用场景就是配合元数据(reflect-metadata),在不改变原有结构的同时添加一些额外的信息</p></blockquote><ul><li>但是元数据目前也是在提案中, 也还没有纳入正式的标准.所以对于装饰器而言, 我们只需要了解即可,因为提案中的所有内容将来都是有可能被修改的(可能会被修改)</li></ul><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">function test() &#123;  return function (target: any, proptyName: string, index: number) &#123;    console.log(target)&#x2F;&#x2F;&#123;&#125;    console.log(proptyName)&#x2F;&#x2F;say    console.log(index)&#x2F;&#x2F;1  &#125;&#125;class Person &#123;  say(age: number, @test() name: string): void &#123;    console.log(age + name)  &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="属性装饰器"><a href="#属性装饰器" class="headerlink" title="属性装饰器"></a>属性装饰器</h4><ul><li>属性装饰器写在一个属性声明之前</li><li>属性装饰器表达式会在运行时当作函数被调用,传入下列2个参数:<ul><li>对于静态成员来说是类的构造函数,对于实例成员是类的<strong>原型对象</strong></li><li>成员的名字</li></ul></li></ul><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">function test(flag:string)&#123;  console.log(flag);&#x2F;&#x2F;hello  return (target: any, propertyKey: string) &#x3D;&gt;&#123;      console.log(target);&#x2F;&#x2F;class[person]      console.log(propertyKey);&#x2F;&#x2F;age  &#125;&#125;class Person&#123;  name:string;  @test(&#39;hello&#39;)  static age:number;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="装饰器的执行顺序"><a href="#装饰器的执行顺序" class="headerlink" title="装饰器的执行顺序"></a>装饰器的执行顺序</h3><blockquote><p>不同装饰器的执行顺序是固定的</p></blockquote><ol><li>实例成员:方法&#x2F;访问器&#x2F;属性装饰器-&gt;参数装饰器</li><li>静态成员:方法&#x2F;访问器&#x2F;属性装饰器-&gt;参数装饰器</li><li>类装饰器</li><li>构造器:参数装饰器</li></ol><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">function f(key: string): any &#123;  console.log(&quot;evaluate: &quot;, key)  return function () &#123;    console.log(&quot;call: &quot;, key)  &#125;&#125;@f(&quot;Class Decorator&quot;)class C &#123;  @f(&quot;Static Property&quot;)  static prop?: number  @f(&quot;Static Method&quot;)  static method(@f(&quot;Static Method Parameter&quot;) foo: number) &#123;&#125;  constructor(@f(&quot;Constructor Parameter&quot;) foo: number) &#123;&#125;  @f(&quot;Instance Method&quot;)  method(@f(&quot;Instance Method Parameter&quot;) foo: number) &#123;&#125;  @f(&quot;Instance Property&quot;)  prop?: number&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">&#x2F;&#x2F;实例方法-&gt;参数evaluate:  Instance Methodevaluate:  Instance Method Parametercall:  Instance Method Parametercall:  Instance Method&#x2F;&#x2F;实例属性evaluate:  Instance Propertycall:  Instance Property&#x2F;&#x2F;静态属性evaluate:  Static Propertycall:  Static Property&#x2F;&#x2F;静态方法evaluate:  Static Methodevaluate:  Static Method Parametercall:  Static Method Parametercall:  Static Method&#x2F;&#x2F;类装饰器-&gt;构造函数:参数装饰器evaluate:  Class Decoratorevaluate:  Constructor Parametercall:  Constructor Parametercall:  Class Decorator<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>对于属性访问装饰器(动态&#x2F;静态)而言,会按照声明的顺序声明它们的装饰器的顺序</li></ul><blockquote><p>同样方法中不同参数的装饰器的执行顺序是相反的,最后一个参数的装饰器会最先被执行</p></blockquote><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">class C &#123;  method(@f(&quot;Parameter Foo&quot;) foo: number, @f(&quot;Parameter Bar&quot;) bar: number) &#123;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">evaluate:  Parameter Fooevaluate:  Parameter Barcall:  Parameter Barcall:  Parameter Foo<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>一些可能用到的场景</p></blockquote><ul><li>Before&#x2F;After钩子.</li><li>监听属性改变或者方法调用.</li><li>对方法的参数做转换.</li><li>添加额外的方法和属性.</li><li>运行时类型检查.</li><li>自动编解码.</li><li>依赖注入.</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;装饰器&quot;&gt;&lt;a href=&quot;#装饰器&quot; class=&quot;headerlink&quot; title=&quot;装饰器&quot;&gt;&lt;/a&gt;装饰器&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;装饰器是一种特殊的类型声明,他能被附加到类声明,方法,访问符,属性或者参数上,可以修改类的行为.装饰器使用</summary>
      
    
    
    
    <category term="TS" scheme="http://mail.zyjcould.ltd/categories/TS/"/>
    
    
    <category term="JS" scheme="http://mail.zyjcould.ltd/tags/JS/"/>
    
    <category term="TS" scheme="http://mail.zyjcould.ltd/tags/TS/"/>
    
  </entry>
  
  <entry>
    <title>递归</title>
    <link href="http://mail.zyjcould.ltd/2022/03/04/di-gui/"/>
    <id>http://mail.zyjcould.ltd/2022/03/04/di-gui/</id>
    <published>2022-03-04T14:11:59.000Z</published>
    <updated>2022-03-19T08:12:04.944Z</updated>
    
    <content type="html"><![CDATA[<h2 id="递归-recursion"><a href="#递归-recursion" class="headerlink" title="递归(recursion)"></a>递归(recursion)</h2><blockquote><p>程序调用自身的技巧就被称之为递归(recursion)</p></blockquote><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">function factorial(n: number): number &#123;  if (n &lt;&#x3D; 1) &#123;    return 1  &#125;  return n * factorial(n - 1)&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>从阶乘这里看出,递归是需要条件的</p></blockquote><ul><li>递归序要具备<strong>边界条件</strong>,<strong>递归前进段</strong>以及<strong>递归返回段</strong>.当边界条件不满足时,递归前进,当边界满足时,递归返回.例如阶乘中的<code>n&lt;=1</code>就是边界条件</li><li>如何使用递归  <ol><li>子问题须与原始问题为同样的事,使用递归化繁为简</li><li>不能无限制的调用本身,必须要有一个出口,化简为非递归的状态处理</li></ol></li></ul><blockquote><p>执行上下文栈</p></blockquote><ul><li>当执行一个函数的时候,就会创建一个执行上下文,并且压入执行上下文栈,当函数执行完毕,就会将函数从执行上下文栈中弹出.</li><li>当使用阶乘的时候,ts(或者是说js)会不停的创建执行上下文压入上下文栈中,对于内存而言,这是非常大的消耗</li><li>使用尾调用优化</li></ul><h3 id="尾调用-Tail-Call"><a href="#尾调用-Tail-Call" class="headerlink" title="尾调用(Tail Call)"></a><a href="https://www.ruanyifeng.com/blog/2015/04/tail-call.html">尾调用(Tail Call)</a></h3><blockquote><p>尾调用就是某个函数的最后一步调用另一个函数</p></blockquote><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token parameter">n</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token keyword">return</span> <span class="token function">g</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>但是在最后一步调用函数之后不能有别的操作</li></ul><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token comment">// 调用函数之后有别的操作,即使语义完全一样</span><span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token parameter">x</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token keyword">let</span> y <span class="token operator">=</span> <span class="token function">g</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> y<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 调用函数之后有别的操作</span><span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token parameter">x</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token keyword">return</span> <span class="token function">g</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>尾调用不一定出现在函数尾部,只要是最后一步操作即可</li></ul><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token parameter">x</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token function">m</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">return</span> <span class="token function">n</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>尾调用优化</p></blockquote><ul><li>函数调用会在内存中形成一个<code>调用记录</code>(调用帧).保存调用的位置何内部的变量信息</li><li>如果函数A的内部调用函数B,那么A 的调用记录上当,会形成一个调用记录B.等到B运行结束.才会将结果返回A.如果还有别的的调用记录栈,会依次形成一个调用栈</li><li>由于<strong>尾调用是函数</strong>的最后一步操作,所以是不需要保留外层函数的调用记录,因为调用位置,内部变量等都用不到了,只要直接使用内层函数的调用记录,取代外层函数的调用记录就可以了</li></ul><ol><li><p>尾调用的函数执行上下文的变化</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token comment">// 伪代码</span>ECStack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token operator">&lt;</span>f<span class="token operator">></span> functionContext<span class="token punctuation">)</span><span class="token punctuation">;</span>ECStack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>ECStack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token operator">&lt;</span>g<span class="token operator">></span> functionContext<span class="token punctuation">)</span><span class="token punctuation">;</span>ECStack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>非尾调用的函数执行上下文</p><ul><li>由于返回函数<code>g(x)+1</code>中的g(x)需要执行完之后(执行的环境就是f(x)的上下文),再加1</li></ul><pre class="line-numbers language-js" data-language="js"><code class="language-js">ECStack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token operator">&lt;</span>f<span class="token operator">></span> functionContext<span class="token punctuation">)</span><span class="token punctuation">;</span>ECStack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token operator">&lt;</span>g<span class="token operator">></span> functionContext<span class="token punctuation">)</span><span class="token punctuation">;</span>ECStack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>ECStack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ol><ul><li>那么可以使用尾调用来重写阶乘的递归<ul><li>由于每次调用之后,只会保留一个调用记录,所以复杂度只有O(1)</li></ul></li></ul><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">function factorial(n: number, total: number): number &#123;  if (n &lt;&#x3D; 1) &#123;    return total  &#125;  return factorial(n - 1, n * total)&#125;console.log(factorial(4, 1))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="实现尾递归"><a href="#实现尾递归" class="headerlink" title="实现尾递归"></a>实现尾递归</h4><blockquote><p>尾递归函数确保最后异步只调用自身.需要把所有的内部变量变成函数的参数(这里就可以使用柯里化来增加函数的复用)</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;递归-recursion&quot;&gt;&lt;a href=&quot;#递归-recursion&quot; class=&quot;headerlink&quot; title=&quot;递归(recursion)&quot;&gt;&lt;/a&gt;递归(recursion)&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;程序调用自身的技巧就被称之为递</summary>
      
    
    
    
    <category term="TS" scheme="http://mail.zyjcould.ltd/categories/TS/"/>
    
    
    <category term="JS" scheme="http://mail.zyjcould.ltd/tags/JS/"/>
    
    <category term="TS" scheme="http://mail.zyjcould.ltd/tags/TS/"/>
    
  </entry>
  
  <entry>
    <title>函数组合&amp;记忆</title>
    <link href="http://mail.zyjcould.ltd/2022/02/27/han-shu-zu-he-ji-yi/"/>
    <id>http://mail.zyjcould.ltd/2022/02/27/han-shu-zu-he-ji-yi/</id>
    <published>2022-02-27T11:35:27.000Z</published>
    <updated>2022-07-24T01:20:54.569Z</updated>
    
    <content type="html"><![CDATA[<h2 id="纯函数-Purity"><a href="#纯函数-Purity" class="headerlink" title="纯函数(Purity)"></a>纯函数(Purity)</h2><ol><li>应始终返回相同的值.不管调用该函数多少次,或者什么时候调用都是一样的</li><li>自包含(不包含全局变量)</li><li>不应修改程序的状态或引起副作用(修改全局变量)</li></ol><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">&#x2F;&#x2F;纯函数const greet &#x3D; (name:string) &#x3D;&gt; &#96;hello, $&#123;name&#125;&#96;greet(&#39;world&#39;)&#x2F;&#x2F;不是纯函数,修改了外部的状态let greeting:stringconst greet &#x3D; (name:string) &#x3D;&gt;&#123;   greeting &#x3D; &#96;hello, $&#123;name&#125;&#96;&#125;greet(&#39;world&#39;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>副作用(Side effects):如果函数与外部可变状态进行交互,则它就是具有副作用的</p></blockquote><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">&#x2F;&#x2F;Date对象就是一个很常见的具有副作用的函数const differentEveryTime &#x3D; new Date()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="幂等性"><a href="#幂等性" class="headerlink" title="幂等性"></a>幂等性</h2><blockquote><p>幂等性和纯函数还是有很大区别的,甚至说可以说是毫无无关系</p></blockquote><ol><li>幂等性函数可以具有副作用</li><li>函数执行多次返回相同的结果(<code>f(f(x))=f(x)</code>),则此函数具有幂等性</li></ol><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">Math.abs(Math.abs(-10))<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="函数组合-Function-Composing"><a href="#函数组合-Function-Composing" class="headerlink" title="函数组合(Function Composing)"></a>函数组合(Function Composing)</h2><blockquote><p>接收多个函数作为参数,从右到左,一个函数的输入为以一个函数的输出</p></blockquote><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">const compose &#x3D;  (f: Function, g: Function): Function &#x3D;&gt;  (a: Function): Function &#x3D;&gt;    f(g(a))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li>做一个反转函数,并且获取第一个索引的例子</li></ul><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">&#x2F;&#x2F;不能确定返回索引的类型,可以使用泛型,这里就用any了function first&lt;T&gt;(arr: T[]): any &#123;  return arr[0]&#125;function reverse&lt;T&gt;(arr: T[]): T[] &#123;  return arr.reverse()&#125;let last &#x3D; compose(first, reverse)console.log(last([1, 2, 3, 4, 5]))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>当然redux给出了一个更好的实现(将函数的个数情况也考虑周全了)</p></blockquote><ul><li>其实还有一个问题就是在闭包中写泛型其实是没有检查的效果</li></ul><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">function compose(...fns: Function[]) &#123;  if (fns.length &#x3D;&#x3D;&#x3D; 0) &#123;    return (arg: Function) &#x3D;&gt; arg  &#125;  if (fns.length &#x3D;&#x3D;&#x3D; 1) &#123;    return fns[0]  &#125;  return fns.reduce(    (a, b) &#x3D;&gt;    &#x2F;&#x2F;Writing a type here won&#39;t do any good      &lt;T&gt;(...args: T[]): Function &#x3D;&gt;        a(b(...args))  )&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="生成器的方式"><a href="#生成器的方式" class="headerlink" title="生成器的方式"></a>生成器的方式</h3><blockquote><p>实现 <code>map</code> 映射函数,由于生成器的<code>yield</code>接受的是上一次的结果,所以第一次的迭代效果是无效的</p></blockquote><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">function* genMap(iteratee: Function): Generator&lt;string | null, any&gt; &#123;  let input &#x3D; yield null  while (true) &#123;    input &#x3D; yield iteratee(input)  &#125;&#125;const gen &#x3D; genMap((x: string) &#x3D;&gt; x.toUpperCase())const arr &#x3D; [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]console.log(gen.next())for (let i of arr) &#123;  console.log(gen.next(i))&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>这种效率是比较低的,并且第一次是浪费的</li></ul><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">function* genMap(  iterable: Iterable&lt;any&gt;,  iteratee: Function): Generator&lt;string | null, any&gt; &#123;  for (let i of iterable) &#123;    yield iteratee(i)  &#125;&#125;const gen &#x3D; genMap([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;], (x: string) &#x3D;&gt; x.toUpperCase())<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>使用 <code>yield*</code> 来调用另一个生成器的方式来进行函数组合, <code>iterable</code>会不停的叠加作用域</p></blockquote><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">function* genCompose(  iterable: Iterable&lt;any&gt;,  ...fns: Function[]): Generator&lt;any, any, any&gt; &#123;  for (let fn of fns) &#123;    iterable &#x3D; genMap(iterable, fn)  &#125;  yield* iterable&#125;const composed &#x3D; genCompose(  [1, 2, 3],  (x: number) &#x3D;&gt; x + 1,  (x: number) &#x3D;&gt; x * x,  (x: number) &#x3D;&gt; x - 2)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Pointfree"><a href="#Pointfree" class="headerlink" title="Pointfree"></a><a href="https://www.ruanyifeng.com/blog/2017/03/pointfree.html">Pointfree</a></h3><blockquote><p>这是函数式编程的答案,利用函数组合和柯里化可以达到一个很好的函数式效果</p></blockquote><ul><li><a href="https://ramdajs.com/">ramda</a>中所有的函数都支持柯里化</li><li>阮老师的教程:<a href="https://www.ruanyifeng.com/blog/2017/03/ramda.html">https://www.ruanyifeng.com/blog/2017/03/ramda.html</a></li></ul><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token comment">//ramda</span>fn <span class="token operator">=</span> <span class="token constant">R</span><span class="token punctuation">.</span><span class="token function">pipe</span><span class="token punctuation">(</span>f1<span class="token punctuation">,</span> f2<span class="token punctuation">,</span> f3<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>定义<code>f1</code>,<code>f2</code>,<code>f3</code>可以推算出<code>fn</code>.整个过程中.根本不需要知到其中的参数变化</li><li>换一种当时可以理解为,只需要将一些简单的步骤合成到一起,定义成一种参数无关的合成运算</li><li>这种风格就是<code>Pointfree</code>.例如上面的例子就是一个<code>Pointfree</code></li></ul><blockquote><p><code>Pointfree</code>的本质就是使用一些通用的函数,组合除各种复杂的运算.shang层运算不直接操作数据</p></blockquote><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">interface Iperson &#123;  name: string  role: string&#125;const data: Iperson[] &#x3D; [  &#123; name: &quot;张三&quot;, role: &quot;worker&quot; &#125;,  &#123; name: &quot;李四&quot;, role: &quot;worker&quot; &#125;,  &#123; name: &quot;王五&quot;, role: &quot;manager&quot; &#125;,]type Iper &#x3D; keyof Ipersonconst isWorker &#x3D; (s: string) &#x3D;&gt; s &#x3D;&#x3D;&#x3D; &quot;worker&quot;&#x2F;&#x2F;定义查找角色的函数,在这里嵌套会增加耦合const prop &#x3D; (p: Iper, obj: Iperson) &#x3D;&gt; isWorker(obj[p])&#x2F;&#x2F;指定读取role的值const propRole &#x3D; curry(prop)(&quot;role&quot;)data.filter(propRole)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>如果不适用<code>compose Function</code>会大大增加函数的耦合度.这就可以使用函数组合的思想降低耦合,避免洋葱模型</li></ul><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">const prop &#x3D; (p: Iper, obj: Iperson) &#x3D;&gt; obj[p]console.log(data.filter((_, index) &#x3D;&gt; compose(isWorker, propRole)(data[index])))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="函数记忆"><a href="#函数记忆" class="headerlink" title="函数记忆"></a>函数记忆</h2><blockquote><p>只要把参数和对应的结果数据存到一个对象中,调用时,判断参数对应的数据是否存在,存在就返回对应的值</p></blockquote><ul><li>如果需要大量重复的计算又依赖于之前的计算,可以考虑函数记忆</li><li>利用Map,Set或者是数组做字典都是一种函数记忆</li><li>谨慎使用,消耗性很大</li></ul><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">const memoize &#x3D; function (fn: Function, hasher?: Function) &#123;  let cache: any &#x3D; &#123;&#125;  const menoize &#x3D; function (...args: any[]) &#123;    const address &#x3D; &quot;&quot; + (hasher ? hasher.apply(null, args) : args)    if (!cache[address]) &#123;      cache[address] &#x3D; fn.apply(null, args)    &#125;    return cache[address]  &#125;  return menoize&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>当然,抄袭<code>underscore</code>的使用ts重够了一下很快</p></blockquote><ul><li>当没有hansher(作为键的函数时),会让args作为键</li></ul><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">let add &#x3D; function (a: number, b: number, c: number) &#123;  return a + b + c&#125;let memoizedAdd &#x3D; memoize(add)console.log(memoizedAdd(1, 2, 3))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>测试一下是,没有问题的.但是我们如果想要使用一个生成键的函数<code>hasher</code></p></blockquote><ul><li>如果并不想要数组的全部内容,可以使用slice截取数组中的第一个作为键</li><li>当然也可以使用别的函数作为键</li></ul><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">const memoizedAdd &#x3D; memoize(add, function () &#123;  const args &#x3D; Array.prototype.slice.call(arguments,0,1)  return JSON.stringify(args)&#125;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;纯函数-Purity&quot;&gt;&lt;a href=&quot;#纯函数-Purity&quot; class=&quot;headerlink&quot; title=&quot;纯函数(Purity)&quot;&gt;&lt;/a&gt;纯函数(Purity)&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;应始终返回相同的值.不管调用该函数多少次,或者什么时候调用都</summary>
      
    
    
    
    <category term="TS" scheme="http://mail.zyjcould.ltd/categories/TS/"/>
    
    
    <category term="JS" scheme="http://mail.zyjcould.ltd/tags/JS/"/>
    
    <category term="TS" scheme="http://mail.zyjcould.ltd/tags/TS/"/>
    
  </entry>
  
  <entry>
    <title>迭代器与生成器</title>
    <link href="http://mail.zyjcould.ltd/2022/02/26/die-dai-qi-yu-sheng-cheng-qi/"/>
    <id>http://mail.zyjcould.ltd/2022/02/26/die-dai-qi-yu-sheng-cheng-qi/</id>
    <published>2022-02-26T05:09:57.000Z</published>
    <updated>2022-07-27T16:52:13.693Z</updated>
    
    <content type="html"><![CDATA[<h2 id="迭代-iteration"><a href="#迭代-iteration" class="headerlink" title="迭代(iteration)"></a>迭代(iteration)</h2><blockquote><p>循环时迭代的基础:循环可以指定迭代的次数,以及每次需要执行什么操作</p></blockquote><h3 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h3><blockquote><p>把实现了正式的<code>Iterable</code>接口的,并且可以通过迭代器<code>Iterator</code>使用的称做可选迭代器</p></blockquote><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">&#x2F;&#x2F;集合的元素可以按插入顺序访问每一个元素let set &#x3D; new Set&lt;number&gt;().add(1).add(2).add(3)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><blockquote><p>实现可迭代协议(Iterable接口):要求同时具备两种能力</p></blockquote><ul><li>支持迭代的自我识别能力和创建实现<code>Iterator</code>接口的对象能力</li><li>在ESMA中,必须暴露一个属性<code>Symbol.iterator</code>作为默认迭代器</li><li>这个默认的迭代器属性必须使用一个迭代器工厂函数(调用时返回一个迭代器)</li></ul><blockquote><p>实现<code>Iterable</code>接口的类型</p></blockquote><ul><li>string</li><li>Array</li><li>Map</li><li>Set</li><li>arguments</li><li>NodeList等DOM集合</li></ul><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">&#x2F;&#x2F;可以通过这种方式是否存在默认的迭代器属性console.log([][Symbol.iterator])&#x2F;&#x2F;[Function: values]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p>迭代器对象的原生语言</p></blockquote><ul><li><p><code>for...of</code>循环</p></li><li><p>数组解构</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">const num:number[] &#x3D; [1,2,3];let [a,b,c] &#x3D; num;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>扩展操作符<code>...</code></p></li><li><p><code>Array.from()</code></p></li><li><p><code>new Set()</code></p></li><li><p><code>new Map()</code></p></li><li><p><code>Promise.all()</code>接收promise组成的可迭代对象</p></li><li><p><code>Promise.race()</code>接收有promise组成的可迭代对象</p></li><li><p><code>yield*</code>操作符,在生成器中使用</p></li></ul><blockquote><p>迭代器使用<code>next()</code>方法在可迭代对象中遍历数据.</p></blockquote><ul><li>每成功调用<code>next()</code>都会返回一个<code>IteratorResult</code>对象,其中包含迭代器返回的下一个值</li><li><code>IteratorResult</code>包含两个属性:<code>done</code>和<code>value</code>.<ul><li>done是一个布尔值,表示是否<code>next()</code>还可以再次调用取得下一个值</li><li>value是包含可迭代对象的下一个值(<code>done:false</code>或者undefined),如果done位true表示结束</li></ul></li></ul><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">let num: number[] &#x3D; [1, 2]let arr &#x3D; num[Symbol.iterator]()console.log(arr.next())&#x2F;&#x2F;&#123; value: 1, done: false &#125;console.log(arr.next())&#x2F;&#x2F;&#123; value: 2, done: false &#125;console.log(arr.next())&#x2F;&#x2F;&#123; value: undefined, done: true &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>只要迭代器对象到达<code>done:true</code>状态,后续调用<code>next</code>都是一样的值</li></ul><h2 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h2><blockquote><p>生成器可以在一个函数块内暂停和恢复代码执行的功能(自定义迭代器或者实现协程)</p></blockquote><ul><li>一般只需要在函数名前加一个<code>*</code>表示他是一个生成器.只要是可以定义函数的地方,就可以定义生成器</li><li>调用生成器函数会返回一个<strong>生成器对象</strong>.<ul><li>生成器对象一开始处于暂停执行的状态.与迭代器相似</li><li>生成器对象同样实现了<code>Iterator</code>接口,因此具有next()方法</li><li>在迭代器中,value值是函数的返回值.默认是undefined</li></ul></li></ul><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">function* gen() &#123;  return &quot;value&quot;&#125;console.log(gen().next)&#x2F;&#x2F;[Function: next]console.log(gen().next())&#x2F;&#x2F;&#123; value: &#39;value&#39;, done: true &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><span style="color:red">生成器只会在初次调用<code>next()</code>方法后执行</span>.直接调用(例如<code>gen()</code>)并不会执行</li><li>生成器对象实现了<code>Iterable</code>接口,默认的迭代器是自引用的</li></ul><h3 id="yield"><a href="#yield" class="headerlink" title="yield"></a>yield</h3><blockquote><p>yield可以让生成器停止或者开始执行</p></blockquote><ul><li>生成器函数在遇到<code>yield</code>关键字之前会正常执行.遇到关键字之后,停止执行,函数作用域的状态会被保留</li><li>停止执行的生成器函数只能通过在生成器对象上调用<code>next()</code>方法来恢复执行</li><li>生成器是会被消费的,同一个生成器消费完后,不能再次被消费</li></ul><blockquote><p>通过<code>yield</code>关键字退出的生成器函数会处于<code>done:false</code>状态.而<code>return</code>关键字退出会处于<code>done:true</code></p></blockquote><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">function* gen() &#123;  yield &quot;done&quot;  yield &quot;data&quot;  return &quot;value&quot;&#125;let genObj &#x3D; gen()console.log(genObj.next())&#x2F;&#x2F;&#123; value: &#39;done&#39;, done: false &#125;console.log(genObj.next())&#x2F;&#x2F;&#123; value: &#39;data&#39;, done: false &#125;console.log(genObj.next())&#x2F;&#x2F;&#123; value: &#39;value&#39;, done: true &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>使用yield实现输入输出</p></blockquote><ul><li>yield除了作为中间返回语句使用,还可以作为函数的中间参数使用.</li><li>上一次上生成器函数暂停的<code>yield</code>关键字会接收到传给<code>next()</code>方法的第一个值</li><li>但是第一次调用next()传入的值不会被使用,因为第一次是为了开始执行生成器函数</li></ul><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">function* gen() &#123;  console.log(yield)  console.log(yield)&#125;let genObj &#x3D; gen()genObj.next(1)&#x2F;&#x2F;不会打印任何东西genObj.next(2)&#x2F;&#x2F;2genObj.next(3)&#x2F;&#x2F;3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>实现输入和输出</li></ul><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">function* gen() &#123;  return yield 1&#125;let genObj &#x3D; gen()console.log(genObj.next(3))&#x2F;&#x2F;&#123; value: 1, done: false &#125;console.log(genObj.next(2))&#x2F;&#x2F;&#123; value: 2, done: true &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol><li>因为函数需要对整个表达式求值才能确定需要返回的值,所以在遇到yield关键字暂停并执行计算要产生的值<code>1</code></li><li>下一次调用<code>next()</code>会传入<code>2</code>,作为交给<code>yield</code>的值.确定位本次生成器函数要返回的值</li></ol><blockquote><p>产生可迭代对象:可以使用<code>*</code>加强yield的行为,让他可以迭代一个可迭代对象,从而一次产出一个值</p></blockquote><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">function* gen() &#123;  yield* [1, 2, 3]&#125;for (let x of gen()) &#123;  console.log(x)&#125;&#x2F;&#x2F;1  &#x2F;&#x2F;2  &#x2F;&#x2F;3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>实际上<code>yield*</code>只是将一个可迭代的对象序列化为一连串的可以单独产出的值,所以这跟把<code>yield</code>凡在一个有循环里一样</li></ul><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">function* gen() &#123;  for (let x of [1,2,3])&#123;    yield x  &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>提前终止生成器</p></blockquote><ul><li>一个实现<code>Iterator</code>接口的对象一定有next()方法,还有一个可选的<code>return()</code>方法用于提前终止迭代器.生成器除了有这两个方法,还有第三个方法<code>throw()</code></li></ul><ol><li><p><code>return()</code>:强制生成器进入关闭状态.提供给return()方法的值,就是迭代器对象的值</p><ul><li>在ts中,如果<code>reuturn()</code>需要传入参数,那么返回值return要定义好类型才能使用,否则<code>void</code></li></ul><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">function* gen() &#123;  yield 1  return 3&#125;console.log(gen().return(4))&#x2F;&#x2F;&#123; value: 1, done: true &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><code>throw</code>:会在暂停的时候将一个提供的错误注入到生成器对象.如果错误未被处理,生成器将会关闭</p><ul><li>如果生成器函数内部处理了这个错误,那么生成器就不会关闭,而且还可以恢复执行</li><li>不过错误也会跳过相对应的yield.</li></ul><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">function* gen() &#123;  for (const x of [1, 2, 3]) &#123;    try &#123;      yield x    &#125; catch (e) &#123;&#125;  &#125;&#125;const g &#x3D; gen()console.log(g.next())&#x2F;&#x2F;&#123; value: 1, done: false &#125;g.throw(&quot;foo&quot;)console.log(g.next())&#x2F;&#x2F;&#123; value: 3, done: false &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><ul><li><p>如果生成器对象还没有被执行,那么调用throw()抛出的错误不会在函数内部被捕获.因为这相当于在函数块外抛出了错误</p><ul><li>以下依然会抛出错误</li></ul><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">function* gen() &#123;  for (const x of [1, 2, 3]) &#123;      try &#123;        yield x      &#125; catch (e) &#123;&#125;      yield x    &#125;&#125;const g &#x3D; gen()g.throw(&quot;foo&quot;)console.log(g.next())console.log(g.next())<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><blockquote><p>最后看一下Generator接口的写法</p></blockquote><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">&#x2F;&#x2F;Generatorinterface Generator&lt;T &#x3D; unknown, TReturn &#x3D; any, TNext &#x3D; unknown&gt; extends Iterator&lt;T, TReturn, TNext&gt; &#123;    next(...args: [] | [TNext]): IteratorResult&lt;T, TReturn&gt;;    return(value: TReturn): IteratorResult&lt;T, TReturn&gt;;    throw(e: any): IteratorResult&lt;T, TReturn&gt;;    [Symbol.iterator](): Generator&lt;T, TReturn, TNext&gt;;&#125;&#x2F;&#x2F;Iteratorinterface Iterator&lt;T, TReturn &#x3D; any, TNext &#x3D; undefined&gt; &#123;    next(...args: [] | [TNext]): IteratorResult&lt;T, TReturn&gt;;    return?(value?: TReturn): IteratorResult&lt;T, TReturn&gt;;    throw?(e?: any): IteratorResult&lt;T, TReturn&gt;;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>Generator</code>泛型接收三个类型<ul><li><strong>T</strong>:yield后的参数类型</li><li><strong>Treturn</strong>:return后的返回值类型</li><li><strong>TNext</strong>:next()函数中的实参类型,不过如果指定了类型,可以不写,或者必须写对应的类型</li></ul></li></ul><blockquote><p>使用生成器完成异步操作</p></blockquote><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">import</span> <span class="token operator">*</span> <span class="token keyword">as</span> fs <span class="token keyword">from</span> <span class="token string">"fs/promises"</span><span class="token keyword">function</span><span class="token operator">*</span> <span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">const</span> filePath <span class="token operator">=</span> <span class="token keyword">yield</span> fs<span class="token punctuation">.</span><span class="token function">readFile</span><span class="token punctuation">(</span><span class="token string">"index.txt"</span><span class="token punctuation">,</span> <span class="token string">"utf8"</span><span class="token punctuation">)</span>  <span class="token keyword">return</span> <span class="token keyword">yield</span> fs<span class="token punctuation">.</span><span class="token function">readFile</span><span class="token punctuation">(</span>filePath<span class="token punctuation">,</span> <span class="token string">"utf8"</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">function</span> <span class="token function">co</span><span class="token punctuation">(</span><span class="token parameter">gen</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>    <span class="token keyword">const</span> <span class="token function-variable function">next</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>      <span class="token keyword">const</span> <span class="token punctuation">&#123;</span> value<span class="token punctuation">,</span> done <span class="token punctuation">&#125;</span> <span class="token operator">=</span> gen<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>done<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">resolve</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span>      <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">res</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>          <span class="token function">next</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">)</span>      <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">const</span> gen <span class="token operator">=</span> <span class="token function">co</span><span class="token punctuation">(</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>gen<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">res</span> <span class="token operator">=></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;迭代-iteration&quot;&gt;&lt;a href=&quot;#迭代-iteration&quot; class=&quot;headerlink&quot; title=&quot;迭代(iteration)&quot;&gt;&lt;/a&gt;迭代(iteration)&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;循环时迭代的基础:循环可以指定</summary>
      
    
    
    
    <category term="TS" scheme="http://mail.zyjcould.ltd/categories/TS/"/>
    
    
    <category term="JS" scheme="http://mail.zyjcould.ltd/tags/JS/"/>
    
    <category term="TS" scheme="http://mail.zyjcould.ltd/tags/TS/"/>
    
  </entry>
  
  <entry>
    <title>函数柯里化&amp;偏函数&amp;惰性函数</title>
    <link href="http://mail.zyjcould.ltd/2022/02/24/han-shu-ke-li-hua-pian-han-shu-duo-xing-han-shu/"/>
    <id>http://mail.zyjcould.ltd/2022/02/24/han-shu-ke-li-hua-pian-han-shu-duo-xing-han-shu/</id>
    <published>2022-02-24T14:34:17.000Z</published>
    <updated>2022-03-19T08:12:04.925Z</updated>
    
    <content type="html"><![CDATA[<h2 id="柯里化"><a href="#柯里化" class="headerlink" title="柯里化"></a>柯里化</h2><blockquote><p>什么是函数柯里化?</p><p>在计算机中,柯里化是将使用多个参数的一个函数转换成一些列使用一个参数的函数</p></blockquote><ul><li>例如:</li></ul><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">function add(a:number,b:number) &#123;  return a+b&#125;&#x2F;&#x2F;执行add函数,依次传入两个参数add(1,2)&#x2F;&#x2F;如果有一个carry函数,可以做到柯里化let addCurry &#x3D; curry(add)addCurry(1)(2)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>柯里化的用途可以理解为参数复用,本质上是降低通用性,提高适用性</p></blockquote><ul><li>例如有一段这样的数据</li></ul><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">const person &#x3D; [&#123;name:&quot;zhangsan&quot;&#125;,&#123;name:&quot;lisi&quot;&#125;]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol><li><p>使用map函数</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">let names &#x3D; person.map(function(item)&#123;  return item.name&#125;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>如果对象中有多个属性,那就要写多个map才行</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">let prop &#x3D;curry((key,obj)&#x3D;&gt;&#123;  obj[key]&#125;)let name &#x3D; person.map(prop(&quot;name&quot;))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ol><ul><li>这样就体现出柯里化的重要性</li></ul><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">function curry&lt;T&gt;(fn: Function): Function &#123;  return function (...args: T[]) &#123;    if (args.length &lt; fn.length) &#123;      return curry(fn.bind(this, ...args))    &#125; else &#123;      return fn(...args)    &#125;  &#125;&#125;function add(a: number, b: number, c: number) &#123;  return a + b + c&#125;let curryAdd &#x3D; curry(add)console.log(curryAdd(1, 3)(3))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>fn.length</code>就是被柯里化函数的</li><li><code>...args</code>是被柯里化函数的返回值(curryAdd)传入的个数.理想状态是只传一个</li><li><code>curryAdd</code>本质上来讲就是curry函数的返回值,只有curryAdd有实参,args才会有值</li></ul><ol><li><p>执行<code>let curryAdd = curry(add)</code>,返回一个闭包</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">function (...args: T[]) &#123;    if (args.length &lt; fn.length) &#123;      return curry(fn.bind(null, ...args))    &#125; else &#123;      return fn(...args)    &#125;  &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>执行<code>curryAdd(1,3)</code>当前的<code>fn.length</code>就是add形参的数量3大于实参的数量2</p><ul><li>同样返回了和1一样的一个闭包,<span style="color">但是fn发生了改变,传入的是<code>fn.bind(null, ...args)</code></span></li><li>执行一个递归,由于bind函数是柯里化的,这里的<code>fn.length</code>在结束的时候就变成了1</li></ul></li><li><p>执行<code>[curryAdd(1,3)](3)</code>当前的<code>fn.length</code>由于是会执行else的内容</p><ul><li><code>add.bind(this, 1 , 3)(3)</code>:这样就利用bind完成了一个柯里化的过程</li></ul></li></ol><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">type IPerson &#x3D; &#123;  name: string  age: number&#125;const person: IPerson[] &#x3D; [  &#123; name: &quot;zhangsan&quot;, age: 12 &#125;,  &#123; name: &quot;lisi&quot;, age: 100 &#125;,]let prop &#x3D; curry((key: keyof IPerson, obj: IPerson) &#x3D;&gt; &#123;  return obj[key]&#125;)console.log(person.map(prop(&quot;name&quot;)))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="偏函数-Partial-Function"><a href="#偏函数-Partial-Function" class="headerlink" title="偏函数(Partial Function)"></a>偏函数(Partial Function)</h2><blockquote><p>在计算机科学中，偏函数是指固定一个函数的一些参数，然后产生另一个更小元的函数。</p><p>什么是元？元是指函数参数的个数，比如一个带有两个参数的函数被称为二元函数。</p></blockquote><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">function add(a, b) &#123;    return a + b;&#125;&#x2F;&#x2F; 执行 add 函数，一次传入两个参数即可add(1, 2) &#x2F;&#x2F; 3&#x2F;&#x2F; 假设有一个 partial 函数可以做到局部应用var addOne &#x3D; partial(add, 1);addOne(2) &#x2F;&#x2F; 3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>和函数柯里化的区别</p></blockquote><ol><li>柯里化是将一个多参数函数转换成多个单参数函数,也就是将一个n元函数转换成n个一元函数</li><li>偏函数则是固定一个函数的一个或者多个参数,也就是将一个n元函数转换成一个n-x元函数</li></ol><ul><li>柯里化和偏函数的关系:<strong>柯里化通过偏函数来实现</strong></li></ul><blockquote><p>当然也可以使用<code>bind</code>函数来实现偏函数</p></blockquote><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">function test(a: number, b: number, c: number) &#123;  return a + b + c&#125;let bindOne &#x3D; test.bind(null, 1)console.log(bindOne(2, 3))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>但是这会直接改变this的指向</li></ul><blockquote><p>手动实现</p></blockquote><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">function partical(fn: Function, ...args: any[]): Function &#123;  return function (...moreArgs: any[]) &#123;    return fn(...args, ...moreArgs)  &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="惰性函数"><a href="#惰性函数" class="headerlink" title="惰性函数"></a>惰性函数</h2><blockquote><p>惰性函数就是说函数执行一次后，之后调用函数都是相同的作用，直接返回第一次执行函数.很多时候只需要执行一次，因为之后每次调用函数执行的结果都一样。所以如果函数语句不必每次执行，我们可以使用称之为惰性函数的技巧来进行优化。</p></blockquote><ul><li>如果我们现在需要写一个 foo 函数，这个函数返回首次调用时的 Date 对象，注意是首次</li></ul><ol><li><p>闭包的写法</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">let foo: () &#x3D;&gt; Function &#x3D; function () &#123;  let time: Date &#x3D; new Date()  return function () &#123;    if (time) time    return time  &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>惰性函数:惰性函数就是解决每次都要进行判断的这个问题，解决原理很简单，重写函数</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">let foo: () &#x3D;&gt; Function | Date &#x3D; function () &#123;  let time: Date &#x3D; new Date()  foo &#x3D; function () &#123;    return time  &#125;  return foo()&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h3 id="惰性求值-Lazy-evaluation"><a href="#惰性求值-Lazy-evaluation" class="headerlink" title="惰性求值(Lazy evaluation)"></a>惰性求值(Lazy evaluation)</h3><blockquote><p>按需求值机制,只有当需要计算所得值时才会计算</p></blockquote><ul><li>利用生成器机制可以很容易写出</li></ul><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">const rand &#x3D; function* () &#123;  while (true) &#123;    yield Math.random()    &#125; &#125;const randIter &#x3D; rand()randIter.next()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;柯里化&quot;&gt;&lt;a href=&quot;#柯里化&quot; class=&quot;headerlink&quot; title=&quot;柯里化&quot;&gt;&lt;/a&gt;柯里化&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;什么是函数柯里化?&lt;/p&gt;
&lt;p&gt;在计算机中,柯里化是将使用多个参数的一个函数转换成一些列使用一个参数的函</summary>
      
    
    
    
    <category term="TS" scheme="http://mail.zyjcould.ltd/categories/TS/"/>
    
    
    <category term="JS" scheme="http://mail.zyjcould.ltd/tags/JS/"/>
    
    <category term="TS" scheme="http://mail.zyjcould.ltd/tags/TS/"/>
    
  </entry>
  
  <entry>
    <title>cookie,session和token</title>
    <link href="http://mail.zyjcould.ltd/2022/02/23/cookie-session-he-token/"/>
    <id>http://mail.zyjcould.ltd/2022/02/23/cookie-session-he-token/</id>
    <published>2022-02-23T07:51:42.000Z</published>
    <updated>2022-03-20T06:35:04.312Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>由于HTTP是无状态的,当关闭网页的时候,服务器并不能意识到还是你来访问的</p></blockquote><ul><li><p>这就涉及到如何让浏览器记住这些信息(例如用户的账号和密码)</p><ol><li>保证密码和账号不易被破解并且完美保存</li><li>保证http无状态的问题,并且在每一次请求中加入这些信息保持登录</li></ol></li><li><p>可以事先每次http请求都自带数据给服务器的技术–&gt;cookie</p></li></ul><h2 id="Cookie-amp-Session"><a href="#Cookie-amp-Session" class="headerlink" title="Cookie&amp;Session"></a>Cookie&amp;Session</h2><p><img src="./cookie.png" alt="cookie"></p><ol><li>浏览器发送http请求后,服务器会进行cookie设置.<code>Set-Cookie</code></li><li><code>Cookie</code>中有<code>value</code>和<code>name</code>两个重要属性</li><li>浏览器会将cookie保存起来,并且在以后的每一个请求自动附上这个Cookie</li></ol><ul><li>并且打开浏览器就可以看到cookie,并且如果将用户密码等重要信息放在浏览器就很不安全</li></ul><blockquote><p>Session,浏览器和服务器是在进行会话,然而比较模糊的就是会话时间.因为关闭浏览器的行为可能是不小心的</p></blockquote><p><img src="./session.png" alt="session"></p><ul><li>所以很多网站会给每个用户的会话设定会话时间(结束会话的时间)和唯一的ID,并且这些session一般都是存储在数据库中的</li></ul><ol><li>当使用用户名密码发送到服务器,认证成功后,会创建一个SessionID和会话结束时间,还有其它参数</li><li>服务器会将<code>SessionID和会话结束时间</code>包含在cookie中发送给浏览器<ul><li>服务器在发送cookie之前会对这个含有Session ID的cookie进行签名</li></ul></li><li>浏览器会将包含SessionID的Cookie进行保存(并没有保存账号密码)</li></ol><ul><li>浏览器会利用cookie的特点,每次访问都会带有sessionid,直到有效期失效后会自行删除cookie</li></ul><blockquote><p>如果有大量用户访问服务器的时候,服务器依旧使用基于cookie的session,就需要存储大量<code>SessionID</code>在服务器中.</p><p>如果有多台服务器的情况,服务器中的SessionID还要分配给其它服务器才能保证用户避免再次输入用户名和密码</p></blockquote><h2 id="JWT-Json-Web-Token"><a href="#JWT-Json-Web-Token" class="headerlink" title="JWT(Json Web Token)"></a>JWT(Json Web Token)</h2><p><img src="./token.png" alt="Token"></p><ol><li>用户第一次登录网页,服务器会生成一个JWT,服务器不需要保存JWT,只需要保存<strong>JWT签名的密文</strong></li><li>接着把JWT发送给服务器,浏览器可以以<code>Cookie</code>或者<code>Storage</code>的形式进行存储</li></ol><ul><li>token验证登录<blockquote><p>三段式加密字符串:header(算法).payload(数据).signature(签名信息)</p><blockquote><ul><li>第一段:头,签证:安全信息验证,你的口令,进行不可逆加密</li><li>第二段:你要保存的信息:将<code>header</code>和<code>payload</code>base64编码后进行算法运算得到签名信息</li><li>第三段:额外信息:不可逆加密</li></ul><blockquote><p> 这一段字符串由后端发给前端.在登陆过以后,生成一个token给前端,前端保存这个token如果前端需要登录后查看页面,或者登陆后发送的请求,只要你把token带回来,解密一下</p></blockquote></blockquote></blockquote></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>Session是由服务器诞生并且保存在服务器中的,由服务器主导</li><li>Cookie是一种数据载体,把session保存在cookie中,送到客户端中,就可以跟随每个http发送</li><li>Token诞生在服务器,但保存在浏览器中,可以放在Cookie或者Storage中.持有Token就像持有令牌可以访问服务器</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;由于HTTP是无状态的,当关闭网页的时候,服务器并不能意识到还是你来访问的&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;这就涉及到如何让浏览器记住这些信息(例如用户的账号和密码)&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;保证密码和账号不易被破解并</summary>
      
    
    
    
    <category term="config" scheme="http://mail.zyjcould.ltd/categories/config/"/>
    
    
    <category term="config" scheme="http://mail.zyjcould.ltd/tags/config/"/>
    
    <category term="HTTP" scheme="http://mail.zyjcould.ltd/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>Github-cli</title>
    <link href="http://mail.zyjcould.ltd/2022/02/21/github-cli/"/>
    <id>http://mail.zyjcould.ltd/2022/02/21/github-cli/</id>
    <published>2022-02-21T02:29:42.000Z</published>
    <updated>2022-03-19T08:12:04.881Z</updated>
    
    <content type="html"><![CDATA[<h2 id="githubCli"><a href="#githubCli" class="headerlink" title="githubCli"></a><a href="https://cli.github.com/">githubCli</a></h2><blockquote><p>简单来讲,gihub是一个基于可视化的操作存储库.而githubcli就是使用命令操作存储库</p></blockquote><ul><li><p>下载完之后,可能有一系列玄学问题.重启一下可以解决80%</p></li><li><p>使用<code>gh [cli命令] -help</code>可以查询使用方法</p></li></ul><h3 id="gh-auth"><a href="#gh-auth" class="headerlink" title="gh auth"></a>gh auth</h3><blockquote><p>githubcli通过帮助您通过基于浏览器的<code>OAuth</code>登录GitHub或接受个人访问令牌,此交互式命令可初始化身份验证状态</p></blockquote><ul><li><p><code>-h,--hostname &lt;string&gt;</code>:要用于进行身份验证的 GitHub 实例的主机名</p></li><li><p><code>gh auth login</code>:授权githubcli登录这个账户</p></li><li><p><code>gh auth logout</code>:登出github</p></li><li><p><code>gh auth refresh</code>:刷新github账户</p></li><li><p><code>gh auth status</code>:查看githubcli登录状态</p><ul><li><code>-t</code>:显示身份验证令牌</li></ul></li></ul><h3 id="gh-ssh-key"><a href="#gh-ssh-key" class="headerlink" title="gh ssh-key"></a>gh ssh-key</h3><blockquote><p><code>gh ssh-key add [&lt;key-file&gt;] [flags]</code>:将 SSH 密钥添加到您的 GitHub 帐户</p></blockquote><ul><li><code>-t,--title &lt;string&gt;</code>:新密钥的标题</li></ul><blockquote><p><code>gh ssh-key list</code>:列出 GitHub 帐户中的 SSH 密钥</p></blockquote><h3 id="browse"><a href="#browse" class="headerlink" title="browse"></a>browse</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">gh browse <span class="token punctuation">[</span><span class="token operator">&lt;</span>number<span class="token operator">></span> <span class="token operator">|</span> <span class="token operator">&lt;</span>path<span class="token operator">></span><span class="token punctuation">]</span> <span class="token punctuation">[</span>flags<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><code>-b,--branch &lt;string&gt;</code>:选择其他分支打开浏览器</li><li><code>-c,--commit</code>:打开上次提交</li><li><code>-n,--no-browser</code>:打印目标URL,不打开浏览器</li><li><code>-p,--projects</code>:开放存储库项目</li><li><code>-R,--repo &lt;[HOST/]OWNER/REPO&gt;</code>:使用 [主机&#x2F;]所有者&#x2F;存储库格式选择另一个存储库</li><li><code>-s,--settings</code>:打开存储库设置</li><li><code>-w,--wiki</code>:开放存储库维基</li></ul><blockquote><p>如果想要打开其它存储库,需要使用<code>-R</code>.如果直接接url,<code>gh browse url</code>,如果是相对url会叠加到当前库的url中</p></blockquote><ul><li>正确的使用方法是:<code>gh browse -R Jack-Zhang-1314/JS_Webpack</code></li><li>并且以上的flags是可以叠加的</li></ul><h3 id="codespace-代码空间"><a href="#codespace-代码空间" class="headerlink" title="codespace(代码空间)"></a><a href="https://docs.github.com/en/codespaces/getting-started/quickstart">codespace(代码空间)</a></h3><blockquote><p>代码空间是浏览器中的集成开发环境(IDE).代码空间包括为特定仓库开发所需的一切,其中包括具有语法突出显示和自动完成功能的文本编辑器,终端,调试工具和Git命令,所有这些都集成在GitHub中.您也可以在代码空间中安装<code>Visual Studio Code</code>扩展以添加更多功能.</p></blockquote><ul><li>代码空间使开发人员更容易加入新公司或开始为开源项目做出贡献. 项目维护员可以配置仓库,以便在为仓库创建代码空间时自动包含项目的依赖项. 减少配置环境所用的时间,可以更快地开始编码.</li><li>代码空间允许您在云端开发,而不是本地开发. 开发者可以随时随地任何机器(包括平板电脑或 Chromebooks)上参与项目开发,无需维护知识产权的本地副本.</li></ul><blockquote><p>目前代码空间只有付费的组织才可以使用.个人和自由组织暂时都不能使用</p></blockquote><h3 id="gh-config"><a href="#gh-config" class="headerlink" title="gh config"></a>gh config</h3><ul><li><code>gh config get &lt;key&gt; [flags]</code>:输出指定配置的键<ul><li><code>-h,--host &lt;string&gt;</code>获取主机设置</li></ul></li><li><code>gh config list</code>:输出所有的配置</li><li><code>gh config set &lt;key&gt; &lt;value&gt; [flags]</code>:使用给定键的值设置配置<ul><li><code>-h,--host &lt;string&gt;</code>获取主机设置</li></ul></li></ul><h3 id="Gist"><a href="#Gist" class="headerlink" title="Gist"></a><a href="https://gist.github.com/">Gist</a></h3><blockquote><p>GitHub有一个隐藏得很好的衍生产品github Gist.这是一种更快,更简单的在线共享代码的方式.与Pastebin一样,Gist是一个通过互联网共享文本的工具.但它提供了额外的功能,并且特别得到了Git强大的版本控制的支持</p></blockquote><ul><li><p><code>gh gist clone &lt;gist&gt; [&lt;directory&gt;] [-- &lt;gitflags&gt;...]</code>:克隆gist</p><ul><li>例如<code>gh gist clone git@gist.github.com:ea351c91acc4f4b0395c6e6241b866bf.git</code></li></ul></li><li><p><code>gh gist create [&lt;filename&gt;... | -] [flags]</code>:创建一个gist</p><ul><li><code>-d,--desc &lt;string&gt;</code>:gist的说明</li><li><code>-f,--filename &lt;string&gt;</code>:创建gist时传入的文件</li><li><code>-p,--public</code>:使gist公开,默认是机密的</li><li><code>-w,--web</code>:创建gist并打开Web浏览器</li><li>例如<code>gh gist create test.md -p -w</code></li></ul></li><li><p><code>gh gist list [flags]</code>:获取自己的gist</p><ul><li><code>-L,--limit &lt;int&gt;</code>:要获取的最大数量</li><li><code>--public</code>:仅显示公共gist</li><li><code>--secret</code>:仅显示秘密的gist</li></ul></li><li><p><code>gh gist delete &#123;&lt;id&gt; | &lt;url&gt;&#125;</code>:删除gist</p></li><li><p><code>gh gist edit &#123;&lt;id&gt; | &lt;url&gt;&#125; [&lt;filename&gt;] [flags]</code>:编辑gist</p><ul><li><code>-a,--add &lt;string&gt;</code>:将新文件添加到gist</li><li><code>-d,--desc &lt;string&gt;</code>:gist的新描述</li><li><code>-f,--filename &lt;string&gt;</code>:选择要编辑的文件</li><li>例如:<code>gh gist edit ea351c91acc4f4b0395c6e6241b866bf -f test.md</code></li></ul></li><li><p><code>gh gist view [&lt;id&gt; | &lt;url&gt;] [flags]</code>:显示gist</p><ul><li><code>-f,--filename &lt;string&gt;</code>:显示gist中的单个文件</li><li><code>--files</code>:从gist中列出文件名,不显示其他内容  </li><li><code>-r,--raw</code>:打印原始内容而不是渲染之后的gist(例如md)</li><li><code>-w,--web</code>:在浏览器中打开要点</li><li>例如:<code>gh gist view ea351c91acc4f4b0395c6e6241b866bf --files</code></li></ul></li></ul><h3 id="gh-repo"><a href="#gh-repo" class="headerlink" title="gh repo"></a>gh repo</h3><blockquote><p><code>gh repo archive [&lt;repository&gt;] [flags]</code>存档仓库.<code>-y</code>跳过确认</p></blockquote><ul><li>存档仓库：您可以存档仓库，将其设为对所有用户只读，并且指出不再主动维护它。 您也可以取消存档已经存档的仓库。</li><li>在仓库存档后，便无法添加或删除协作者或团队。 具有仓库访问权限的贡献者只能对项目复刻或标星。</li><li>当仓库存档后，其议题、拉取请求、代码、标签、重要事件、项目、wiki、版本、提交、标记、分支、反应和注解都会变成只读。 要更改存档的仓库，必须先对仓库取消存档</li></ul><blockquote><p><code>gh repo clone &lt;repository&gt;</code>克隆仓库</p></blockquote><ul><li>在本地克隆 GitHub 存储库</li></ul><blockquote><p><code>gh repo create [&lt;name&gt;] [flags]</code>:创建存储库</p></blockquote><ul><li><code>-c,--clone</code>:将新存储库克隆到当前目录</li><li><code>-d,--description &lt;string&gt;</code>:存储库的描述</li><li><code>--private</code>:将新存储库设为私有</li><li><code>--public</code>:公开新存储库</li><li><code>--push</code>:将本地提交推送到新存储库</li><li><code>-r,--remote &lt;string&gt;</code>:指定新存储库的远程名称</li><li><code>-s,--source &lt;string&gt;</code>:指定要用作源的本地存储库的路径</li><li><code>-g,--gitignore &lt;string&gt;</code>:为存储库指定 gitignore 模板</li><li><code>-h,--homepage &lt;URL&gt;</code>:存储库主页网址</li><li><code>--disable-issues</code>:禁用新存储库中的问题</li><li><code>--disable-wiki</code>:在新存储库中禁用 wiki</li><li><code>--internal</code>:将新存储库设为内部存储库</li><li><code>-l,--license &lt;string&gt;</code>:为存储库指定开源许可证</li><li><code>-t,--team &lt;name&gt;</code>:要授予访问权限的组织团队的名称</li><li><code>-p,--template &lt;repository&gt;</code>基于模板存储库创建新存储库</li></ul><ol><li>使用交互的方式创建存储库<code>gh repo create</code></li><li>使用非交互的方式创建<ul><li>直接创建远程仓库<code>--public --private --internal --clone</code></li><li>将本地仓库推到新的远程仓库<code>--source--push</code></li></ul></li></ol><blockquote><p><code>gh repo list [&lt;owner&gt;] [flags]</code>列出用户或组织拥有的存储库</p></blockquote><ul><li><code>-l,--language &lt;string&gt;</code>:按主要编码语言筛选</li><li><code>-L,--limit &lt;int&gt;</code>:要列出的存储库的最大数量</li><li><code>--archived</code>:仅显示已存档的存储库</li><li><code>--no-archived</code>:省略已存档的存储库</li><li><code>--private</code>:仅显示私有仓库</li><li><code>--public</code>:仅显示公共存储库</li><li><code>--fork</code>:仅显示fork</li><li><code>--source</code>:仅显示非分叉</li><li><code>-q,--jq &lt;expression&gt;</code>:使用 jq 表达式筛选 JSON 输出</li><li><code>--json &lt;fields&gt;</code>:输出具有指定字段的 JSON</li><li><code>-t,--template &lt;string&gt;</code>:使用 Go 模板设置 JSON 输出的格式</li><li><code>--topic &lt;string&gt;</code>:按主题筛选</li></ul><blockquote><p><code>gh repo view [&lt;repository&gt;] [flags]</code>:显示 GitHub 存储库的描述和自述文件.如果没有参数,显示当前仓库的</p></blockquote><ul><li>[-b,–branch <string> | -q,–jq <expression> | -t,–template <string> | -w,–web]</li></ul><blockquote><p><code>gh repo deploy-key</code>,部署密钥</p></blockquote><ul><li><code>-R,--repo &lt;[HOST/]OWNER/REPO&gt;</code>:选择其它的仓库或者主机,使用者<ul><li><code>gh repo deploy-key add &lt;key-file&gt; [flags]</code>:增加密钥<ul><li><code>-w,--allow-write</code>:允许密钥的写入访问权限</li><li><code>-t,--title &lt;string&gt;</code>:新密钥的标题</li></ul></li><li><code>gh repo deploy-key delete &lt;key-id&gt;</code>:删除密钥</li><li><code>gh repo deploy-key list</code>:查看所有密钥</li></ul></li></ul><blockquote><p><code>gh repo delete [&lt;repository&gt;] [flags]</code>删除存储库</p></blockquote><ul><li><code>--confirm</code>,确认删除,不带提示</li></ul><blockquote><p><code>gh repo rename [&lt;new-name&gt;] [flags]</code>重新命名仓库名称</p></blockquote><ul><li>[-y,–confirm | -R,–repo &lt;[HOST&#x2F;]OWNER&#x2F;REPO&gt;]</li></ul><blockquote><p><code>gh repo edit [&lt;repository&gt;] [flags]</code>:编辑存储库</p></blockquote><ul><li><code>--add-topic &lt;strings&gt;</code>添加存储库主题</li><li><code>--remove-topic &lt;strings&gt;</code>:删除存储库主题</li><li><code>--visibility &lt;string&gt;</code>:将存储库的可见性更改为 {<code>public</code>、<code>private</code>、<code>internal</code>}</li><li><code>--allow-forking</code>允许fork组织存储库</li><li><code>--default-branch &lt;name&gt;</code>:设置存储库的默认分支名称</li><li><code>--delete-branch-on-merge</code>:合并拉取请求时删除头分支</li><li><code>-d,--description &lt;string&gt;</code>:存储库的描述</li><li><code>--enable-issues</code>:在存储库中启用问题</li><li><code>-h,--homepage &lt;URL&gt;</code>:设置存储库主页网址</li><li><code>--enable-auto-merge</code>:启用自动合并功能</li><li><code>--enable-merge-commit</code>:通过合并提交启用合并拉取请求</li><li><code>--enable-rebase-merge</code>:拉取请求存在合并冲突,会重新定位合并冲突</li><li><code>--enable-squash-merge</code>:拉取请求的提交将压缩到单个提交中</li><li><code>--enable-wiki</code>:在存储库中启用 wiki</li><li><code>--enable-projects</code>:在存储库中启用项目</li><li><code>--template</code>:使存储库可用作模板存储库</li></ul><blockquote><p><code>gh repo fork [&lt;repository&gt;] [-- &lt;gitflags&gt;...] [flags]</code>:创建存储库的分支</p></blockquote><ul><li><code>--clone</code>:克隆到本地 {true|false}</li><li><code>--fork-name &lt;string&gt;</code>:指定分叉存储库的名称</li><li><code>--org &lt;string&gt;</code>:在组织中创建分支</li><li><code>--remote</code>:为分叉添加远程 {true|false}</li><li><code>--remote-name &lt;string&gt;</code>:指定新的远程仓库名称</li></ul><h3 id="gh-issue"><a href="#gh-issue" class="headerlink" title="gh issue"></a>gh issue</h3><ul><li><code>-R,--repo &lt;[HOST/]OWNER/REPO&gt;</code>使用 [主机&#x2F;]所有者&#x2F;存储库格式选择另一个存储库</li></ul><blockquote><p><code>gh issue list [flags]</code>:列出和筛选此存储库中的问题</p></blockquote><ul><li><code>-a,--assignee &lt;string&gt;</code>:按回答问题的受让人(assignee)</li><li><code>-A,--author &lt;string&gt;</code>:按问题的作者筛选</li><li><code>-l,--label &lt;strings&gt;</code>:按标签筛选</li><li><code>-L,--limit &lt;int&gt;</code>:要获取的最大问题数</li><li><code>--mention &lt;string&gt;</code>:按提及筛选</li><li><code>-m,--milestone &lt;number&gt;</code>:按里程碑编号或”标题”筛选</li><li><code>-S,--search &lt;query&gt;</code>:查询的搜索问题</li><li><code>-s,--state &lt;string&gt;</code>:按状态筛选<code>&#123;open|closed|all&#125;</code></li><li>[-t,–template <string> | -q,–jq <expression> | –json <fields>]:输出格式</li><li><code>-w,--web</code>:打开浏览器以列出问题</li></ul><blockquote><p><code>gh issue view &#123;&lt;number&gt; | &lt;url&gt;&#125; [flags]</code>:显示有关问题的标题、正文和其他信息。</p></blockquote><ul><li><code>-c,--comments</code>:查看问题评论</li><li>[-q,–jq <expression>|–json <fields> |-t,–template <string>]:输出格式</li><li><code>-w,--web</code>:在浏览器中打开问题</li></ul><blockquote><p><code>gh issue create [flags]</code>创建新问题</p></blockquote><ul><li><code>-a,--assignee &lt;login&gt;</code>:通过登录名分配人员。使用”@me”进行自我分配。</li><li><code>-b,--body &lt;string&gt;</code>:提供问题的内容。否则将提示一个。</li><li><code>-F,--body-file &lt;file&gt;</code>:从文件中读取正文文本（使用”-“从标准输入读取）</li><li><code>-l,--label &lt;name&gt;</code>:按名称添加标签</li><li><code>-m,--milestone &lt;name&gt;</code>:按名称将问题添加到里程碑</li><li><code>-p,--project &lt;name&gt;</code>:按名称将问题添加到项目</li><li><code>--recover &lt;string&gt;</code>:从失败的创建运行中恢复输入</li><li><code>-t,--title &lt;string&gt;</code>:提供标题。否则将提示一个。</li><li><code>-w,--web</code>:打开浏览器以创建问题</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">gh issue create -t <span class="token string">"测试"</span> -b <span class="token string">"问题的内容"</span> -a <span class="token string">"@me"</span> -w<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>将标题设置为测试,添加内容,受让人是我自己,在浏览器打开</li></ul><blockquote><p><code>gh issue edit &#123;&lt;number&gt; | &lt;url&gt;&#125; [flags]</code>:编辑问题</p></blockquote><ul><li><code>[-t | -b | -F | -m]</code>:与create一样</li><li><code>--add-assignee &lt;login&gt;</code>:通过登录名添加分配的用户。使用”@me”来分配自己。</li><li><code>--add-label &lt;name&gt;</code>:按名称添加标签</li><li><code>--add-project &lt;name&gt;</code>按名称将问题添加到项目</li><li><code>--remove-assignee &lt;login&gt;</code>:通过登录名删除分配的用户。使用”@me”取消分配自己。</li><li><code>--remove-label &lt;name&gt;</code>:按名称删除标签</li><li><code>--remove-project &lt;name&gt;</code>:按名称从项目中删除问题</li></ul><blockquote><p><code>gh issue delete &#123;&lt;number&gt; | &lt;url&gt;&#125;</code>删除问题</p><p><code>gh issue close &#123;&lt;number&gt; | &lt;url&gt;&#125;</code>关闭问题</p><p><code>gh issue reopen &#123;&lt;number&gt; | &lt;url&gt;&#125;</code>:重新打开问题</p></blockquote><p>…</p><blockquote><p><code>gh issue comment &#123;&lt;number&gt; | &lt;url&gt;&#125; [flags]</code>创建新问题评论</p></blockquote><ul><li><code>-b,--body &lt;string&gt;</code>提供正文。否则将提示一个。</li><li><code>-F,--body-file &lt;file&gt;</code>:从文件中读取正文文本（使用”-“从标准输入读取）</li><li><code>-e,--editor</code>:使用编辑器添加正文</li><li><code>-w,--web</code>:在浏览器中添加正文</li></ul><blockquote><p><code>gh issue status [flags]</code>:问题状态</p></blockquote><ul><li>[-t,–template <string> | -q,–jq <expression> | –json <fields>]:输出格式</li></ul><blockquote><p><code>gh issue transfer &#123;&lt;number&gt; | &lt;url&gt;&#125; &lt;destination-repo&gt;</code>将问题转到另一个库</p></blockquote><h3 id="gh-pr"><a href="#gh-pr" class="headerlink" title="gh pr"></a>gh pr</h3><ul><li><code>-R,--repo &lt;[HOST/]OWNER/REPO&gt;</code>使用 [主机&#x2F;]所有者&#x2F;存储库格式选择另一个存储库</li></ul><blockquote><p>gh pr list [flags]</p></blockquote><ul><li><code>[-a | -A | -L | -l | -S | -s | --json | -q | -t | -w]</code>查看issue</li><li><code>-B,--base &lt;string&gt;</code>:按基本分支筛选</li><li><code>-d,--draft</code>:按草稿状态筛选</li><li><code>-H,--head &lt;string&gt;</code>:按头分支筛选</li></ul><blockquote><p><code>gh pr view [&lt;number&gt; | &lt;url&gt; | &lt;branch&gt;] [flags]</code>:显示有关拉取请求的标题、正文和其他信息</p></blockquote><ul><li><code>[ --json | -q | -t ]</code>:输出格式</li><li><code>-c,--comments</code>:查看拉取请求注释</li></ul><blockquote><p><code>gh pr status [flags]</code>:查看拉取请求的状态</p></blockquote><ul><li><code>[ --json | -q | -t ]</code>:输出格式</li></ul><blockquote><p><code>gh pr close &#123;&lt;number&gt; | &lt;url&gt; | &lt;branch&gt;&#125; [flags]</code>:关闭pr</p></blockquote><ul><li><code>-d,--delete-branch</code>:关闭后删除本地和远程分支</li></ul><blockquote><p><code>gh pr reopen &#123;&lt;number&gt; | &lt;url&gt; | &lt;branch&gt;&#125;</code>:重新打开和拉取请求</p></blockquote><p>…</p><blockquote><p><code>gh pr checkout &#123;&lt;number&gt; | &lt;url&gt; | &lt;branch&gt;&#125; [flags]</code>:在git中拉取请求到本地</p></blockquote><ul><li><code>-b,--branch &lt;string&gt;</code>:远程分支要使用的本地分支名称(默认是主分支)</li></ul><blockquote><p><code>gh pr review [&lt;number&gt; | &lt;url&gt; | &lt;branch&gt;] [flags]</code>:审阅当前的拉取请求</p></blockquote><ul><li><code>-a,--approve</code>:批准拉取请求</li><li><code>-b,--body &lt;string&gt;</code>:指定审阅的正文</li><li><code>-F,--body-file &lt;file&gt;</code>:从文件中读取正文文本</li><li><code>-c,--comment</code>:对拉取请求发表评论</li><li><code>-r,--request-changes</code>:请求对拉取请求进行更改</li></ul><blockquote><p><code>gh pr comment [&lt;number&gt; | &lt;url&gt; | &lt;branch&gt;] [flags]</code>:创建新的 PR 注释(评论)</p></blockquote><ul><li><code>-b,--body &lt;string&gt;</code>:提供正文。否则将提示一个。</li><li><code>-F,--body-file &lt;file&gt;</code>:从文件中读取正文文本（使用”-“从标准输入读取）</li><li><code>-e,--editor</code>:使用编辑器添加正文</li><li><code>-w,--web</code>:打开浏览器</li></ul><blockquote><p><code>gh pr ready [&lt;number&gt; | &lt;url&gt; | &lt;branch&gt;]</code>:将拉取请求标记为已就绪(可供审核)</p></blockquote><p>…</p><blockquote><p><code>gh pr merge [&lt;number&gt; | &lt;url&gt; | &lt;branch&gt;] [flags]</code>:在 GitHub 上合并拉取请求</p></blockquote><ul><li><code>--admin</code>:使用管理员权限合并不符合要求的拉取请求</li><li><code>--auto</code>:仅在满足必要要求后自动合并</li><li><code>-b,--body &lt;text&gt;</code>:合并提交的正文文本</li><li><code>-F,--body-file &lt;file&gt;</code>:从文件中读取正文文本（使用”-“从标准输入读取）</li><li><code>-d,--delete-branch</code>:合并后删除本地和远程分支</li><li><code>--disable-auto</code>:禁用此拉取请求的自动合并</li><li><code>-m,--merge</code>:将提交与基本分支合并</li><li><code>-r,--rebase</code>:将提交重新定位到基础分支</li><li><code>-s,--squash</code>:将提交压缩到一个提交中，然后将其合并到基础分支中</li><li><code>-t,--subject &lt;text&gt;</code>:合并提交的主题文本</li></ul><blockquote><p><code>gh pr create [flags]</code>:创建一个pr</p></blockquote><ul><li><p>[-a | -b | -F | -l | -m | -P | -t | -w]</p></li><li><p><code>-B,--base &lt;branch&gt;</code>:要将代码合并到其中的分支</p></li><li><p><code>-d,--draft</code>:将拉取请求标记为草稿</p></li><li><p><code>-f,--fill</code>:不要提示标题&#x2F;正文，只使用提交信息</p></li><li><p><code>-H,--head &lt;branch&gt;</code>:包含拉取请求提交的分支（默认值：当前分支）</p></li><li><p><code>--no-maintainer-edit</code>:禁用维护者修改拉取请求的功能</p></li><li><p><code>--recover &lt;string&gt;</code>:从失败的创建运行中恢复输入</p></li><li><p><code>-r,--reviewer &lt;handle&gt;</code>:按句柄请求人员或团队进行审核</p></li></ul><blockquote><p><code>gh pr diff [&lt;number&gt; | &lt;url&gt; | &lt;branch&gt;] [flags]</code></p></blockquote><p><code>--color &lt;string&gt;</code>:在差异输出中使用颜色：{always|never|auto}<br><code>--patch</code>:以补丁格式显示差异</p><blockquote><p><code>gh pr edit [&lt;number&gt; | &lt;url&gt; | &lt;branch&gt;] [flags]</code>:编辑拉取请求。</p></blockquote><p>–add-assignee <login>| –remove-assignee <login> | –add-label <name> | –remove-label <name> | –add-reviewer <login> | –remove-reviewer <login> | –add-project <name> | –remove-project <name> | -b,–body <string> | -F,–body-file <file> | -m,–milestone <name> | -t,–title <string></p><ul><li><code>-B,--base &lt;branch&gt;</code>:更改此拉取请求的基本分支</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;githubCli&quot;&gt;&lt;a href=&quot;#githubCli&quot; class=&quot;headerlink&quot; title=&quot;githubCli&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://cli.github.com/&quot;&gt;githubCli&lt;/a&gt;&lt;/h2&gt;&lt;blockq</summary>
      
    
    
    
    <category term="git" scheme="http://mail.zyjcould.ltd/categories/git/"/>
    
    
    <category term="git" scheme="http://mail.zyjcould.ltd/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>nuxt</title>
    <link href="http://mail.zyjcould.ltd/2022/02/12/nuxt/"/>
    <id>http://mail.zyjcould.ltd/2022/02/12/nuxt/</id>
    <published>2022-02-12T09:21:52.000Z</published>
    <updated>2022-03-19T08:12:04.902Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><code>npx nuxi init nuxt-app</code>:首先得初始化一个nuxt3的项目</p></blockquote><h2 id="pages"><a href="#pages" class="headerlink" title="pages"></a>pages</h2><blockquote><p>Nuxt 会自动将 <code>Vue Router</code> 和 <code>map</code> 目录集成到应用程序的路由中(pages)</p></blockquote><ol><li>&lt;NuxtWelcome&gt;:nuxt的欢迎页面</li><li>&lt;NuxtPage&gt;:展示页面,相当于&lt;router-view&gt;</li><li>&lt;NuxtLink&gt;:导航链接,相当于&lt;router-link&gt;</li><li>&lt;NuxtChild&gt;:嵌套路由中显示子组件</li></ol><blockquote><p>动态路由:在pages中使用<code>[]</code>表示动态的路由</p></blockquote><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">-<span class="token operator">|</span> pages/---<span class="token operator">|</span> index.vue---<span class="token operator">|</span> users-<span class="token punctuation">[</span>group<span class="token punctuation">]</span>/-----<span class="token operator">|</span> <span class="token punctuation">[</span>id<span class="token punctuation">]</span>.vue<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li>在<code>index.vue</code>中,写入动态部分</li></ul><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;NuxtLink to&#x3D;&quot;&#x2F;user-admin&#x2F;1&quot;&gt;user-admin&#x2F;1&lt;&#x2F;NuxtLink&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>在全局也可以拿到动态路由数据</li></ul><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;p&gt;&#123;&#123; $route.params.group &#125;&#125;&lt;&#x2F;p&gt;&lt;p&gt;&#123;&#123; $route.params.id &#125;&#125;&lt;&#x2F;p&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>在script中使用<code>useRoute()</code>函数也可以拿到动态路由的值</li></ul><blockquote><p>嵌套路由:由嵌套多个层深的组件组成(其中嵌套的文件夹parent同级下需要一个<code>parent.vue</code>)</p></blockquote><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">-<span class="token operator">|</span> pages/---<span class="token operator">|</span> parent/------<span class="token operator">|</span> child.vue---<span class="token operator">|</span> parent.vue<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li>在<code>parent.vue</code>中使用&lt;NuxtChild&#x2F;&gt;显示<code>child.vue</code>中的内容</li></ul><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;template&gt;  &lt;div&gt;    &lt;h1&gt;parent&lt;&#x2F;h1&gt;    &lt;NuxtChild &#x2F;&gt;  &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>依然需要在<code>index.vue</code>中使用路由链接</li></ul><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;NuxtLink to&#x3D;&quot;&#x2F;parent&#x2F;child&quot;&gt;parent&lt;&#x2F;NuxtLink&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="布局-layouts"><a href="#布局-layouts" class="headerlink" title="布局(layouts)"></a>布局(layouts)</h2><blockquote><p>在nuxt中自定义的布局框架,可以在整个应用程序中使用.可以将重读的UI提取到这个此文件中</p></blockquote><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">-<span class="token operator">|</span> layouts/---<span class="token operator">|</span> default.vue<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>使用<code>default.vue</code>用于应用中的所有页面除了(app.vue).<code>app.vue</code>依然会是所有页面的入口</li></ul><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;div&gt;  &lt;h1&gt;默认布局&lt;&#x2F;h1&gt;  &lt;slot&gt;&lt;&#x2F;slot&gt;&lt;&#x2F;div&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>自定义布局:如果不想在所有页面设置属性,就需要在某个页面设置属性(<code>layout</code>).并且不能使用<code>default.vue</code>,而应该使用别的,例如<code>custom.vue</code>.</p></blockquote><ul><li>例如我们自定义一个<code>custom.vue</code>之后就可以在有需要的页面使用</li></ul><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">definePageMeta(&#123;  layout: &#39;custom&#39;,&#125;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p>使用插槽:可以对页面进行完全的控制.需要使用&lt;NuxtLayout&gt;并且<code>layout:false</code></p></blockquote><ul><li>需要使用的<code>layout</code>的页面(类似于父页面)</li></ul><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;template&gt;  hhh  &lt;NuxtLayout name&#x3D;&quot;custom&quot;&gt;    &lt;template #header&gt;      &lt;h1&gt;这不好吧&lt;&#x2F;h1&gt;    &lt;&#x2F;template&gt;  &lt;&#x2F;NuxtLayout&gt;&lt;&#x2F;template&gt;&lt;script setup lang&#x3D;&quot;ts&quot;&gt;definePageMeta(&#123;  layout: false,&#125;);&lt;&#x2F;script&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>layout</code>的插槽页面<code>custom</code>(类似于子页面)</li></ul><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;template&gt;  &lt;div&gt;    &lt;h1&gt;特殊的页面&lt;&#x2F;h1&gt;    &lt;slot name&#x3D;&quot;header&quot;&gt;&lt;&#x2F;slot&gt;  &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="组件-components"><a href="#组件-components" class="headerlink" title="组件(components)"></a>组件(components)</h2><blockquote><p>放在该目录的所有组件可以直接将器导入其它页面或者组件中</p></blockquote><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token operator">|</span> components/--<span class="token operator">|</span> TheHeader.vue<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;template&gt;  &lt;TheHeader&gt;&lt;&#x2F;TheHeader&gt;&lt;&#x2F;template&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p>如果是嵌套目录,那么组件的名称需要加入文件名称</p></blockquote><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">-<span class="token operator">|</span> components/---<span class="token operator">|</span> test/-----<span class="token operator">|</span> hao.vue<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&#96;&#96;&#96;vue&lt;template&gt;  &lt;TheHeader&gt;&lt;&#x2F;TheHeader&gt;&lt;&#x2F;template&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li>不需要在<code>script</code>中使用import导入,直接可以使用</li></ul><blockquote><p>懒加载:将将前缀(<code>Lazy&#39;</code>)添加到组件的名称中.例如<code>&lt;LazyTheHeader&gt;</code></p></blockquote><h2 id="获取数据"><a href="#获取数据" class="headerlink" title="获取数据"></a>获取数据</h2><blockquote><p><code>useFetch</code>,<code>useLazyFetch</code>,<code>useAsyncData</code>,<code>useLazyAsyncData</code>仅在生命周期或者setup中可以使用</p></blockquote><h3 id="server"><a href="#server" class="headerlink" title="server"></a>server</h3><blockquote><p>在nuxt项目的根目录,nuxt会自动读取<code>server/api</code>下文件的promise或者JSON数据(后端服务器)</p></blockquote><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">const todos &#x3D; [  &#123; id: 1, title: &#39;nuxt3&#39;, completed: false &#125;,  &#123; id: 2, title: &#39;vue3&#39;, completed: true &#125;,]export default () &#x3D;&gt; todos<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="useAsyncData"><a href="#useAsyncData" class="headerlink" title="useAsyncData"></a>useAsyncData</h3><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">const &#123;  data: Ref&lt;DataT&gt;,  pending: Ref&lt;boolean&gt;,  refresh: (force?: boolean) &#x3D;&gt; Promise&lt;void&gt;,  error?: any&#125; &#x3D; useAsyncData(  key: string,  fn: () &#x3D;&gt; Object,  options?: &#123; lazy: boolean, server: boolean &#125;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>函数参数</p></blockquote><ol><li><code>key</code>:保证请求数据不会重复</li><li><code>fn</code>:返回值的异步函数</li><li><code>options</code>:<ol><li><code>lazy</code>:是否在加载路由后解析异步函数，而不是阻塞导航(默认为false,卡顿现象)</li><li><code>default()</code>:一个工厂函数，用于在异步函数解析之前设置数据的默认值 (配合<code>lazy:true</code>)</li><li><code>server</code>:是否在服务器端获取数据(默认为true),用户可以直接浏览到页面</li><li><code>transform()</code>:一个函数，可用于在解析后改变fn结果</li><li><code>pick</code>:仅从 fn 结果中选取此数组中的指定键.<span style="color:red">只能适用于对象</span></li></ol></li></ol><blockquote><p>返回值</p></blockquote><ol><li><code>data</code>:传入的异步函数的结果</li><li><code>pending</code>:指示数据是否仍在提取(配合<code>lazy:true</code>,可以写一些加载提示器)</li><li><code>refresh</code>:可用于强制刷新数据的函数</li><li><code>error</code>:错误对象</li></ol><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">const &#123; data: todos &#125; &#x3D; await useAsyncData(&#39;todos&#39;, () &#x3D;&gt; $fetch(&#39;&#x2F;api&#x2F;todo&#39;));<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="useLazyAsyncData"><a href="#useLazyAsyncData" class="headerlink" title="useLazyAsyncData"></a>useLazyAsyncData</h3><blockquote><p>此方法仅是将<code>useAsyncData</code>中的<code>lazy</code>设置为true(异步函数不会阻止导航).这得考虑data为null的情况(或者使用<code>default</code>给data设置一个默认值)</p></blockquote><h3 id="useFetch"><a href="#useFetch" class="headerlink" title="useFetch"></a>useFetch</h3><blockquote><p><code>useFetch</code>是对<code>useAsyncData</code>的包装,自动生成key同时推断响应类型</p></blockquote><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">const &#123;  data: Ref&lt;DataT&gt;,  pending: Ref&lt;boolean&gt;,  refresh: (force?: boolean) &#x3D;&gt; Promise&lt;void&gt;,  error?: any&#125; &#x3D; useFetch(url: string, options?)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>Options:<ol><li><a href="https://github.com/unjs/ohmyfetch"><code>ohmyfetch</code></a><ul><li><code>method</code>:请求方法</li><li><code>params</code>:查询参数</li><li><code>headers</code>:请求标头</li><li><code>baseURL</code>:请求的基本 URL</li></ul></li><li><code>useAsyncData</code>中的也可以使用</li></ol></li></ul><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">const &#123; data: todos &#125; &#x3D; await useFetch(&#39;&#x2F;api&#x2F;todo&#39;,&#123;pick:[&quot;data&quot;],transform(input)&#123;   return input&#125;&#125;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="状态共享"><a href="#状态共享" class="headerlink" title="状态共享"></a>状态共享</h2><blockquote><p>一般在<code>composables</code>中创建<code>useState()</code></p></blockquote><h3 id="composables"><a href="#composables" class="headerlink" title="composables"></a>composables</h3><blockquote><p>只有目录顶层的文件(或任何子目录中的索引文件)才会被认定为可组合的文件</p></blockquote><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">composables <span class="token operator">|</span> - useFoo.ts <span class="token operator">|</span> - useBar <span class="token operator">|</span> --- supportingFile.ts <span class="token operator">|</span> --- index.ts<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>可以直接在该目录下使用useState状态管理(不需要任何导入)</li></ul><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">export const useCounter &#x3D; () &#x3D;&gt; useState(&#39;counter&#39;, () &#x3D;&gt; 0);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>在组件中使用,不需要任何导入</li></ul><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">const counter &#x3D; useCounter()<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="插件-plugins"><a href="#插件-plugins" class="headerlink" title="插件(plugins)"></a>插件(plugins)</h2><blockquote><p>可以使用文件名或后缀来仅在服务器端(<code>.server</code>)或客户端(<code>client</code>)加载插件.</p></blockquote><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">plugins <span class="token operator">|</span> - myPlugin.ts <span class="token operator">|</span> - myOtherPlugin <span class="token operator">|</span> --- supportingFile.ts <span class="token operator">|</span> --- componentToRegister.vue <span class="token operator">|</span> --- index.ts<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>创建一个简单的插件</p></blockquote><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">import &#123; defineNuxtPlugin &#125; from &#39;#app&#39;;export default defineNuxtPlugin((nuxtApp) &#x3D;&gt; &#123;  return &#123;    provide: &#123;      hello: () &#x3D;&gt; &#39;world&#39;,    &#125;,  &#125;;&#125;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>导入插件时会自动加上<code>$</code>符号区分</p></blockquote><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">const &#123; $hello &#125; &#x3D; useNuxtApp();console.log($hello());<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="按需引入组件库"><a href="#按需引入组件库" class="headerlink" title="按需引入组件库"></a>按需引入组件库</h3><blockquote><p>全局挂载组件<code>nuxtApp.vueApp.use</code></p></blockquote><ul><li><code>npm i vue-devui</code></li></ul><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">import &#123; defineNuxtPlugin &#125; from &#39;#app&#39;;import &#123; Button &#125; from &#39;vue-devui&#39;;import &#39;vue-devui&#x2F;button&#x2F;style.css&#39;;export default defineNuxtPlugin((nuxtApp) &#x3D;&gt; &#123;  nuxtApp.vueApp.use(Button);&#125;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="pinia"><a href="#pinia" class="headerlink" title="pinia"></a><a href="https://pinia.vuejs.org/ssr/nuxt.html">pinia</a></h2><ul><li>下载:<code>npm install pinia @pinia/nuxt</code></li><li>在<code>nuxt.config.ts</code>中添加模块,如果不想使用vuex可以将<code>disableVuex</code>改成false</li></ul><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">buildModules: [[&#39;@pinia&#x2F;nuxt&#39;, &#123; disableVuex: true &#125;]]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>在根目录下新建<code>store/counter.ts</code>就可以使用了</li></ul><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">import &#123; defineStore &#125; from &#39;pinia&#39;;export const useStore &#x3D; defineStore(&#39;counter&#39;, &#123;  state() &#123;    return &#123;      count: 0,    &#125;;  &#125;,&#125;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;npx nuxi init nuxt-app&lt;/code&gt;:首先得初始化一个nuxt3的项目&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;pages&quot;&gt;&lt;a href=&quot;#pages&quot; class=&quot;headerlink&quot; ti</summary>
      
    
    
    
    <category term="vue" scheme="http://mail.zyjcould.ltd/categories/vue/"/>
    
    
    <category term="JS" scheme="http://mail.zyjcould.ltd/tags/JS/"/>
    
    <category term="TS" scheme="http://mail.zyjcould.ltd/tags/TS/"/>
    
    <category term="vue" scheme="http://mail.zyjcould.ltd/tags/vue/"/>
    
  </entry>
  
</feed>
