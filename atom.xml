<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>苍穹之下</title>
  
  <subtitle>a little blog</subtitle>
  <link href="http://mail.zyjcould.ltd/atom.xml" rel="self"/>
  
  <link href="http://mail.zyjcould.ltd/"/>
  <updated>2022-05-15T14:35:54.086Z</updated>
  <id>http://mail.zyjcould.ltd/</id>
  
  <author>
    <name>Jack-zhang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>stream-api</title>
    <link href="http://mail.zyjcould.ltd/2022/05/14/stream-api/"/>
    <id>http://mail.zyjcould.ltd/2022/05/14/stream-api/</id>
    <published>2022-05-14T14:14:07.000Z</published>
    <updated>2022-05-15T14:35:54.086Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h2><blockquote><p>stream 的种类</p></blockquote><ul><li><code>Readable Stream</code> 可读数据流</li><li><code>Writeable Stream</code> 可写数据流</li><li><code>Duplex Stream</code> 双向数据流,可以同时读和写</li><li><code>Transform Stream</code>转换数据流,可读可写,同时可以转换&#x2F;处理数据(不常用)</li></ul><blockquote><p>Buffer:<code>Writeable</code>和<code>Readable</code>流都将数据存储在内部缓冲区中</p></blockquote><ul><li>内部缓冲的数据屈居于传给流的构造函数<code>highWaterMark</code>选项.对于普通的流,<code>highWaterMark</code>选项指定字节的总数,对于在对象模式下操作的流<code>highWaterMark</code>指定对象的总数</li><li>当实现调用<code>stream.push(chunk)</code>时,数据缓存在Readable流中.如果流的消费者没有调用<code>stream.read()</code>,则数据会一直留在内部队列,直到被消费</li><li>当内部读取缓冲区的总大小达到<code>highWaterMark</code>指定的阈值,则流将暂时停止从底层资源读取数据,直到可以消费当前缓冲区的数据(流将停止调用内部用于填充读取缓冲区的<code>readable._read()</code>)</li><li>当重复调用<code>writeable.write(chunk)</code>方法时,数据会缓存在<code>Writeable</code>中.虽然内部的写入缓冲区的总大小低于<code>highWaterMark</code>设置的阈值,淡对<code>writeable.write()</code>的调用将返回true.一旦内部缓冲区的大小达到活着超过<code>highWaterMark</code>,则返回false</li><li><code>stream API</code>的一个关键目标,尤其是<code>stream.pipe()</code>方法,是将数据缓冲限制在可接受的水平,以便不同速度的来源和目标不会压倒可用内存</li><li><code>highWaterMark</code>选项是阈值,而不是限制:它规定了流在停止请求更多数据之前缓冲的数据量.<ul><li>它通常不强制执行严格的内存限制.特定的流实现可能会选择实施更严格的限制,但这样做是可选的.</li></ul></li><li><code>Duplex</code> 和 <code>Transform</code> 流都是 <code>Readable</code> 和 <code>Writable</code>,因此每个流都维护两个独立的内部缓冲区,用于读取和写入,允许每一端独立操作,同时保持适当且高效的数据流.<ul><li>例如<code>net.Socket</code>实例是<code>Duplex</code>流,其<code>Readable</code>端允许消费从套接字接收的数据,其<code>Writable</code>端允许将数据写入套接字因为数据可能以比接收数据更快或更慢的速度写入套接字,所以每一端都应该独立于另一端进行操作.</li></ul></li></ul><h3 id="Writable-Streams"><a href="#Writable-Streams" class="headerlink" title="Writable Streams"></a>Writable Streams</h3><ul><li>TTP requests, on the client</li><li>HTTP responses, on the server</li><li>fs write streams</li><li>zlib streams</li><li>crypto streams</li><li>TCP sockets</li><li>child process stdin</li><li>process.stdout, process.stderr</li></ul><blockquote><p>事件</p></blockquote><ol><li><code>close</code>:当流以及底层资源(例如文件描述符)已关闭时,则会触发<code>close</code>事件.表明该事件不会再触发更多事件<ul><li>如果使用<code>writable</code>流是使用<code>emitClose</code>选项创建的,则会触发close事件</li></ul></li><li><code>drain</code>:如果对<code>stream.write(chunk)</code>的调用返回false,则<code>drain</code>事件将在适合继续将数据写入流是触发</li><li><code>error</code>:当数据再写入或者管道数据法伤错误,则会触发<code>error</code>事件.监听器回调再调用时传入单个Error参数<ul><li>除非在创建流时将 <code>autoDestroy</code> 选项设置为 <code>false</code>,否则当触发 <code>&#39;error&#39;</code> 事件时将关闭流</li></ul></li><li><code>finish</code>:在调用<code>stream.end()</code>方法之后,并且所有的数据都已刷新到底层系统,则触发<code>finish</code>中</li><li><code>pipe</code>:当在可读流上调用<code>stream.pipe()</code>方法将此可写流添加到其目标集时,则触发<code>pipe</code>事件</li><li><code>unpipe</code>:当在<code>Readable</code>流上调用<code>stream.unpipe()</code>方法时,则会触发<code>unpipe</code>事件,从其目标集合中删除此<code>Writable</code></li></ol><blockquote><p>方法</p></blockquote><ol><li><p><code>writable.cork()</code></p><ul><li><code>writable.cork()</code>方法强制所有写入的数据都缓存在内存中.当调用<code>stream.uncork()</code>或<code>stream.end()</code>方法时,缓冲的数据将被刷新</li><li><code>writable.cork()</code>的主要目的是适应将几个小块快速连续写入流的情况.<code>writable.cork()</code>不是立即将它们转发到底层目标,而是缓冲所有块,直到<code>writable.uncork()</code>被调用,如果存在<code>writable.uncork()</code>会将它们全部传给<code>writable._writev()</code>. 这可以防止在等待处理第一个小块时正在缓冲数据的行头阻塞情况.但是,在不实现<code>writable._writev()</code>的情况下使用<code>writable.cork()</code>可能会对吞吐量产生不利影响</li></ul></li><li><p><code>writable.destroy([error])</code></p><ul><li><strong>销毁stream</strong>.可选地触发 <code>&#39;error&#39;</code> 事件,并且触发 <code>&#39;close&#39;</code> 事件(除非 emitClose 设置为 false).</li><li>在此调用之后,则可写流已结束,随后对<code>write()</code>或<code>end()</code>的调用将导致 <code>ERR_STREAM_DESTROYED</code> 错误.</li><li>这是销毁流的破坏性和直接的方式.先前对 <code>write()</code> 的调用可能没有排空,并且可能触发<code>ERR_STREAM_DESTROYED</code>错误.</li><li>如果数据应该在关闭之前刷新,或者在销毁流之前等待 <code>&#39;drain&#39;</code> 事件,则使用<code>end()</code>而不是<code>destroy</code></li></ul></li><li><p><code>writable.end([chunk[, encoding]][, callback])</code></p><ul><li>参数<ul><li><code>chunk</code> &lt;string&gt; | &lt;Buffer&gt; | &lt;Uint8Array&gt; | &lt;any&gt; 可选的要写入的数据.对于不在对象模式下操作的流,<code>chunk</code>必须是<strong>字符串</strong>,<strong>Buffer</strong>或<strong>Uint8Array</strong>.对于对象模式的流,chunk可以是除null之外的任何JavaScript值</li><li><code>encoding</code>: &lt;string&gt;, chunk为字符串时的编码</li><li><code>callback</code>:&lt;Function&gt;, 流结束时的回调</li></ul></li><li>返回: &lt;this&gt;</li><li>调用 <code>writable.end()</code> 方法表示不再有数据写入<code>Writable</code>可选的<code>chunk</code>和<code>encoding</code> 参数允许在关闭流之前立即写入最后一个额外的数据块.在调用 <code>stream.end()</code> 之后调用 <code>stream.write()</code> 方法将引发错误</li></ul></li><li><p><code>writable.setDefaultEncoding(encoding)</code></p><ul><li><code>writable.setDefaultEncoding()</code> 方法为<code>Writable</code>流设置默认的<code>encoding</code></li></ul></li><li><p><code>writable.uncork()</code></p><ul><li><p><code>writable.uncork()</code>方法会刷新自调用<code>stream.cork()</code>以来缓冲的所有数据</p></li><li><p>当使用<code>writable.cork()</code>和<code>writable.uncork()</code>管理写入流的缓冲时,使用 <code>process.nextTick()</code> 推迟对 <code>writable.uncork()</code>的调用. 这样做允许对在给定 Node.js 事件循环阶段中发生的所有 <code>writable.write()</code> 调用进行批处理</p> <pre class="line-numbers language-js" data-language="js"><code class="language-js">stream<span class="token punctuation">.</span><span class="token function">cork</span><span class="token punctuation">(</span><span class="token punctuation">)</span>stream<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token string">'some '</span><span class="token punctuation">)</span>stream<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token string">'data '</span><span class="token punctuation">)</span>process<span class="token punctuation">.</span><span class="token function">nextTick</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> stream<span class="token punctuation">.</span><span class="token function">uncork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>如果在一个流上多次调用 <code>writable.cork()</code> 方法,则必须调用相同数量的 <code>writable.uncork()</code> 调用来刷新缓冲的数据</p> <pre class="line-numbers language-js" data-language="js"><code class="language-js">stream<span class="token punctuation">.</span><span class="token function">cork</span><span class="token punctuation">(</span><span class="token punctuation">)</span>stream<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token string">'some '</span><span class="token punctuation">)</span>stream<span class="token punctuation">.</span><span class="token function">cork</span><span class="token punctuation">(</span><span class="token punctuation">)</span>stream<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token string">'data '</span><span class="token punctuation">)</span>process<span class="token punctuation">.</span><span class="token function">nextTick</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>  stream<span class="token punctuation">.</span><span class="token function">uncork</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment">// 在第二次调用 uncork() 之前不会刷新数据.</span>  stream<span class="token punctuation">.</span><span class="token function">uncork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li><li><p><code>writable.write(chunk[, encoding][, callback])</code></p><ul><li>参数<ul><li><code>chunk</code>:和<code>end()</code>一样</li><li><code>encoding</code>: &lt;string&gt; | &lt;null&gt;,如果<code>chunk</code>为字符串,则w为编码.<strong>默认值: ‘utf8’</strong></li><li><code>callback</code>:&lt;Function&gt;当刷新此数据块时的回调</li></ul></li><li>返回: &lt;boolean&gt; 如果流希望调用代码在继续写入其他数据之前等待<code>drain</code>事件被触发,则为false.否则为 true</li></ul></li></ol><blockquote><p>属性</p></blockquote><ol><li><code>writable.closed</code>:触发<code>&#39;close&#39;</code>之后为 true</li><li><code>writable.destroyed</code>:在调用 <code>writable.destroy()</code> 之后是 true</li><li><code>writable.writable</code>:如果调用 <code>writable.write()</code> 是安全的,则为 true,这意味着流没有被销毁、出错或结束</li><li><code>writable.writableAborted</code>:返回在触发 ‘finish’ 之前流是被破销毁或出错</li><li><code>writable.writableEnded</code>:在调用<code>writable.end()</code>之后是 true.此属性不指示数据是否已刷新,为此则使用 <code>writable.writableFinished</code> 代替</li><li><code>writable.writableCorked</code>:需要调用 <code>writable.uncork()</code> 以完全解开流的次数</li><li><code>writable.errored</code>:如果流因错误而被销毁,则返回false</li><li><code>writable.writableFinished</code>:在触发 ‘finish’ 事件之前立即设置为 true</li><li><code>writable.writableHighWaterMark</code>:返回创建此 Writable 时传入的 highWaterMark 的值</li><li><code>writable.writableLength</code>:此属性包含队列中准备写入的字节数(或对象数).该值提供有关 <code>highWaterMark</code>状态的内省数据</li><li><code>writable.writableNeedDrain</code>:如果流的缓冲区已满并且流将触发 ‘drain’,则为 true</li><li><code>writable.writableObjectMode</code>:给定 <code>Writable</code> 流的属性 <code>objectMode</code> 的获取器</li></ol><h3 id="Readable-Streams"><a href="#Readable-Streams" class="headerlink" title="Readable Streams"></a>Readable Streams</h3><ul><li>HTTP responses, on the client</li><li>HTTP requests, on the server</li><li>fs read streams</li><li>zlib streams</li><li>crypto streams</li><li>TCP sockets</li><li>child process stdout and stderr</li><li>process.stdin</li></ul><blockquote><p>两种读取模式</p></blockquote><p><code>Readable</code>流以两种模式:<strong>流动和暂停</strong>.这些模式与对象模式是分开的. <code>Readable</code>流可以处于或不处于对象模式,无论其是处于流动模式还是暂停模式.</p><ul><li><p>在流动模式下,数据会自动从底层系统读取,并通过<code>EventEmitter</code>接口使用事件尽快提供给应用程序</p></li><li><p>在暂停模式下,必须显式调用<code>stream.read()</code>方法以从流中读取数据块</p></li><li><p>所有的<code>Readable</code>流都以暂停模式开始,但可以通过以下方式之一切换到流动模式</p><ul><li>添加 <code>&#39;data&#39;</code> 事件句柄.</li><li>调用 <code>stream.resume()</code> 方法.</li><li>调用 <code>stream.pipe()</code> 方法将数据发送到 Writable</li></ul></li><li><p><code>Readable</code>可以使用以下方法之一切换回暂停模式</p><ul><li>如果没有管道目标,则通过调用<code>stream.pause()</code>方法.</li><li>如果有管道目标,则删除所有管道目标.可以通过调用<code>stream.unpipe()</code>方法删除多个管道目标.</li></ul></li><li><p>要记住的重要概念是,在提供消费或忽略该数据的机制之前,<code>Readable</code> 不会产生数据.如果消费机制被禁用或移除,则<code>Readable</code> 将尝试停止产生数据</p></li><li><p>出于向后兼容性的原因,删除<code>data</code>事件句柄不会自动暂停流.此外,如果有管道目标,则调用<code>stream.pause()</code>将不能保证一旦这些目标排空并要求更多数据,流将保持暂停状态.</p></li><li><p>如果<code>Readable</code>切换到流动模式并且没有消费者可用于处理数据,则数据将被丢失.例如,当调用<code>readable.resume()</code>方法而没有绑定到 <code>data</code>事件的监听器时,或者当从流中删除<code>data</code>事件句柄时,就会发生这种情况.</p></li><li><p>添加<code>readable</code>事件句柄会自动使流停止流动,并且必须通过<code>readable.read()</code>来消费数据.如果删除了<code>readable</code>事件句柄,则如果有<code>data</code>事件句柄,流将再次开始流动.</p></li></ul><blockquote><p>三种状态</p></blockquote><ul><li><code>Readable</code> 流的操作的”两种模式”是对 <code>Readable</code> 流实现中发生的更复杂的内部状态管理的简化抽象</li><li>具体来说,在任何给定的时间点,每个 Readable 都处于三种可能的状态之一:<ul><li><code>readable.readableFlowing === null</code></li><li><code>readable.readableFlowing === false</code></li><li><code>readable.readableFlowing === true</code></li></ul></li><li>当 <code>readable.readableFlowing</code> 为 null 时,则不提供消费流数据的机制.因此,流不会生成数据. 在此状态下,为 ‘data’ 事件绑定监听器、调用<code>readable.pipe()</code>方法,或调用<code>readable.resume()</code>方法会将<code>readable.readableFlowing</code>切换到<code>true</code>,从而使 <code>Readable</code> 在生成数据时开始主动触发事件.</li><li>调用<code>readable.pause()</code>、<code>readable.unpipe()</code>,或者接收背压都会导致<code>readable.readableFlowing</code>被设置为 false,暂时停止事件的流动,但不会停止数据的生成.在此状态下,为<code>&#39;data&#39;</code>事件绑定监听器不会将<code>readable.readableFlowing</code>切换到 true.</li></ul><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">const</span> <span class="token punctuation">&#123;</span> PassThrough<span class="token punctuation">,</span> Writable <span class="token punctuation">&#125;</span> <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'node:stream'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> pass <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PassThrough</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> writable <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Writable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>pass<span class="token punctuation">.</span><span class="token function">pipe</span><span class="token punctuation">(</span>writable<span class="token punctuation">)</span><span class="token punctuation">;</span>pass<span class="token punctuation">.</span><span class="token function">unpipe</span><span class="token punctuation">(</span>writable<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// readableFlowing 现在为 false.</span>pass<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'data'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">chunk</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>chunk<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>pass<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token string">'ok'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 不会触发 'data'.</span>pass<span class="token punctuation">.</span><span class="token function">resume</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// 必须调用才能使流触发 'data'.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>事件</p></blockquote><ol><li><p><code>close</code>:当流及其任何底层资源已关闭时,则会触发<code>close</code>事件.该事件表明将不再触发更多事件,并且不会发生进一步的计算</p><ul><li>如果<code>Readable</code>流是使用<code>emitClose</code>选项创建的,则始终会触发<code>close</code>事件.</li></ul></li><li><p><code>data</code>:<strong>chunk &lt;Buffer&gt; | &lt;string&gt; | &lt;any&gt; 数据块</strong>.对于不在对象模式下操作的流,块将是<strong>字符串</strong>或<strong>Buffer</strong>.对于处于对象模式的流,块可以是除null之外的任何JavaScript值</p><ul><li>每当流将数据块的所有权移交给消费者时,则会触发<code>data</code>事件. 每当通过调用 <code>readable.pipe()</code>,<code>readable.resume()</code>,或通过将监听器回调绑定到<code>data</code>事件而将流切换到流动模式时,就会发生这种情况</li><li>每当调用<code>readable.read()</code>方法并且可以返回数据块时,也会触发 ‘data’ 事件.</li><li>将 ‘data’ 事件监听器绑定到尚未显式暂停的流,则会将流切换到流动模式. 数据将在可用时立即传入.</li><li>如果使用<code>readable.setEncoding()</code>方法为流指定了默认编码,则监听器回调将把数据块作为字符串传入.否则数据将作为Buffer传入</li></ul></li><li><p><code>end</code>:当流中没有更多数据可供消费时,则会触发 ‘end’ 事件.</p><ul><li>除非数据被完全地消费,否则不会触发 ‘end’ 事件.这可以通过将流切换到流动模式来实现,或者通过重复调用<code>stream.read()</code>直到所有数据都被消费完</li></ul></li><li><p><code>error</code>:error事件可以随时由 <code>Readable</code> 的实现触发.通常,如果底层流由于底层内部故障而无法生成数据,或者当流实现尝试推送无效数据块时,可能会发生这种情况</p><ul><li>监听器回调将传入单个 Error 对象</li></ul></li><li><p><code>pause</code>:当调用<code>stream.pause()</code>并且<code>readableFlowing</code>不是<code>false</code>时,则会触发<code>pause</code>事件.</p></li><li><p><code>readable</code>:当有可从流中读取的数据或已到达流的末尾时,则将触发<code>readable</code>事件.实际上,<code>readable</code>事件表明流有新的信息. 如果数据可用,则<code>stream.read()</code>将返回该数据.</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">const</span> readable <span class="token operator">=</span> <span class="token function">getReadableStreamSomehow</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>readable<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'readable'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// 现在有一些数据要读取.</span>  <span class="token keyword">let</span> data<span class="token punctuation">;</span>  <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>data <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>如果已经到达流的末尾,则调用<code>stream.read()</code>将返回null并触发<code>end</code>事件.如果从未读取任何数据,则也是如此</li><li>例如,在以下示例中,foo.txt 是一个空文件:</li></ul><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">const</span> fs <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'node:fs'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> rr <span class="token operator">=</span> fs<span class="token punctuation">.</span><span class="token function">createReadStream</span><span class="token punctuation">(</span><span class="token string">'foo.txt'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>rr<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'readable'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">readable: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>rr<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>rr<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'end'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'end'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>在某些情况下,为<code>readable</code>事件绑定监听器会导致一些数据被读入内部缓冲区</li><li>一般来说,<code>readable.pipe()</code>和<code>data</code>事件机制比<code>readable</code>事件更容易理解.但是,处理<code>readable</code>可能会导致吞吐量增加</li><li>如果同时使用<code>readable</code>和<code>data</code>,则<code>readable</code>优先控制流,即只有在调<code>stream.read()</code>时才会触发 ‘data’.<code>readableFlowing</code>属性将变为 false.如果在移除<code>readable</code>时有data监听器,则流将开始流动,即data事件将在不调用<code>resume()</code>的情况下触发.</li></ul></li><li><p><code>resume</code>当调用<code>stream.resume()</code>并且<code>readableFlowing</code>不是true时,则会触发<code>resume</code>事件</p></li></ol><blockquote><p>方法</p></blockquote><ul><li><p><code>readable.destroy([error])</code>: <strong>销毁流</strong>可选地触发<code>error</code>事件,并且触发<code>close</code>事件(除非<code>emitClose</code>设置为<code>false</code>) 在此调用之后,可读流将释放任何内部资源,随后对<code>push()</code>的调用将被忽略</p><ul><li>一旦<code>destroy()</code>被调用,任何进一步的调用都将是空操作,除了来自<code>_destroy()</code>的其他错误可能不会作为error触发.</li><li>实现者不应覆盖此方法,而应实现 readable._destroy().</li></ul></li><li><p><code>readable.isPaused()</code>:方法返回<code>Readable</code>的当前运行状态 这主要由作为<code>readable.pipe()</code>方法基础的机制使用.在大多数典型情况下,没有理由直接使用此方法</p></li><li><p><code>readable.pause()</code>:方法将导致处于流动模式的流停止触发<code>data</code>事件,切换出流动模式.任何可用的数据都将保留在内部缓冲区中</p></li><li><p><code>readable.pipe(destination[, options])</code></p><ul><li><p>参数</p><ul><li><code>destination</code>:&lt;stream.Writable&gt; 写入数据的目标</li><li><code>options</code>:&lt;Object&gt; 管道选项<ul><li><code>end</code>:&lt;boolean&gt; 当读取结束时结束写入.<strong>默认值: true</strong>.</li></ul></li></ul></li><li><p>返回:&lt;stream.Writable&gt; 目标,如果它是Duplex或 Transform 流,则允许使用管道链</p></li><li><p><code>readable.pipe()</code>方法将<code>Writable</code>流绑定到<code>readable</code>,使其自动切换到流动模式并将其所有数据推送到绑定的 <code>Writable</code>. 数据流将被自动管理,以便目标<code>Writable</code>流不会被更快的<code>Readable</code>流漫过.</p></li><li><p>以下示例将 <code>readable</code> 中的所有数据通过管道传输到名为 <code>file.txt</code> 的文件中：</p></li></ul> <pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">const</span> fs <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'node:fs'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> readable <span class="token operator">=</span> <span class="token function">getReadableStreamSomehow</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> writable <span class="token operator">=</span> fs<span class="token punctuation">.</span><span class="token function">createWriteStream</span><span class="token punctuation">(</span><span class="token string">'file.txt'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 可读流的所有数据进入 'file.txt'</span>readable<span class="token punctuation">.</span><span class="token function">pipe</span><span class="token punctuation">(</span>writable<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>可以将多个<code>Writable</code>流绑定到单个<code>Readable</code>流</li><li><code>readable.pipe()</code>方法返回对目标流的引用,从而可以建立管道流链</li></ul> <pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">const</span> fs <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'node:fs'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> r <span class="token operator">=</span> fs<span class="token punctuation">.</span><span class="token function">createReadStream</span><span class="token punctuation">(</span><span class="token string">'file.txt'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> z <span class="token operator">=</span> zlib<span class="token punctuation">.</span><span class="token function">createGzip</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> w <span class="token operator">=</span> fs<span class="token punctuation">.</span><span class="token function">createWriteStream</span><span class="token punctuation">(</span><span class="token string">'file.txt.gz'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>r<span class="token punctuation">.</span><span class="token function">pipe</span><span class="token punctuation">(</span>z<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">pipe</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>默认情况下,当源<code>Readable</code>流触发’end’时,则在目标Writable流上调用stream.end(),因此目标不再可写.要禁用此默认行为,可以将 end 选项作为 false 传入,从而使目标流保持打开状态:</li></ul> <pre class="line-numbers language-js" data-language="js"><code class="language-js">reader<span class="token punctuation">.</span><span class="token function">pipe</span><span class="token punctuation">(</span>writer<span class="token punctuation">,</span> <span class="token punctuation">&#123;</span> end<span class="token operator">:</span> <span class="token boolean">false</span> <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>reader<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'end'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>  writer<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token string">'Goodbye\n'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li>有个重要的注意事项,如果<code>Readable</code>流在处理过程中触发错误,则<code>Writable</code>目标不会自动关闭.如果发生错误,则需要手动关闭每个流以防止内存泄漏.</li><li><code>process.stderr</code>和<code>process.stdout</code>.Writable 流在 Node.js 进程退出之前永远不会关闭,无论指定的选项如何.</li></ul></li><li><p><code>readable.read([size])</code></p><ul><li><p><code>size</code>&lt;number&gt; 用于指定要读取的数据量的可选参数</p></li><li><p>返回: <code>&lt;string&gt; | &lt;Buffer&gt; | &lt;null&gt; | &lt;any&gt;</code></p></li><li><p><code>readable.read()</code>方法从内部缓冲区中读取数据并返回.如果没有数据可以读取,则返回null.</p><ul><li>默认情况下,除非使用<code>readable.setEncoding()</code>方法指定了编码或流在对象模式下运行,否则数据将作为 Buffer对象返回.</li></ul></li><li><p>可选的 size 参数指定要读取的特定字节数.如果无法读取 size 字节,则将返回 null,除非流已结束,在这种情况下,将返回内部缓冲区中剩余的所有数据</p></li><li><p>如果未指定size参数,则将返回内部缓冲区中包含的所有数据.</p></li><li><p><code>size</code>参数必须小于或等于 1 GiB</p></li><li><p><code>readable.read()</code>方法应该只在暂停模式下操作的 Readable 流上调用.在流动模式下,会自动调用<code>readable.read()</code>,直到内部缓冲区完全排空.</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">const</span> readable <span class="token operator">=</span> <span class="token function">getReadableStreamSomehow</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 随着数据被缓冲,'readable' 可能会被多次触发</span>readable<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'readable'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>  <span class="token keyword">let</span> chunk<span class="token punctuation">;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Stream is readable (new data received in buffer)'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 使用循环来确保读取所有当前可用的数据</span>  <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token keyword">null</span> <span class="token operator">!==</span> <span class="token punctuation">(</span>chunk <span class="token operator">=</span> readable<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">Read </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>chunk<span class="token punctuation">.</span>length<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token string"> bytes of data...</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 当没有更多可用数据时,则触发一次 'end'.</span>readable<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'end'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Reached end of stream.'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li><li><p><code>readable.resume()</code>:readable.resume() 方法使被显式暂停的 Readable 流恢复触发 ‘data’ 事件,将流切换到流动模式.</p><ul><li><code>readable.resume()</code>方法可用于完全地消费流中的数据,而无需实际处理任何数据</li></ul> <pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token function">getReadableStreamSomehow</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token punctuation">.</span><span class="token function">resume</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'end'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Reached the end, but did not read anything.'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>如果有 ‘readable’ 事件监听器,则 <code>readable.resume()</code> 方法不起作用</li></ul></li><li><p><code>readable.setEncoding(encoding)</code></p><ul><li><code>encoding</code>:&lt;string&gt; 要使用的编码.</li><li><code>readable.setEncoding()</code>方法为从Readable流读取的数据设置字符编码</li><li>默认情况下,没有分配编码,流数据将作为 Buffer 对象返回.设置编码会导致流数据作为指定编码的字符串而不是 Buffer 对象返回. 例如,调用<code>readable.setEncoding(&#39;utf8&#39;)</code>将导致输出数据被解释为 UTF-8 数据,并作为字符串传入</li><li>调用<code>readable.setEncoding(&#39;hex&#39;)</code>将使数据以十六进制字符串格式进行编码.</li><li>Readable 流将正确地处理通过流传递的多字节字符,否则如果简单地从流中提取为 Buffer 对象,这些字符将无法正确解码</li></ul> <pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">const</span> readable <span class="token operator">=</span> <span class="token function">getReadableStreamSomehow</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>readable<span class="token punctuation">.</span><span class="token function">setEncoding</span><span class="token punctuation">(</span><span class="token string">'utf8'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>readable<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'data'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">chunk</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>  assert<span class="token punctuation">.</span><span class="token function">equal</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> chunk<span class="token punctuation">,</span> <span class="token string">'string'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Got %d characters of string data:'</span><span class="token punctuation">,</span> chunk<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><code>readable.unpipe([destination])</code></p><ul><li><code>destination</code>: &lt;stream.Writable&gt; 可选的要取消管道的特定流</li><li><code>readable.unpipe()</code>方法分离先前使用<code>stream.pipe()</code>方法绑定的<code>Writable</code>流.</li><li>如果未指定<code>destination</code>,则所有管道都将分离.</li><li>如果指定了<code>destination</code>,但没有为其设置管道,则该方法不执行任何操作.</li></ul> <pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">const</span> fs <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'node:fs'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> readable <span class="token operator">=</span> <span class="token function">getReadableStreamSomehow</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> writable <span class="token operator">=</span> fs<span class="token punctuation">.</span><span class="token function">createWriteStream</span><span class="token punctuation">(</span><span class="token string">'file.txt'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 可读流的所有数据进入 'file.txt',</span><span class="token comment">// 但只有第一秒.</span>readable<span class="token punctuation">.</span><span class="token function">pipe</span><span class="token punctuation">(</span>writable<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Stop writing to file.txt.'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  readable<span class="token punctuation">.</span><span class="token function">unpipe</span><span class="token punctuation">(</span>writable<span class="token punctuation">)</span><span class="token punctuation">;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Manually close the file stream.'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  writable<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><blockquote><p>属性</p></blockquote><ul><li><code>readable.closed</code>:触发<code>close</code>之后为true.</li><li><code>readable.destroyed</code>:在调用<code>readable.destroy()</code>之后是 true.</li><li><code>readable.readable</code>:如果调用 readable.read() 是安全的,则为 true,这意味着流尚未被销毁或触发 ‘error’ 或 ‘end’.</li><li><code>readable.readableAborted</code>:返回在触发 ‘end’ 之前流是被破销毁或出错</li><li><code>readable.readableDidRead</code>:返回是否已触发 ‘data’</li><li><code>readable.readableEncoding</code>:给定 Readable流的属性encoding 的获取器.可以使用<code>readable.setEncoding()</code>方法设置 <code>encoding</code>属性</li><li><code>readable.readableEnded</code>:当触发 ‘end’ 事件时变为 true</li><li><code>eadable.errored</code>:如果流因错误而被销毁,则返回<code>error</code></li><li><code>readable.readableFlowing</code>:反映了 Readable 流的当前三种状态之一</li><li><code>readable.readableHighWaterMark</code>:返回创建此 Readable 时传入的 highWaterMark 的值</li><li><code>readable.readableLength</code>:此属性包含队列中准备读取的字节数(或对象数).该值提供有关 <code>highWaterMark</code>状态的内省数据</li><li><code>readable.readableObjectMode</code>:给定 Readable 流的属性 objectMode 的获取器</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Stream&quot;&gt;&lt;a href=&quot;#Stream&quot; class=&quot;headerlink&quot; title=&quot;Stream&quot;&gt;&lt;/a&gt;Stream&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;stream 的种类&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;co</summary>
      
    
    
    
    <category term="stram" scheme="http://mail.zyjcould.ltd/categories/stram/"/>
    
    
    <category term="JS" scheme="http://mail.zyjcould.ltd/tags/JS/"/>
    
    <category term="node" scheme="http://mail.zyjcould.ltd/tags/node/"/>
    
  </entry>
  
  <entry>
    <title>stream</title>
    <link href="http://mail.zyjcould.ltd/2022/05/14/stream/"/>
    <id>http://mail.zyjcould.ltd/2022/05/14/stream/</id>
    <published>2022-05-14T11:27:26.000Z</published>
    <updated>2022-05-15T11:46:13.659Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h2><blockquote><p>流(stream)是抽象的数据接口,流实现了<code>EventEmitter</code>这个接口,并且node中的很多对象实现了流</p></blockquote><ul><li><p>在读取大文件的时候,完全读完文件再响应大量用户并发请求的时候,程序可能会消耗大量的内存,可能会造成用户连接缓慢的问题</p> <pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token comment">//mjs</span><span class="token keyword">import</span> http <span class="token keyword">from</span> <span class="token string">"http"</span><span class="token keyword">import</span> <span class="token operator">*</span> <span class="token keyword">as</span> fs <span class="token keyword">from</span> <span class="token string">"fs"</span><span class="token keyword">const</span> server <span class="token operator">=</span> http<span class="token punctuation">.</span><span class="token function">createServer</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">req<span class="token punctuation">,</span> res</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>  <span class="token keyword">const</span> filename <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">URL</span><span class="token punctuation">(</span><span class="token string">"data.txt"</span><span class="token punctuation">,</span> <span class="token keyword">import</span><span class="token punctuation">.</span>meta<span class="token punctuation">.</span>url<span class="token punctuation">)</span>  <span class="token keyword">let</span> stream <span class="token operator">=</span> fs<span class="token punctuation">.</span><span class="token function">createReadStream</span><span class="token punctuation">(</span>filename<span class="token punctuation">)</span>  stream<span class="token punctuation">.</span><span class="token function">pipe</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span>server<span class="token punctuation">.</span><span class="token function">listen</span><span class="token punctuation">(</span><span class="token number">8000</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"server is running"</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>stream可以不需要把文件全部读取再返回,而是一边读取一边返回,数据通过管道流动给客户端,减轻服务器压力</li></ul></li></ul><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/7/10/16bdbb113be0341a~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp" alt=" "></p><ul><li>stream整个流转过程包括<code>source</code>,<code>dest</code>,还有连接二者的管道<code>pipe</code>(stream核心)</li></ul><h3 id="source"><a href="#source" class="headerlink" title="source"></a>source</h3><blockquote><p>stream常见的三种来源</p></blockquote><ol><li>从控制台输入</li><li>http请求中的request</li><li>读取文件</li></ol><blockquote><p>process.stdin</p></blockquote><ul><li>当在控制台输入<code>hello world</code>时</li></ul><pre class="line-numbers language-js" data-language="js"><code class="language-js">process<span class="token punctuation">.</span>stdin<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">"data"</span><span class="token punctuation">,</span> <span class="token parameter">data</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"stream=>"</span><span class="token punctuation">,</span> data<span class="token punctuation">)</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">stream=></span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>data<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token comment">// stream=> &lt;Buffer 68 65 6c 6c 6f 20 77 6f 72 6c 64 0d 0a></span><span class="token comment">// stream=>hello world</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>控制台输入的任何内容都会被<code>data</code>事件监听到,<code>process.stdin</code>是一个<code>stream</code>对象,data是用来监听数据传入的一个自定义函数</li></ul><h3 id="pipe"><a href="#pipe" class="headerlink" title="pipe"></a>pipe</h3><blockquote><p>在<code>source</code>和<code>dest</code>之间有一个来凝结的管道<code>pipe</code>,他的基本语法是<code>source.pipe(dest)</code>,<code>source</code>和<code>dest</code>就是通过pipe管道,让数据从<code>source</code>流向<code>dest</code></p></blockquote><h3 id="dest"><a href="#dest" class="headerlink" title="dest"></a>dest</h3><blockquote><p>stream常见的三种输出方式</p></blockquote><ol><li>输出控制台</li><li>http请求中的response</li><li>输出文件</li></ol><ul><li>stream的应用场景主要是处理<code>IO</code>流.并且<code>http请求</code>和<code>文件操作</code>都属于IO操作</li><li>stream的本质就是避免IO操作过大,硬件开销太多,因此将IO分批分段进行操作,让数据像水管一样流动</li></ul><blockquote><p>get请求中应用stream</p></blockquote><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">import</span> http <span class="token keyword">from</span> <span class="token string">"http"</span><span class="token keyword">import</span> <span class="token operator">*</span> <span class="token keyword">as</span> fs <span class="token keyword">from</span> <span class="token string">"fs"</span><span class="token keyword">const</span> server <span class="token operator">=</span> http<span class="token punctuation">.</span><span class="token function">createServer</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">req<span class="token punctuation">,</span> res</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>req<span class="token punctuation">.</span>method <span class="token operator">===</span> <span class="token string">"GET"</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">//默认是get请求</span>    <span class="token keyword">const</span> filename <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">URL</span><span class="token punctuation">(</span><span class="token string">"data.txt"</span><span class="token punctuation">,</span> <span class="token keyword">import</span><span class="token punctuation">.</span>meta<span class="token punctuation">.</span>url<span class="token punctuation">)</span>    <span class="token keyword">let</span> stream <span class="token operator">=</span> fs<span class="token punctuation">.</span><span class="token function">createReadStream</span><span class="token punctuation">(</span>filename<span class="token punctuation">)</span>    stream<span class="token punctuation">.</span><span class="token function">pipe</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span>server<span class="token punctuation">.</span><span class="token function">listen</span><span class="token punctuation">(</span><span class="token number">8000</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"server is running"</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>response</code>也是一个stream对象,就是接受收数据的<code>dest</code></li><li><code>request</code>是source,数据的源头</li></ul><blockquote><p>在文件中拷贝数据</p></blockquote>   <pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">import</span> <span class="token operator">*</span> <span class="token keyword">as</span> fs <span class="token keyword">from</span> <span class="token string">"fs"</span><span class="token keyword">const</span> filenameOne <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">URL</span><span class="token punctuation">(</span><span class="token string">"data.txt"</span><span class="token punctuation">,</span> <span class="token keyword">import</span><span class="token punctuation">.</span>meta<span class="token punctuation">.</span>url<span class="token punctuation">)</span><span class="token keyword">const</span> filenameTwo <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">URL</span><span class="token punctuation">(</span><span class="token string">"data-copy.txt"</span><span class="token punctuation">,</span> <span class="token keyword">import</span><span class="token punctuation">.</span>meta<span class="token punctuation">.</span>url<span class="token punctuation">)</span><span class="token keyword">const</span> readStream <span class="token operator">=</span> fs<span class="token punctuation">.</span><span class="token function">createReadStream</span><span class="token punctuation">(</span>filenameOne<span class="token punctuation">)</span><span class="token keyword">const</span> writeStream <span class="token operator">=</span> fs<span class="token punctuation">.</span><span class="token function">createWriteStream</span><span class="token punctuation">(</span>filenameTwo<span class="token punctuation">)</span>readStream<span class="token punctuation">.</span><span class="token function">pipe</span><span class="token punctuation">(</span>writeStream<span class="token punctuation">)</span>readStream<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">"end"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"readStream end"</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>首先创建一个可读数据流<code>readStream</code>,一个可写数据流<code>writeStream</code>,然后直接通过<code>pipe</code>管道把数据直接传过去</li></ul><h3 id="Stream种类"><a href="#Stream种类" class="headerlink" title="Stream种类"></a>Stream种类</h3><ul><li><code>Readable Stream</code> 可读数据流</li><li><code>Writeable Stream</code> 可写数据流</li><li><code>Duplex Stream</code> 双向数据流,可以同时读和写<ul><li><code>Duplex Stream</code>是双向的,既可以读又可以写.<code>Duplex Stream</code>同时实现了<code>Readable</code>和<code>Writeable</code>接口</li><li>包括<code>tcp sockets</code>,<code>zlib streams</code>,<code>crypto streams</code></li></ul></li><li><code>Transform Stream</code>转换数据流,可读可写,同时可以转换&#x2F;处理数据(不常用)</li></ul><blockquote><p>流驱动的node api</p></blockquote><ul><li><code>process.stdin</code>:返回连接到 <code>stdin</code> 的流</li><li><code>process.stdout</code>:返回连接到 <code>stdout</code> 的流</li><li><code>process.stderr</code>:返回连接到 <code>stderr</code> 的流</li><li><code>fs.createReadStream()</code>: 创建文件的可读流</li><li><code>fs.createWriteStream()</code>: 创建到文件的可写流</li><li><code>net.connect()</code>: 启动基于流的连接</li><li><code>http.request()</code>: 返回 <code>http.ClientRequest</code> 类的实例,该实例是可写流</li><li><code>zlib.createGzip()</code>: 使用 <code>gzip</code>(压缩算法)将数据压缩到流中</li><li><code>zlib.createGunzip()</code>: 解压缩 <code>gzip</code> 流</li><li><code>zlib.createDeflate()</code>: 使用 <code>deflate</code>（压缩算法）将数据压缩到流中</li><li><code>zlib.createInflate()</code>: 解压缩 <code>deflate</code> 流</li></ul><blockquote><p>stream 的弊端</p></blockquote><ol><li>使用<code>rs.pipe(ws)</code>方式来写文件,不是将rs的文件追加到ws文件之后,而是将rs的内容覆盖ws</li><li>已结束&#x2F;关闭 的流不能重复使用,必须重新创建数据流</li><li><code>pipe</code>方法返回的是目标数据流,例如<code>a.pipe(b)</code>返回的是b,因此监听事件需要主义监听对象是否正确</li><li>如果需要监听多个数据流,同时又使用<code>pipe</code>方法</li></ol><pre class="line-numbers language-js" data-language="js"><code class="language-js">data  <span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'end'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'data end'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">)</span>  <span class="token punctuation">.</span><span class="token function">pipe</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span>  <span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'end'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'a end'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">)</span>  <span class="token punctuation">.</span><span class="token function">pipe</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span>  <span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'end'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'b end'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Stream&quot;&gt;&lt;a href=&quot;#Stream&quot; class=&quot;headerlink&quot; title=&quot;Stream&quot;&gt;&lt;/a&gt;Stream&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;流(stream)是抽象的数据接口,流实现了&lt;code&gt;EventEmitter&lt;</summary>
      
    
    
    
    <category term="stram" scheme="http://mail.zyjcould.ltd/categories/stram/"/>
    
    
    <category term="JS" scheme="http://mail.zyjcould.ltd/tags/JS/"/>
    
    <category term="node" scheme="http://mail.zyjcould.ltd/tags/node/"/>
    
  </entry>
  
  <entry>
    <title>child_process</title>
    <link href="http://mail.zyjcould.ltd/2022/05/10/child-process/"/>
    <id>http://mail.zyjcould.ltd/2022/05/10/child-process/</id>
    <published>2022-05-10T11:56:38.000Z</published>
    <updated>2022-05-14T04:23:16.279Z</updated>
    
    <content type="html"><![CDATA[<h2 id="异步流程"><a href="#异步流程" class="headerlink" title="异步流程"></a>异步流程</h2><blockquote><p>child_process.spawn(),child_process.fork(),child_process.exec()和child_process.execFile()方法都遵循其他 Node.js API 的典型惯用异步编程模式</p></blockquote><ul><li>每个方法都会返回一个<code>ChildProcess</code>实例,这些对象实现<code>Node.js</code>的<code>EventEmitter</code>API,允许父进程注册在子进程的生命周期中发生某些事件时调用的侦听器函数<ul><li><code>exec</code>,<code>execFile</code>创建时可以指定<code>timeout</code>属性设置超时时间,一旦创建的进程运行超过设定的时间将会被杀死.<code>spawn</code>不可以</li><li><code>exec</code>适合执行已有的命令,<code>execFile</code>适合执行文件</li><li><code>exec</code>,<code>execFile</code>,<code>fork</code>都是spawn的延伸应用,底层都是通过spawn实现的</li></ul></li></ul><table><thead><tr><th>options</th><th>参数说明</th></tr></thead><tbody><tr><td>cwd</td><td>默认值<code>process.cwd()</code>当前工作路径</td></tr><tr><td>env</td><td>默认值<code>process.env</code>环境变量</td></tr><tr><td>encoding</td><td>编码,默认是<code>utf8</code></td></tr><tr><td>shell</td><td>用来执行命令的<code>shell</code>,<code>unix</code>上默认是<code>/bin/sh</code>,windows上默认是cmd.exe</td></tr><tr><td>timeout</td><td>默认是<code>0</code></td></tr><tr><td>killSignal</td><td>默认是<code>SIGTERM</code></td></tr><tr><td>uid</td><td>执行进程的<code>uid</code></td></tr><tr><td>gid</td><td>执行进程的<code>gid</code></td></tr><tr><td>maxBuffer</td><td>标准输出,错误输出最大允许的数据量(单位为字节),如果超出的话,子进程就会被杀死.默认是<code>200*1024</code>(即200k)</td></tr><tr><td>windowsHide</td><td>默认值false.隐藏通常在<code>Windows</code>系统上创建的子进程控制台窗口</td></tr></tbody></table><h3 id="spawn-command-args-options"><a href="#spawn-command-args-options" class="headerlink" title="spawn(command[, args][, options])"></a>spawn(command[, args][, options])</h3><ol><li><code>command</code>:要执行的命令</li><li><code>args</code>:字符串参数列表</li><li><code>options</code>:参数说明,其它重复的参数不在重复</li></ol><blockquote><p>异步衍生子进程,不会阻塞父进程的执行</p></blockquote><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">import</span> <span class="token punctuation">&#123;</span> spawn <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">'child_process'</span><span class="token keyword">const</span> ls <span class="token operator">=</span> <span class="token function">spawn</span><span class="token punctuation">(</span><span class="token string">'ls'</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">'-lh'</span><span class="token punctuation">,</span> <span class="token string">'/usr'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>ls<span class="token punctuation">.</span>stdout<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'data'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">stdout: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>data<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span>ls<span class="token punctuation">.</span>stderr<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'data'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>  console<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">stderr: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>data<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span>ls<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'close'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">code</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">child process exited with code </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>code<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>spawn自带的options参数</p></blockquote><ol><li><code>detached</code>,如果为true,使子进程能够在父进程退出后继续运行</li><li><a href="https://nodejs.org/dist/latest-v16.x/docs/api/child_process.html#optionsstdio"><code>stdio</code>:</a><ul><li><code>&#39;pipe&#39;</code>:默认值.相当于 [‘pipe’, ‘pipe’, ‘pipe’]<ul><li>在子进程和父进程之间创建管道</li></ul></li><li><code>&#39;overlapped&#39;</code>: 相当于 [‘overlapped’, ‘overlapped’, ‘overlapped’]<ul><li>与’pipe’相同,只是在参数上设置了<code>FILE_FLAG_OVERLAPPED</code>标志</li></ul></li><li><code>&#39;ignore&#39;</code>: 相当于 [‘ignore’, ‘ignore’, ‘ignore’]<ul><li>指示 Node.js 忽略子进程中的文件描述符</li></ul></li><li><code>&#39;inherit&#39;</code>: 相当于 [‘inherit’, ‘inherit’, ‘inherit’]或[0, 1, 2](0,1和2分别对应于标准输入,标准输出和标准错误)<ul><li>通过相应的标准输入输出流传入&#x2F;传出父进程</li></ul></li></ul></li></ol><blockquote><p>当使用 detached 选项启动长时间运行的进程时,进程在父进程退出后<strong>不会一直在后台运行</strong>,想要长时间运行需要提供stdio</p></blockquote><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">import</span> <span class="token punctuation">&#123;</span> spawn <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">'child_process'</span><span class="token keyword">const</span> subprocess <span class="token operator">=</span> <span class="token function">spawn</span><span class="token punctuation">(</span>process<span class="token punctuation">.</span>argv<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">'child_program.js'</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span>  detached<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>  stdio<span class="token operator">:</span> <span class="token string">'ignore'</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>subprocess<span class="token punctuation">.</span><span class="token function">unref</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="exec-command-options-callback"><a href="#exec-command-options-callback" class="headerlink" title="exec(command[, options][, callback])"></a>exec(command[, options][, callback])</h3><blockquote><p>创建一个shell,然后在shell里执行命令.执行完成后,将<code>stdout</code>,<code>stderr</code>作为参数传入回调方法</p></blockquote><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token function">exec</span><span class="token punctuation">(</span><span class="token string">"echo 'hello world' >> a.txt"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">error<span class="token punctuation">,</span> stdout<span class="token punctuation">,</span> stderr</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>error<span class="token punctuation">)</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span><span class="token punctuation">;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>stdout<span class="token punctuation">)</span><span class="token punctuation">;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>stderr<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="child-process-execFile-file-args-options-callback"><a href="#child-process-execFile-file-args-options-callback" class="headerlink" title="child_process.execFile(file[, args][, options][, callback])"></a>child_process.execFile(file[, args][, options][, callback])</h3><blockquote><p>跟exec类似,但是不会创建一个新的shell,options和exec一样</p></blockquote><ul><li>执行shell脚本命令</li></ul><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token function">execFile</span><span class="token punctuation">(</span><span class="token string">"./a.sh"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">error<span class="token punctuation">,</span> stdout<span class="token punctuation">,</span> stderr</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>error<span class="token punctuation">)</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span><span class="token punctuation">;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>stdout<span class="token punctuation">)</span><span class="token punctuation">;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>stderr<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="child-process-fork-modulePath-args-options"><a href="#child-process-fork-modulePath-args-options" class="headerlink" title="child_process.fork(modulePath[, args][, options])"></a>child_process.fork(modulePath[, args][, options])</h3><ol><li><code>modulePath</code>:子进程运行的模块</li><li><code>args</code>:字符串参数列表</li><li><code>options</code>:参数如下所示.其中与 exec 重复的参数就不重复介绍<ul><li><code>execPath</code>:用来创建子进程的可执行文件,默认是<code>/usr/local/bin/node</code>.也就是说通过execPath来指定具体的node版本</li><li><code>execArgv</code>:传给可执行文件的字符串参数列表.默认是<code>process.execArgv</code>,跟父进程保持一致</li><li><code>silent</code>:默认是<code>false</code>,即子进程的<code>stdio</code>从父进程继承.如果是true,则直接<code>pipe</code>向子进程的<code>child.stdin</code>,<code>child.stdout</code>等</li><li><code>stdio</code>:选项用于配置在父进程和子进程之间建立的管道,<span style="color:red">如果声明了stdio,则会覆盖silent选项的设置</span></li></ul></li></ol><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token comment">//child3.js</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Ending...'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><blockquote><p>默认silent为 false,子进程会继承父进程</p></blockquote><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">const</span> <span class="token punctuation">&#123;</span> fork <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">""</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Starting...'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">fork</span><span class="token punctuation">(</span><span class="token string">'./child3.js'</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span>  silent<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>设置 silent 为 true,则子进程不会输出</p></blockquote><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token function">fork</span><span class="token punctuation">(</span><span class="token string">'./child3.js'</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span>  silent<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p>通过stdout属性,可以获取到子进程输出的内容</p></blockquote><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">const</span> child3 <span class="token operator">=</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token string">'./child3.js'</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span>  silent<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>child3<span class="token punctuation">.</span>stdout<span class="token punctuation">.</span><span class="token function">setEncoding</span><span class="token punctuation">(</span><span class="token string">'utf8'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>child3<span class="token punctuation">.</span>stdout<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'data'</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'stdout 中输出:'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="同步流程"><a href="#同步流程" class="headerlink" title="同步流程"></a>同步流程</h2><blockquote><p>child_process.spawnSync(),child_process.execSync()和child_process.execFileSync()方法是同步的,将阻塞 Node.js 事件循环,暂停任何其他代码的执行,直到产生的进程退出</p></blockquote><ul><li>像这样的阻塞调用对于简化通用脚本任务和在启动时简化应用<strong>程序配置的加载&#x2F;处理非常有用</strong></li><li>参数和异步的相同</li></ul><h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><ol><li><strong>close事件</strong>:子进程的stdio流关闭时触发</li><li><strong>disconnect事件</strong>:事件在父进程手动调用 <code>child.disconnect</code> 函数时触发</li><li><strong>error事件</strong>:产生错误时会触发</li><li><strong>exit事件</strong>:子进程自行退出时触发</li><li><strong>message事件</strong>:它在子进程使用<code>process.send()</code>函数来传递消息时触发</li></ol><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">import</span> <span class="token punctuation">&#123;</span> fork <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">'child_process'</span><span class="token punctuation">;</span><span class="token keyword">const</span> child <span class="token operator">=</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token string">'./child3.js'</span><span class="token punctuation">)</span>child<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'close'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">code<span class="token punctuation">,</span> signal</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'close 事件：'</span><span class="token punctuation">,</span> code<span class="token punctuation">,</span> signal<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span>child<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'disconnect'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'disconnect 事件...'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span>child<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'error'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">code<span class="token punctuation">,</span> signal</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'error 事件：'</span><span class="token punctuation">,</span> code<span class="token punctuation">,</span> signal<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span>child<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'exit'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">code<span class="token punctuation">,</span> signal</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'exit 事件：'</span><span class="token punctuation">,</span> code<span class="token punctuation">,</span> signal<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span>child<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'message'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">val</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'message 事件：'</span><span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span>child<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'spawn'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'spawn 事件'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token comment">//child3.js</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'starting...'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>process<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token string">"子线程..."</span><span class="token punctuation">)</span><span class="token comment">// starting...</span><span class="token comment">// spawn事件</span><span class="token comment">// message 事件： 子线程...</span><span class="token comment">// exit 事件： 0 null</span><span class="token comment">// close 事件： 0 null</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h2><ul><li>通过以上 4 种 API 创建子进程后,父进程与子进程之间将会创建<code>IPC</code>通道,通过<code>IPC</code>通道,父子进程之间通过<code>message</code>和<code>send</code>来通信</li><li>Node 中实现 IPC 通道的是管道(<code>pipe</code>)技术,具体实现细节由 libuv 实现</li></ul><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2a9ff71a53994eba8b5eec5e37e70626~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt=" "></p><ul><li>父进程在实际创建子进程之前,会创建 IPC 通道并监听它,然后才真正创建出子进程,并通过环境变量<code>NODE_CHANNEL_FD</code>告诉子进程这个 IPC 通道的文件描述符.子进程在启动过程中,根据文件描述符去连接这个已存在的 IPC 通道,从而完成父子进程之间的连接</li></ul><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a87f3b25fee948d9bd65185da459ca06~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt=" "></p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">import</span> <span class="token punctuation">&#123;</span> fork <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">'child_process'</span><span class="token punctuation">;</span><span class="token comment">// 父进程</span><span class="token keyword">const</span> child3 <span class="token operator">=</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token string">'./child3.js'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>child3<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'message'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">m</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'message from child: '</span> <span class="token operator">+</span> <span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>child3<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span> from<span class="token operator">:</span> <span class="token string">'parent'</span> <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 子进程</span>process<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'message'</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">m</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'message from parent: '</span> <span class="token operator">+</span> <span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>process<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span> from<span class="token operator">:</span> <span class="token string">'child'</span> <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;异步流程&quot;&gt;&lt;a href=&quot;#异步流程&quot; class=&quot;headerlink&quot; title=&quot;异步流程&quot;&gt;&lt;/a&gt;异步流程&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;child_process.spawn(),child_process.fork(),child_</summary>
      
    
    
    
    <category term="process" scheme="http://mail.zyjcould.ltd/categories/process/"/>
    
    
    <category term="JS" scheme="http://mail.zyjcould.ltd/tags/JS/"/>
    
    <category term="node" scheme="http://mail.zyjcould.ltd/tags/node/"/>
    
  </entry>
  
  <entry>
    <title>process</title>
    <link href="http://mail.zyjcould.ltd/2022/05/09/process/"/>
    <id>http://mail.zyjcould.ltd/2022/05/09/process/</id>
    <published>2022-05-09T14:55:33.000Z</published>
    <updated>2022-05-10T08:38:42.340Z</updated>
    
    <content type="html"><![CDATA[<ul><li>参考:<a href="http://nodejs.cn/api/process.html#processexecargv">http://nodejs.cn/api/process.html#processexecargv</a></li></ul><h2 id="process"><a href="#process" class="headerlink" title="process"></a>process</h2><blockquote><p>process位于全局模块,不需要使用加载模块</p></blockquote><ul><li>process的主要事情<ol><li>获取进程信息(资源使用,运行环境,运行状态)</li><li>执行进程操作(监听事件,调度任务,发出警告)</li></ol></li></ul><h3 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h3><blockquote><p>menoryUsage():描述 Node.js 进程的内存使用情况</p></blockquote><pre class="line-numbers language-js" data-language="js"><code class="language-js">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>process<span class="token punctuation">.</span><span class="token function">memoryUsage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">// &#123;</span><span class="token comment">//   rss: 28729344,</span><span class="token comment">//   heapTotal: 8060928,</span><span class="token comment">//   heapUsed: 6062024,</span><span class="token comment">//   external: 976895,</span><span class="token comment">//   arrayBuffers: 17342</span><span class="token comment">// &#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>rss</code>,常驻集大小,是进程在主内存设备(即总分配内存的子集)中占用的空间量,包括所有<strong>C++<strong>和</strong>JavaScript</strong>对象和代码<ul><li><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/5/30/163b10282fbb4e46~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp" alt=" "></li></ul></li><li><code>heapTotal</code>和 heapUsed 指的是 V8 的内存使用量</li><li><code>external</code>指的是绑定到 V8 管理的 JavaScript 对象的 C++ 对象的内存使用量</li><li><code>arrayBuffers</code>:是指为<code>ArrayBuffer</code>和<code>SharedArrayBuffer</code>分配的内存,包括所有Node.js<code>Buffer</code>这也包含在<code>external</code>值中当Node.js被用作嵌入式库时,此值可能为0,因为在这种情况下可能不会跟踪<code>ArrayBuffer</code>的分配</li></ul><blockquote><p>cpuUsage():返回当前进程的用户和系统 CPU 时间使用情况</p></blockquote><ul><li>可以传入参数,参数时之前的<code>process.cpuUsage()</code></li></ul><pre class="line-numbers language-js" data-language="js"><code class="language-js">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>process<span class="token punctuation">.</span><span class="token function">cpuUsage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">//&#123; user: 62000, system: 78000 &#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="运行环境"><a href="#运行环境" class="headerlink" title="运行环境"></a>运行环境</h3><blockquote><p>cwd():返回 Node.js 进程的当前工作目录</p></blockquote><pre class="line-numbers language-js" data-language="js"><code class="language-js">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>process<span class="token punctuation">.</span>cwd<span class="token punctuation">)</span><span class="token comment">//E:\Project\hexoPage</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><blockquote><p>version:node版本信息</p></blockquote><pre class="line-numbers language-js" data-language="js"><code class="language-js">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>version<span class="token punctuation">)</span><span class="token comment">//v16.14.2</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>versions: 返回Node.js 的版本字符串及其依赖项</p></blockquote><pre class="line-numbers language-js" data-language="js"><code class="language-js">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>versions<span class="token punctuation">)</span><span class="token comment">// &#123;</span><span class="token comment">//   node: '16.14.2',</span><span class="token comment">//   v8: '9.4.146.24-node.20',</span><span class="token comment">//   uv: '1.43.0',</span><span class="token comment">//   zlib: '1.2.11',</span><span class="token comment">//   brotli: '1.0.9',</span><span class="token comment">//   ares: '1.18.1',</span><span class="token comment">//   modules: '93',</span><span class="token comment">//   nghttp2: '1.45.1',</span><span class="token comment">//   napi: '8',</span><span class="token comment">//   llhttp: '6.0.4',</span><span class="token comment">//   openssl: '1.1.1n+quic',</span><span class="token comment">//   cldr: '40.0',</span><span class="token comment">//   icu: '70.1',</span><span class="token comment">//   tz: '2021a3',</span><span class="token comment">//   unicode: '14.0',</span><span class="token comment">//   ngtcp2: '0.1.0-DEV',</span><span class="token comment">//   nghttp3: '0.1.0-DEV'</span><span class="token comment">// &#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>arch:返回当前操作系统的架构</p></blockquote><pre class="line-numbers language-js" data-language="js"><code class="language-js">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>process<span class="token punctuation">.</span>arch<span class="token punctuation">)</span><span class="token comment">//x64</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><blockquote><p>env:返回包含用户环境的对象</p></blockquote><pre class="line-numbers language-js" data-language="js"><code class="language-js">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>process<span class="token punctuation">.</span>env<span class="token punctuation">)</span><span class="token comment">//设置用户变量</span>process<span class="token punctuation">.</span>env<span class="token punctuation">.</span><span class="token constant">NODE_ENV</span> <span class="token operator">=</span> <span class="token string">'production'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p>platform:用户操作系统的平台</p></blockquote><pre class="line-numbers language-js" data-language="js"><code class="language-js">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>process<span class="token punctuation">.</span>platform<span class="token punctuation">)</span><span class="token comment">//win32</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="运行状态"><a href="#运行状态" class="headerlink" title="运行状态"></a>运行状态</h3><ul><li>运行状态指当前进程的运行相关的信息包括启动参数,执行目录,主文件,PID信息,运行时间</li></ul><blockquote><p>启动参数</p></blockquote><ul><li><code>argv</code>获取非命令行选项的所有信息</li><li><code>argv0</code>则获取argv[0]的值</li><li><code>execArgv</code>进程启动时传入的一组特定于 <code>Node.js</code> 的命令行选项.这些选项可用于衍生与父进程具有相同执行环境的子进程<ul><li>选项不会出现在<code>process.argv</code>属性返回的数组中,也不包括<code>Node.js</code><span style="color:red">可执行文件,脚本名称或脚本名称后面的任何选项</span></li></ul></li></ul><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token comment">// node --harmony a.js --version</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>process<span class="token punctuation">.</span>argv<span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>process<span class="token punctuation">.</span>argv0<span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>process<span class="token punctuation">.</span>execArgv<span class="token punctuation">)</span><span class="token comment">// [</span><span class="token comment">//   'E:\\envPath\\node\\node\\node.exe',</span><span class="token comment">//   'E:\\Project\\hexoPage\\a.js',</span><span class="token comment">//   '--version'</span><span class="token comment">// ]</span><span class="token comment">// E:\envPath\node\node\node.exe</span><span class="token comment">// [ '--harmony' ]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>execPath:执行目录</p></blockquote><pre class="line-numbers language-js" data-language="js"><code class="language-js">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>process<span class="token punctuation">.</span>execPath<span class="token punctuation">)</span><span class="token comment">// E:\envPath\node\node\node.exe</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><blockquote><p>uptime():运行时间</p></blockquote><pre class="line-numbers language-js" data-language="js"><code class="language-js">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>process<span class="token punctuation">.</span><span class="token function">uptime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">// 0.5094782</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="标准I-x2F-O流"><a href="#标准I-x2F-O流" class="headerlink" title="标准I&#x2F;O流"></a>标准I&#x2F;O流</h3><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><blockquote><p>pid:返回进程的ID名称</p><p>ppid:属性返回当前进程的父进程的ID名称</p></blockquote><pre class="line-numbers language-js" data-language="js"><code class="language-js">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>process<span class="token punctuation">.</span>pid<span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>process<span class="token punctuation">.</span>ppid<span class="token punctuation">)</span><span class="token comment">// 30316</span><span class="token comment">// 32772</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>exitCode:进程退出码的数字</p><p>exit([code]):以 code 的退出状态同步终止进程</p></blockquote><ul><li><code>exitCode</code>:当进程正常退出或通过<code>process.exit()</code>退出而不指定代码时,将作为进程退出码的数字<ul><li>将代码指定为<code>process.exit(code)</code>将覆盖<code>process.exitCode</code>的任何先前设置</li></ul></li><li><code>exit()</code>:以<code>code</code>的退出状态同步终止进程<ul><li>如果省略code,则退出将使用<strong>成功</strong>代码<code>0</code>或<code>process.exitCode</code>的值(如果已设置)</li><li>执行Node.js的<code>shell</code>应该看到退出码为 1</li><li>调用<code>process.exit()</code>将强制进程尽快退出,即使仍有未完全完成的异步操作挂起,包括对<code>process.stdout</code>和<code>process.stderr</code>的I&#x2F;O操作</li></ul></li></ul><blockquote><p>kill(pid[, signal])</p></blockquote><ul><li><p><code>pid</code>:进程标识</p></li><li><p><code>signal</code>:要发送的信号,可以是字符串或者数字.默认值<code>SIGTER</code></p></li><li><p>如果使用<code>pid</code>来杀死进程组,则<code>Windows</code>平台将抛出错误.它实际上只是信号发送者,发送信号可能是做其他事情,而不一定是杀死进程</p></li></ul><pre class="line-numbers language-JS" data-language="JS"><code class="language-JS">import process, &#123; kill &#125; from &#39;node:process&#39;process.on(&#39;SIGHUP&#39;, () &#x3D;&gt; &#123;  console.log(&#39;Got SIGHUP signal.&#39;)&#125;)setTimeout(() &#x3D;&gt; &#123;  console.log(&#39;Exiting.&#39;)  process.exit(0)&#125;, 100)kill(process.pid, &#39;SIGHUP&#39;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>title:返回当前进程的标题(即ps列出的值).</p></blockquote><ul><li>为<code>process.title</code>分配一个新值会修改ps的当前值</li></ul><pre class="line-numbers language-js" data-language="js"><code class="language-js">process<span class="token punctuation">.</span>title <span class="token operator">=</span> <span class="token string">"hhh"</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>process<span class="token punctuation">.</span>title<span class="token punctuation">)</span><span class="token comment">//hhh</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p>process.abort():立即退出,并生成核心文件</p></blockquote><pre class="line-numbers language-js" data-language="js"><code class="language-js">process<span class="token punctuation">.</span><span class="token function">abort</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>nextTick(callback[, …args])</p></blockquote><ul><li><code>callback</code>:需要传入的回调函数</li><li><code>...args</code>:回调函数需要传入的额外参数</li><li>在mjs的<code>eventloop</code>中<code>Promise</code>的执行顺序大于<code>nextTick</code></li><li>在cjs的<code>eventloop</code>中<code>Promise</code>的执行顺序小于<code>nextTick</code></li></ul><pre class="line-numbers language-js" data-language="js"><code class="language-js">process<span class="token punctuation">.</span><span class="token function">nextTick</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'nextTick'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span>Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'promise'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token function">queueMicrotask</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'queueMicrotask'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token comment">//mjs:promise>queueMicrotask>nextTick</span><span class="token comment">//cjs:nextTick>promise>queueMicrotask</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>queueMicrotask()</code>:使用<strong>微任务队列</strong>来执行回调函数.微任务队列会在Eventloop之前执行完,如果在Eventloop中加入微任务队列,会在下一次eventloop开头的时候执行完微任务队列<ul><li>setTimeout在第一次EventLoop阶段会等定时器结束将自己的回调放入timer中,等到下一次再执行</li><li>首先从上往下执行先将<code>p1</code>这个微任务放入微任务队列中,之后将<code>queueMicrotask</code>放入微任务</li><li>取出<code>p1</code>这个微任务执行<code>console</code>,里面的<code>q1</code>和<code>p2</code>,继续放入微任务队列,然后执行下一个微任务<code>queueMicrotask</code></li><li>…</li></ul></li></ul><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token comment">//mjs</span>process<span class="token punctuation">.</span><span class="token function">nextTick</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'nextTick'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span>Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"p1"</span><span class="token punctuation">)</span>  <span class="token function">queueMicrotask</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'q1'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">queueMicrotask</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'q2'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">)</span>  Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"p2"</span><span class="token punctuation">)</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token function">queueMicrotask</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'queueMicrotask'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'setTimeout'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token comment">// p1</span><span class="token comment">// queueMicrotask</span><span class="token comment">// q1</span><span class="token comment">// p2</span><span class="token comment">// q2</span><span class="token comment">// nextTick</span><span class="token comment">// setTimeout</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>尽量使用<code>queueMicrotask()</code>而不是<code>process.nextTick()</code></li></ul><h3 id="report"><a href="#report" class="headerlink" title="report"></a>report</h3><blockquote><p>一个对象,其方法用于为当前进程生成诊断报告</p></blockquote><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token punctuation">&#123;</span>  writeReport<span class="token operator">:</span> <span class="token punctuation">[</span>Function<span class="token operator">:</span> writeReport<span class="token punctuation">]</span><span class="token punctuation">,</span>  getReport<span class="token operator">:</span> <span class="token punctuation">[</span>Function<span class="token operator">:</span> getReport<span class="token punctuation">]</span><span class="token punctuation">,</span>  directory<span class="token operator">:</span> <span class="token punctuation">[</span>Getter<span class="token operator">/</span>Setter<span class="token punctuation">]</span><span class="token punctuation">,</span>  filename<span class="token operator">:</span> <span class="token punctuation">[</span>Getter<span class="token operator">/</span>Setter<span class="token punctuation">]</span><span class="token punctuation">,</span>  compact<span class="token operator">:</span> <span class="token punctuation">[</span>Getter<span class="token operator">/</span>Setter<span class="token punctuation">]</span><span class="token punctuation">,</span>  signal<span class="token operator">:</span> <span class="token punctuation">[</span>Getter<span class="token operator">/</span>Setter<span class="token punctuation">]</span><span class="token punctuation">,</span>  reportOnFatalError<span class="token operator">:</span> <span class="token punctuation">[</span>Getter<span class="token operator">/</span>Setter<span class="token punctuation">]</span><span class="token punctuation">,</span>  reportOnSignal<span class="token operator">:</span> <span class="token punctuation">[</span>Getter<span class="token operator">/</span>Setter<span class="token punctuation">]</span><span class="token punctuation">,</span>  reportOnUncaughtException<span class="token operator">:</span> <span class="token punctuation">[</span>Getter<span class="token operator">/</span>Setter<span class="token punctuation">]</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>compact</code>:默认值<code>false</code>:以紧凑的单行<code>JSON</code>格式编写报告</li><li><code>direction</code>:默认是<code>&#39;&#39;</code>,将report写入Node.js进程的当前工作目录</li><li><code>filename</code>:写入的文件名称</li><li><code>signal</code>:默认值<code>SIGUSR2</code>,用于触发诊断报告创建的信号</li><li><code>reportOnFatalError</code>:默认值<code>false</code>.根据致命错误（如内存不足错误或C++断言失败）生成诊断报告</li><li><code>reportOnSignal</code>:默认值<code>false</code>.在进程收到指定的信号时生成诊断报告</li><li><code>reportOnUncaughtException</code>:默认值<code>false</code>.在未捕获的异常时生成诊断报告</li><li><code>writeReport([filename][, err])</code>:该函数用于将report写入指定文件<ul><li><code>filename</code>写入report的文件名称</li><li><code>err</code>:报告JavaScript堆栈的自定义错误</li></ul></li><li><code>getReport([err])</code>:<ul><li><code>error</code>:如果存在,报告 JavaScript 堆栈的自定义错误出错的地方</li></ul></li></ul><pre class="line-numbers language-js" data-language="js"><code class="language-js">process<span class="token punctuation">.</span>report<span class="token punctuation">.</span>compact <span class="token operator">=</span> <span class="token boolean">true</span>process<span class="token punctuation">.</span>report<span class="token punctuation">.</span>directory <span class="token operator">=</span> <span class="token string">"./"</span>process<span class="token punctuation">.</span>report<span class="token punctuation">.</span><span class="token function">writeReport</span><span class="token punctuation">(</span><span class="token string">"report.json"</span><span class="token punctuation">)</span><span class="token comment">//写了filename就不需要传入文件名参数</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;参考:&lt;a href=&quot;http://nodejs.cn/api/process.html#processexecargv&quot;&gt;http://nodejs.cn/api/process.html#processexecargv&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2</summary>
      
    
    
    
    <category term="process" scheme="http://mail.zyjcould.ltd/categories/process/"/>
    
    
    <category term="JS" scheme="http://mail.zyjcould.ltd/tags/JS/"/>
    
    <category term="node" scheme="http://mail.zyjcould.ltd/tags/node/"/>
    
  </entry>
  
  <entry>
    <title>git回滚与撤销</title>
    <link href="http://mail.zyjcould.ltd/2022/04/30/git-hui-gun-yu-che-xiao/"/>
    <id>http://mail.zyjcould.ltd/2022/04/30/git-hui-gun-yu-che-xiao/</id>
    <published>2022-04-30T12:12:52.000Z</published>
    <updated>2022-04-30T16:09:03.787Z</updated>
    
    <content type="html"><![CDATA[<h2 id="撤销"><a href="#撤销" class="headerlink" title="撤销"></a>撤销</h2><ol><li><p>存在工作目录.代码并没有提交到暂存区(没有进行<code>git add</code>操作).在工作树中修改</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 需要撤销的文件或者 .(当前目录)</span><span class="token function">git</span> checkout <span class="token operator">&lt;</span>filname<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>代码提交到暂存区(进行了<code>git add</code>),但是想要撤销提交</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 需要从暂存区撤销的提交</span><span class="token function">git</span> reset HEAD <span class="token operator">&lt;</span>filename<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>代码已经提交(<code>git commit</code>)</p><ul><li>已经进行多次提交,但是在最后一次修改后,不再产生新的提交</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 注释名为最后一次的</span><span class="token function">git</span> commit --amend -m <span class="token string">"最后一次的注释"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ol><blockquote><p>如果想撤销到其中某次commit</p></blockquote><ul><li>这些操作分别是对<strong>工作目录</strong>,<strong>暂存区</strong>,<strong>当前HEAD</strong>的位置的改变</li><li><code>git reset [--hard|soft|mixed|merge|keep] [commit|HEAD]</code><ol><li><code>--hard</code>:重设当前<code>HEAD</code>位置.并将之前commit以来的<strong>工作区目录</strong>和<strong>暂存区</strong>的改变都丢弃<ul><li>彻底回退到某一个版本.本地所欲的源码也会变为上一个版本的内容</li><li>例如<code>git reset --hard HEAD~1</code>:将代码回退到前一次提交,并且将之前的所有改变丢弃</li></ul></li><li><code>--soft</code>:只重设当前<code>HEAD</code>位置.所有更改的文件会回到<strong>工作区目录</strong>和<strong>暂存区</strong><ul><li><code>git status</code>可以查看回退的状态.只是回退了提交的信息,不会回退提交的内容.</li></ul></li><li><code>--mixed</code>:重设当前<code>HEAD</code>位置和<strong>暂存区</strong>位置.但是不会重设<strong>工作区</strong>的内容<ul><li><code>git status</code>:查看回退的状态.已经回退到初始状态(没有使用<code>git add</code>之前)</li><li>例如<code>git reset --mixed HEAD~1</code>:将代码回退到上一次提交.提交内容保留在工作区</li></ul></li></ol></li></ul><h2 id="回滚"><a href="#回滚" class="headerlink" title="回滚"></a>回滚</h2><blockquote><p>如果已经使用<code>git push</code>,推送到远程仓库中.对已经提交到远程仓库的还原操作叫回滚</p></blockquote><ol><li>撤销本地仓库的提交<ul><li><code>revert</code>:放弃指定提交的修改,会生成一次新的提交,并且以前的历史记录都在<ul><li>例如:<code>git revert HEAD~1</code>.将代码回滚到上一次的提交,但是不会销毁之前提交,并且生成一个新的提交</li></ul></li><li><code>reset</code>:是指将HEAD指针指到指定提交,历史记录中不会出现放弃的提交记录(会销毁之前的提交)</li></ul></li><li>对远程仓库的提交进行回滚(撤销远程仓库的提交)<ul><li>需要强制将本地回退的代码推到远程仓库,进行回滚操作</li><li><code>git push origin 本地分支 --force-with-lease</code></li><li><code>--force-with-lease</code>并不会像<code>--force</code>强制将代码覆盖<ul><li>如果远端有其他人推送了新的提交,那么推送将被拒绝,并且和<code>--force</code>参数时的拒绝是一样的</li><li>如果远端没有其他人推送,会直接进行强制推送(<strong>回滚</strong>)</li></ul></li></ul></li></ol><blockquote><p>如果没有其他人推送提交时</p></blockquote><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> reset --hard HEAD~1<span class="token function">git</span> push origin 本地分支 --force-with-lease<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><blockquote><p>当遇到其他人推送新的提交时(产生冲突),需要使用<code>git fetch</code></p></blockquote><ul><li>在<code>git fetch</code>之后需要合并fetch下的分支.需要考虑使用<code>rebase</code>和<code>merge</code>情况<ul><li><code>rebase</code>会将分支合并到一个分支,不会保留被合并分支的提交记录.保证主分支的纯粹<ul><li><img src="./rebase.png" alt=" "></li></ul></li><li><code>merge</code>会将分支合并到一个分支,会保留被合并分支的提交记录<ul><li><img src="./merge.png" alt=" "></li></ul></li></ul></li><li>在开发中尽量选择rebase合并分支,来保证主分支的清晰</li><li>继续推送以达到回滚的效果</li></ul><h3 id="merge和rebase"><a href="#merge和rebase" class="headerlink" title="merge和rebase"></a>merge和rebase</h3><ul><li><code>rebase</code>:下游分支更新上游分支内容的时候使用</li><li><code>merge</code>:上游分支合并下游分支内容的时候使用</li><li><code>git pull origin dev --rebase</code>更新当前分支的内容时一定要使用<code>--rebase</code>参数</li></ul><blockquote><p>例如现有上游分支<code>master</code>,基于<code>master</code>分支拉出来一个开发分支<code>dev</code>,在<code>dev</code>上开发了一段时间后要把<code>master</code>分支提交的新内容更新到 <code>dev</code>分支</p><p>此时切换到<code>dev</code>分支,使用<code>git rebase master</code>等<code>dev</code>分支开发完成了之后,要合并到上游分支<code>master</code>上的时候,切换到<code>master</code>分支,使用<code>git merge dev</code></p></blockquote><h3 id="撤销回退"><a href="#撤销回退" class="headerlink" title="撤销回退"></a>撤销回退</h3><p><img src="./resetback.png" alt=" "></p><blockquote><p>如果在回退的时候回退过了怎么办</p></blockquote><ol><li><p>使用<code>git reflog</code>找到当前的提交记录的<code>commit</code>值(hash值)</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">bf75e3e <span class="token punctuation">(</span>HEAD -<span class="token operator">></span> dev, upstream/master, origin/test, origin/master, origin/dev, origin/HEAD<span class="token punctuation">)</span> HEAD@<span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">&#125;</span>: reset: moving to HEAD~1e87c01a HEAD@<span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">&#125;</span>: reset: moving to HEAD~4<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p><code>git checkout bf75e3e</code>.检出需要撤销到某一版本的提交</p></li><li><p><code>git branch mer</code>为需要找回的版本创建新分支</p></li><li><p><code>git branch dev</code>&amp;&amp;<code>git rebase mer</code>切换分支并且合并分支</p></li><li><p><code>git push origin dev --force-with-lease</code>.强制推送到远程仓库,完成撤销的回退</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;撤销&quot;&gt;&lt;a href=&quot;#撤销&quot; class=&quot;headerlink&quot; title=&quot;撤销&quot;&gt;&lt;/a&gt;撤销&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;存在工作目录.代码并没有提交到暂存区(没有进行&lt;code&gt;git add&lt;/code&gt;操作).在工作树中修改&lt;/p&gt;
&lt;p</summary>
      
    
    
    
    <category term="git" scheme="http://mail.zyjcould.ltd/categories/git/"/>
    
    
    <category term="git" scheme="http://mail.zyjcould.ltd/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>rollup</title>
    <link href="http://mail.zyjcould.ltd/2022/04/23/rollup/"/>
    <id>http://mail.zyjcould.ltd/2022/04/23/rollup/</id>
    <published>2022-04-23T12:32:33.000Z</published>
    <updated>2022-04-24T12:15:42.799Z</updated>
    
    <content type="html"><![CDATA[<h2 id="cli"><a href="#cli" class="headerlink" title="cli"></a>cli</h2><ul><li><code>-c == --config &lt;filname&gt;</code>,指定<code>rollup.config.js</code>配置文件</li><li><code>-i == --input &lt;dirname&gt;</code>:入口文件</li><li><code>-o == --file &lt;output&gt;</code>:单个输出文件</li><li><code>-f == --format &lt;format&gt;</code>:打包风格<ul><li>amd, cjs, es, iife, umd, system</li></ul></li><li><code>-d == --dir &lt;dirname&gt;</code>:将输出文件块打包到目录</li><li><code>-w == --watch</code>:执行监听</li><li><code>--environment &lt;values&gt;</code>:设置环境变量<ul><li><code>--envirment TEST:123</code>可以通过<code>process.env.TEST</code>来获取变量的值</li></ul></li><li><code>-p == --plugin &lt;plugin&gt;</code>:使用插件<ul><li>如果在项目中使用rollup,不使用全局的rollup命令.需要使用npx:<code>npx rollup -c rollup.config.js</code></li></ul></li></ul><h2 id="配置项"><a href="#配置项" class="headerlink" title="配置项"></a><a href="https://rollupjs.org/guide/en/#configuration-files">配置项</a></h2><ul><li>如果想要不同的配置文件,可以使用一个数组,在数组中配置各个对象</li></ul><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">export</span> <span class="token keyword">default</span><span class="token punctuation">[</span>  <span class="token punctuation">&#123;</span>input<span class="token operator">:</span><span class="token operator">...</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span>  <span class="token punctuation">&#123;</span>input<span class="token operator">:</span> <span class="token operator">...</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span>  <span class="token operator">...</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><ul><li>input:指定打包文件的入口</li><li>output:指定输出文件的出口</li></ul></blockquote><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">&#123;</span>  input<span class="token operator">:</span> <span class="token string">"./index.js"</span><span class="token punctuation">,</span>  output<span class="token operator">:</span> <span class="token punctuation">&#123;</span>    <span class="token comment">//直接指定输出的文件夹</span>    file<span class="token operator">:</span> <span class="token string">"./dist/bundle.js"</span><span class="token punctuation">,</span>    format<span class="token operator">:</span> <span class="token string">"es"</span><span class="token punctuation">,</span>    name<span class="token operator">:</span><span class="token string">"bundle"</span><span class="token punctuation">,</span>    banner<span class="token operator">:</span><span class="token string">"/* hello */"</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>name:示bundles(捆绑包)的全局变量名称.例如<code>iife</code>,<code>umd</code>是必要的.同一页面上的其他脚本可以使用此变量名称来访问捆绑包的导出</p></li><li><p>banner:打包文件在最上行的介绍</p></li><li><p><code>output:[&#123;&#125;,&#123;&#125;...]</code>,<code>input</code>也可以写成数组的形式</p></li></ul><blockquote><p>多入口打包:input写成数组的形式</p></blockquote><ul><li>input可以写成数组的形式也可以写成对象的形式</li></ul><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">&#123;</span>  input<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">"./index.js"</span><span class="token punctuation">,</span> <span class="token string">"./test.js"</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  plugins<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token function">json</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  output<span class="token operator">:</span> <span class="token punctuation">&#123;</span>    dir<span class="token operator">:</span> <span class="token string">"dist"</span><span class="token punctuation">,</span>    format<span class="token operator">:</span> <span class="token string">"cjs"</span><span class="token punctuation">,</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>plugins:使用插件.例如<code>@rollup/plugin-json</code></p></blockquote><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">&#123;</span>  <span class="token operator">...</span>  plugins<span class="token operator">:</span><span class="token punctuation">[</span><span class="token function">json</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span>  <span class="token operator">...</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>rollup的插件是按照数组的加载顺序加载的</li><li>对于希望将依赖打包进自己的项目时,需要使用<code>@rollup/plugin-node-resolve</code>插件.并且最好放在第一个位置<ul><li>如果打包的依赖是只支持es项目,那么会和<code>@rollup/plugin-node-resolve</code>产生冲突.这时候最好需要下载<code>@rollup/plugin-commonjs</code></li></ul></li></ul><pre class="line-numbers language-js" data-language="js"><code class="language-js">plugins<span class="token operator">:</span><span class="token punctuation">[</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">commonjs</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">json</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><p><code>externals</code>:如果不想要将某个依赖打包进某个项目中,可以使用<code>externals</code></p><ul><li>可以是一个对象或者是数组.如果是数组,<code>[&quot;react&quot;]</code>默认的名字是<code>[&quot;React&quot;]</code>.如果不是这样命名的内库,可以使用对象的形式<code>&#123;&quot;react&quot;:&quot;React&quot;&#125;</code></li></ul></li><li><p><code>output</code>中的plugins.在编译之后启动,而不是编译之前.一般用于压缩代码.</p><ul><li>例如:<code>rollup-plugin-terser</code></li></ul></li></ul><h3 id="alias"><a href="#alias" class="headerlink" title="alias"></a><a href="https://github.com/rollup/plugins/tree/master/packages/alias">alias</a></h3><blockquote><p>用于别名的映射</p></blockquote><h3 id="babel"><a href="#babel" class="headerlink" title="babel"></a><a href="https://github.com/rollup/plugins/tree/master/packages/babel">babel</a></h3><blockquote><p>用于打包项目</p></blockquote><h3 id="replace"><a href="#replace" class="headerlink" title="replace"></a><a href="https://github.com/rollup/plugins/tree/master/packages/replace">replace</a></h3><blockquote><p>打包时变量替换(只能是数字或者字符串)</p></blockquote><h3 id="typescript"><a href="#typescript" class="headerlink" title="typescript"></a><a href="https://github.com/rollup/plugins/tree/master/packages/typescript">typescript</a></h3><ul><li>使用typescript:<code>npm install @rollup/plugin-typescript tslib typescript --save-dev</code></li></ul><h3 id="eslint"><a href="#eslint" class="headerlink" title="eslint"></a><a href="https://github.com/rollup/plugins/tree/master/packages/eslint">eslint</a></h3><ul><li>使用eslint:<code>yarn add -D @rollup/plugin-eslint eslint</code></li><li>eslint的一些插件<ul><li>eslint-config-standard</li><li>eslint-plugin-import</li><li>eslint-plugin-promise</li><li>eslint-plugin-node</li></ul></li></ul><h3 id="image"><a href="#image" class="headerlink" title="image"></a><a href="https://github.com/rollup/plugins/tree/master/packages/image">image</a></h3><ul><li>显示图像的 Base64 编码表示形式</li><li>静态文件可以使用:<code>rollup-plugin-copy</code></li></ul><h3 id="strip"><a href="#strip" class="headerlink" title="strip"></a><a href="https://github.com/rollup/plugins/tree/master/packages/strip">strip</a></h3><ul><li>打包时删除类似<code>debugger</code>,<code>assert.equal</code>和<code>console.log</code>函数的语句和函数</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;cli&quot;&gt;&lt;a href=&quot;#cli&quot; class=&quot;headerlink&quot; title=&quot;cli&quot;&gt;&lt;/a&gt;cli&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;-c == --config &amp;lt;filname&amp;gt;&lt;/code&gt;,指定&lt;code&gt;rollup.c</summary>
      
    
    
    
    <category term="JS" scheme="http://mail.zyjcould.ltd/categories/JS/"/>
    
    
    <category term="JS" scheme="http://mail.zyjcould.ltd/tags/JS/"/>
    
    <category term="TS" scheme="http://mail.zyjcould.ltd/tags/TS/"/>
    
    <category term="config" scheme="http://mail.zyjcould.ltd/tags/config/"/>
    
    <category term="vue" scheme="http://mail.zyjcould.ltd/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>FLIP</title>
    <link href="http://mail.zyjcould.ltd/2022/04/19/flip/"/>
    <id>http://mail.zyjcould.ltd/2022/04/19/flip/</id>
    <published>2022-04-19T09:02:23.000Z</published>
    <updated>2022-04-19T11:50:41.639Z</updated>
    
    <content type="html"><![CDATA[<h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><blockquote><p><code>Element.getBoundingClientRect()</code>:返回元素的大小及其<strong>相对于视口</strong>的位置</p></blockquote><ul><li><p>如果是标准盒子模型,元素的尺寸等于<code>width/height + padding + border-width</code>的总和.如果<code>box-sizing: border-box</code>,元素的的尺寸等于<code>width/height</code>.</p></li><li><p><code>DOMRect</code>:返回一个DOMRect对象.(DOMRect)代表一个矩形,表示盒子的类型右返回它的属性和方法决定</p></li><li><p><img src="././rect.png" alt=" "></p></li><li><p><strong>原点</strong>:当前视口的左上角(0,0)</p><ul><li><code>x</code>:矩形盒子的左边框(border)距离视口的左边的距离(可能为负数:当视口在盒子右边的时候)</li><li><code>y</code>:矩形盒子的上边框距离视口上边的距离(可能为负数:当漱口在盒子下边的时候)</li><li><code>height</code>:矩形盒子的高度</li><li><code>width</code>:矩形盒子的宽度</li><li><code>left</code>:视口到矩形盒子左边框的距离</li><li><code>right</code>:视口到矩形盒子有边框的距离</li><li><code>top</code>:视口到矩形盒子上边框的距离</li><li><code>bottom</code>:视口到矩形盒子下边框的距离</li></ul></li></ul><blockquote><p><code>Element.getClientRects()</code>:方法返回一个指向客户端中每一个盒子的边界矩形的矩形集合</p></blockquote><ul><li>返回<code>ClientRectList</code>:这是一个DOMRect的集合对象,属性和<code>getBoundingClientRect()</code>返回的方法一样<ul><li>如果是块级元素,只会返回一个数组,数组的内容和<code>getBoundingClientRect</code>一样</li><li>实际上,该方法主要用于内联元素,内联元素有多少行,该方法返回的对象有多少个成员.这个方法主要用于判断<strong>行内元素</strong>是否换行,以及<strong>行内元素</strong>的每一行的位置偏移</li></ul></li></ul><blockquote><p><code>DocumentOrShadowRoot.elementFromPoint(x: number, y: number): Element</code>:方法返回给定坐标点下最上层的<code>element</code>元素</p></blockquote><ul><li><p><strong>DocumentOrShadowRoot</strong>为<code>document</code>或者<code>shadowRoot</code>的接口</p></li><li><p>如果指定的坐标点在文档的可视范围外,或者两个坐标都是负数,那么结果返回null</p></li><li><p>如果该位置有多个元素层叠,则返回最上层的元素</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;API&quot;&gt;&lt;a href=&quot;#API&quot; class=&quot;headerlink&quot; title=&quot;API&quot;&gt;&lt;/a&gt;API&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;Element.getBoundingClientRect()&lt;/code&gt;:返回元素的大小及</summary>
      
    
    
    
    <category term="JS" scheme="http://mail.zyjcould.ltd/categories/JS/"/>
    
    
    <category term="JS" scheme="http://mail.zyjcould.ltd/tags/JS/"/>
    
    <category term="HTML" scheme="http://mail.zyjcould.ltd/tags/HTML/"/>
    
  </entry>
  
  <entry>
    <title>Jest</title>
    <link href="http://mail.zyjcould.ltd/2022/04/16/jest/"/>
    <id>http://mail.zyjcould.ltd/2022/04/16/jest/</id>
    <published>2022-04-16T13:34:37.000Z</published>
    <updated>2022-04-17T06:46:25.700Z</updated>
    
    <content type="html"><![CDATA[<h2 id="初始化一个test项目"><a href="#初始化一个test项目" class="headerlink" title="初始化一个test项目"></a>初始化一个test项目</h2><ol><li><code>npm i jest -D</code>:下载jest测试框架</li><li><code>npx jest --init</code>.初始化一个jest测试文件<ul><li>测试文件可以是ts或者js结尾的<code>jest.config.(js|ts)</code></li></ul></li><li>在<code>package.json</code>的脚本中写入<code>&quot;test&quot;:&quot;jest&quot;</code>配置<ul><li>jest是test本项目中的所有目录的测试文件</li></ul></li></ol><blockquote><p>进行一个commonjs模块的测试</p></blockquote><ol><li><p><code>math.js</code>文件中写入如下待测试代码</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span> b</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">return</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">function</span> <span class="token function">minus</span><span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span> b</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">return</span> a <span class="token operator">-</span> b<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">function</span> <span class="token function">multi</span><span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span> b</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">return</span> a <span class="token operator">*</span> b<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">&#123;</span> add<span class="token punctuation">,</span> minus<span class="token punctuation">,</span> multi <span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><code>math.test.js</code>导入测试代码</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">const</span> <span class="token punctuation">&#123;</span> add<span class="token punctuation">,</span> minus<span class="token punctuation">,</span> multi <span class="token punctuation">&#125;</span> <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">"./math"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token string">"测试加法 3 + 3"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>  <span class="token function">expect</span><span class="token punctuation">(</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toBe</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token string">"测试减法 3 - 3"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>  <span class="token function">expect</span><span class="token punctuation">(</span><span class="token function">minus</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toBe</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token string">"测试乘法 3 * 3"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>  <span class="token function">expect</span><span class="token punctuation">(</span><span class="token function">multi</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toBe</span><span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>运行<code>npm run test</code>可以看到终端有成功运行的样式</p></li></ol><h2 id="jest-config"><a href="#jest-config" class="headerlink" title="jest config"></a>jest config</h2><ol><li><p>jest可以直接使用命令行参数<code>--config &lt;path/to/file.js|cjs|mjs|json&gt;</code></p></li><li><p>jest可以直接在<code>package.json</code>中配置文件</p><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token punctuation">&#123;</span>    <span class="token property">"jest"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>直接使用<code>jest.config.(js|ts)</code>文件,在文件中配置</p></li></ol><blockquote><p>有如下的选项</p></blockquote><ul><li><p><code>automock</code>:<code>bool</code>默认值false.将所有的导入模块都自动mock</p><ul><li>但是当源文件下有<strong>mocks目录</strong>时,会自动mock.核心模块,如fs不会默认fock,需要手动设置<code>jest.mobk(&quot;fs&quot;)</code></li></ul></li><li><p><code>bail</code>:<code>number|bppl</code>.默认值是0.bail选项可以让你配置jest在经历几次失败后停止运行测试</p></li><li><p><code>browser</code>:<code>bool</code>默认值false.解析模块中是否遵循<code>package.json</code>中的<code>browser</code>字段</p><ul><li>有些模块导出的版本会不一样,取决于是在<strong>Node</strong>中还是<strong>浏览器</strong>中进行操作</li></ul></li><li><p><code>cacheDirectory</code>:<code>string</code>.默认值**&#x2F;tmp&#x2F;&lt;path&gt;**.用来储存依赖信息缓存目录</p></li><li><p><code>clearMocks</code>:<code>bool</code>.<strong>默认值false</strong>.在每个而是前自动清理mock的调用和实例instance</p><ul><li>相当于在每一个test之前调用<code>jest.clearAllMocks</code>,但不会删除已经有的mock实现</li></ul></li><li><p><code>collectCoverage</code>: <code>bool</code><strong>默认值false</strong>.是否打开代码覆盖率信息</p></li><li><p><code>collectCoverageFrom</code>:<code>array</code>.<strong>默认值undefined</strong>.表明哪些文件需要收集.如果文件匹配就会手机作为<code>coverage</code>的基数</p><ul><li>收集根目录下所有的js,jsx文件,同时排除node_modules下的所有文件</li><li>并且此参数需要<code>collectCoverage</code>被设置成true</li></ul><pre class="line-numbers language-js" data-language="js"><code class="language-js">collectCoverageFrom<span class="token operator">:</span><span class="token punctuation">[</span><span class="token string">"**/*.&#123;js,jsx&#125;"</span><span class="token punctuation">,</span><span class="token string">"!**/node_modules/**"</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p><code>coverageDirectory</code>:<code>string</code>.<strong>默认值undefined</strong>,输出覆盖信息文件的目录名称</p></li><li><p><code>coveragePathIgnorePatterns</code>:<code>[array&lt;string&gt;]</code>.<strong>默认值[node_modules]</strong>.排除出coverage的文件列表.</p></li><li><p><code>coverageProvider</code>:<code>string</code>.有两个选项,<code>v8</code>或者是<code>babel</code>.声明到底用哪个provider来用于指导代码的覆盖测试</p></li><li><p><code>coverageThreshold</code>:<code>object</code>.<strong>默认值undefined</strong>.该阈值作为覆盖最小阈值来设置.</p><ul><li>可以被设置为<code>global</code>,或者是目录及文件路径</li><li>如果没有达到阈值,则jest失败,如果给了一个正数,就表示最小的百分比值</li></ul><pre class="line-numbers language-js" data-language="js"><code class="language-js">coverageThreshold<span class="token operator">:</span> <span class="token punctuation">&#123;</span>    global<span class="token operator">:</span> <span class="token punctuation">&#123;</span>      <span class="token string">"branches"</span><span class="token operator">:</span> <span class="token number">80</span><span class="token punctuation">,</span>      <span class="token string">"functions"</span><span class="token operator">:</span> <span class="token number">80</span><span class="token punctuation">,</span>      <span class="token string">"lines"</span><span class="token operator">:</span> <span class="token number">80</span><span class="token punctuation">,</span>      <span class="token string">"statements"</span><span class="token operator">:</span> <span class="token operator">-</span><span class="token number">10</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><code>dependencyExtractor</code>:<code>string</code>.<strong>默认值undefined</strong>.允许等地依赖提取器的使用,必须满足是一个node modules,同时导出的object中包含<code>extract</code>函数</p></li><li><p><code>displayName</code>:<code>string | object</code>.<strong>默认值undefined</strong>.允许在测试的时候打印显示标签.这里有多个repo和多个jest配置文件的时候很好用</p> <pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token comment">//string</span>displayName<span class="token operator">:</span> <span class="token string">'CLIENT'</span><span class="token comment">//object</span>displayName<span class="token operator">:</span> <span class="token punctuation">&#123;</span> name<span class="token operator">:</span> <span class="token string">'CLIENT'</span><span class="token punctuation">,</span> color<span class="token operator">:</span> <span class="token string">'blue'</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><code>errorOnDeprecated</code>:<code>bool</code>.<strong>默认值false</strong>.针对国企的API抛出提示性的错误</p></li><li><p><code>extensionsToTreatAsEsm</code>:<code>Array&lt;string&gt;.</code><strong>默认值[]</strong>.将mjs字段视作esm模块.</p><ul><li>如果有其他文件使用ESM运行,需要在此处指定其文件的扩展名称</li></ul> <pre class="line-numbers language-js" data-language="js"><code class="language-js">extensionsToTreatAsEsm<span class="token operator">:</span><span class="token punctuation">[</span><span class="token string">".ts"</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p><code>extraGlobals</code>:<code>array&lt;string&gt;</code><strong>默认值undefined</strong>.测试文件在<a href="https://nodejs.org/api/vm.html">vm</a>中运行,会减慢全局上下文的属性的调用速度</p></li><li><p><code>forceCoverageMatch</code>:<code>array&lt;string&gt;</code>.在收集代码覆盖率的时候,通常会忽略测试文件.使用此选项,可以在coverage包含被忽略的文件</p></li><li><p><code>globals</code>:<code>object</code>.<strong>默认值{}</strong>.全局变量,需要在所有的测试环境中都可以使用</p> <pre class="line-numbers language-js" data-language="js"><code class="language-js">globals<span class="token operator">:</span><span class="token punctuation">&#123;</span>  <span class="token string">"__DEV__"</span><span class="token operator">:</span><span class="token boolean">true</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p><code>rootDir</code>:<code>string</code>.默认值<strong>jest配置文件的根目录</strong>.如果未找到则为<code>pwd</code></p><ul><li>通常可以设置为<code>src</code>或者<code>lib</code>为根目录,对应于代码在存储库中的存储位置</li></ul></li><li><p><code>roots</code>:<code>array&lt;string&gt;</code>.<strong>默认值[“<rootDir>“]</strong>.Jest 应用于在其中搜索文件的目录路径列表</p><ul><li>根据<code>rootDir</code>决定根目录所在的位置</li></ul></li><li><p><code>moduleFileExtensions</code>:<code>array&lt;string&gt;</code>.<strong>默认值[“js”, “jsx”, “ts”, “tsx”, “json”, “node”]</strong></p><ul><li>模块使用的文件扩展数组.如果未指定文件扩展名的模块,则这些事jest将俺从左到有顺序查找的扩展名.建议将常用的扩展名放置左侧</li></ul></li><li><p><code>moduleNameMapper</code>:<code>object&lt;string,string | array&lt;string&gt;&gt;</code>.正则表达式到模块名称或模块名称数组的映射(设置别名)</p></li><li><p><code>modulePathIgnorePatterns</code>:<code>object&lt;string&gt;</code>.<strong>默认值[]</strong>.定模块的路径与任何模式匹配,则它在测试环境中将不可用</p><ul><li>一个正则表达式模式字符串数组,这些字符串与所有模块路径匹配,然后这些路径将被视为对模块加载程序<strong>可见</strong></li><li>这些模式字符串与完整路径匹配<code>[&quot;&lt;rootDir&gt;/build/&quot;]</code></li></ul></li><li><p><code>transform</code>:<code>[object&lt;string, pathToTransformer | [pathToTransformer, object]&gt;]</code>.默认值<code>&#123;&quot;\\.[jt]sx?$&quot;: &quot;babel-jest&quot;&#125;</code></p><ul><li>从正则表达式到转换器路径的映射.这些编译器将<code>JavaScript</code>的未来版本编译为当前版本,或者可以配合ts,webpack使用</li></ul></li><li><p><code>transformIgnorePatterns</code>:<code>array&lt;string&gt;</code>.文件路径与任何模式匹配的时候,忽略这些匹配的文件</p><ul><li><strong>默认值:[“&#x2F;node_modules&#x2F;“, “\.pnp\.[^\/]+$”]</strong></li></ul></li></ul><h2 id="jest中es-ts的配置项"><a href="#jest中es-ts的配置项" class="headerlink" title="jest中es,ts的配置项"></a>jest中es,ts的配置项</h2><blockquote><p><code>npx jest --coverage</code>代码覆盖率</p></blockquote><ul><li>代码覆盖率会在控制台显示一个图表信息.并且有一个默认叫做<code>coverage</code>的文件夹.文件夹中的html文件就是对覆盖率的阐述</li><li>覆盖率就是编写的测试代码对原来的功能代码的占比,全部test,则为100%</li><li><span style="color:red">在配置文件中,初始化的时可以开启代码覆盖率的选项</span>,而不必使用cli的时候添加<code>--coverage</code><ol><li><code>collectCoverage: true</code>:是否打开代码覆盖率</li><li><code>coverageDirectory: &quot;coverage&quot;</code>:代码覆盖率生成的文件目录名称.可以自定义</li><li><code>coverageProvider: &quot;v8&quot;</code>:有两个选项,<code>v8</code>或者是<code>babel</code>.声明到底用哪个provider来用于指导代码的覆盖测试</li></ol></li></ul><blockquote><p><a href="https://jestjs.io/docs/ecmascript-modules">配置esm模块进行测试</a></p></blockquote><ol><li><p>首先需要在<code>package.json</code>中加入<code>&quot;type&quot;:modules</code>.不需要改<code>.js</code>为<code>.mjs</code></p></li><li><p>对于<code>jest.config.js</code>文件,不能使用默认的<code>module.exports</code>导出</p><ul><li>需要使用esm的方式导出配置</li></ul><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">export</span> <span class="token keyword">default</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>执行需要使用<code>NODE_OPTIONS=--experimental-vm-modules</code>这种形式设置环境变量</p><ul><li>在脚本中配置此环境变量并没有成功</li><li>这里我是直接使用<code>NODE_OPTIONS=--experimental-vm-modules npx jest</code>命令来运行此测试</li></ul></li></ol><blockquote><p>如果是ts项目,建议直接使用vitest直接进行TDD开发</p></blockquote><ul><li>vitest基于vite开发,完全适用于<code>vite.config.ts</code>配置</li><li>下载<code>npm i vitest -D</code></li></ul><ol><li><p>基于<code>vite.config.ts</code>配置vitest</p><ul><li>如果你使用<code>vite</code>的<code>defineConfig</code>你还需要将三斜线指令写在配置文件的顶部</li></ul><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">&#x2F;&#x2F;&#x2F; &lt;reference types&#x3D;&quot;vitest&quot; &#x2F;&gt;import &#123; defineConfig &#125; from &#39;vite&#39;export default defineConfig(&#123;  test: &#123;    &#x2F;&#x2F; ...  &#125;,&#125;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>基于<code>vitest.config.ts</code>配置vitest.</p><ul><li>此优先级高于<code>vite.config.ts</code>,可以直接使用vitest中的<code>defineConfig</code>配置</li></ul><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">import &#123; defineConfig &#125; from &#39;vitest&#x2F;config&#39;export default defineConfig(&#123;  test: &#123;    &#x2F;&#x2F; ...  &#125;,&#125;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>排除默认选项,自己配置测试的选项</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">import &#123; configDefaults, defineConfig &#125; from &#39;vitest&#x2F;config&#39;export default defineConfig(&#123;  test: &#123;    exclude: [...configDefaults.exclude, &#39;packages&#x2F;template&#x2F;*&#39;],  &#125;,&#125;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;初始化一个test项目&quot;&gt;&lt;a href=&quot;#初始化一个test项目&quot; class=&quot;headerlink&quot; title=&quot;初始化一个test项目&quot;&gt;&lt;/a&gt;初始化一个test项目&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;code&gt;npm i jest -D&lt;/code&gt;:下</summary>
      
    
    
    
    <category term="config" scheme="http://mail.zyjcould.ltd/categories/config/"/>
    
    
    <category term="JS" scheme="http://mail.zyjcould.ltd/tags/JS/"/>
    
    <category term="config" scheme="http://mail.zyjcould.ltd/tags/config/"/>
    
  </entry>
  
  <entry>
    <title>npm中的bin</title>
    <link href="http://mail.zyjcould.ltd/2022/04/16/npm-zhong-de-bin/"/>
    <id>http://mail.zyjcould.ltd/2022/04/16/npm-zhong-de-bin/</id>
    <published>2022-04-16T06:54:05.000Z</published>
    <updated>2022-04-16T08:02:49.842Z</updated>
    
    <content type="html"><![CDATA[<h2 id="bin"><a href="#bin" class="headerlink" title="bin"></a>bin</h2><blockquote><p>bin文件是一个二进制的脚本文件</p></blockquote><ul><li><p>一般文件内会有以下的字样等等,这就是平时运行的脚本文件的解释程序(<code>Shebang</code>)</p><ul><li><code>#!/usr/bin/env node</code>这段话的意思就是启用node进行脚本的解释程序</li><li><code>#!/bin/sh</code>:使用sh进行脚本的执行程序</li><li>并且在windows中同样可以使用(windows会忽略shengban,会根据程序的脚本名来指定运行的解释程序)</li></ul></li><li><p>可以查看一下typescript中的脚本配置</p> <pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token property">"bin"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>    <span class="token property">"tsc"</span><span class="token operator">:</span> <span class="token string">"./bin/tsc"</span><span class="token punctuation">,</span>    <span class="token property">"tsserver"</span><span class="token operator">:</span> <span class="token string">"./bin/tsserver"</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ul><ol><li><p>创建一个node的项目并且创建一个bin目录(用于存放脚本文件)</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">.</span>├── bin│   └── vli.js├── index.js└── package.json<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>在<code>package.json</code>配置bin字段,用于打包生成脚本命令</p><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token property">"bin"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>  <span class="token property">"v-vli"</span><span class="token operator">:</span><span class="token string">"./bin/vli.js"</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>在脚本文件中写入需要的命令<code>vli.js</code></p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token hashbang comment">#!/usr/bin/env node</span><span class="token keyword">function</span> <span class="token function">run</span> <span class="token punctuation">(</span><span class="token parameter">argv</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token string">'-v'</span> <span class="token operator">||</span> argv<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token string">'--version'</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'  version is 0.0.1'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token string">'-h'</span> <span class="token operator">||</span> argv<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token string">'--help'</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'  usage:\n'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'  -v --version [show version]'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token function">run</span><span class="token punctuation">(</span>process<span class="token punctuation">.</span>argv<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>打成全局包才可以使用该命令,打成全局包的命令<code>npm install . -g</code>或者<code>npm link</code></p></li><li><p>使用<code>v-cli -v</code>就可以查看输出的脚本命令了</p></li></ol><h2 id="npm-link"><a href="#npm-link" class="headerlink" title="npm link"></a>npm link</h2><blockquote><p><code>npm link</code>将npm模块链接到对应的运行项目中去,方便地对模块进行调试和测试</p></blockquote><ol><li>如果他是一个<code>bin</code>(二进制文件):他会被链接到全局的<code>&#123;prefix&#125;/bin</code>目录(node的全局目录)下,生成一个脚本文件,供全局使用</li><li>如果他是一个<code>lib</code>(库文件),他会被连接到<code>&#123;prefix&#125;/lib/node_modules/&lt;package&gt;</code>(node的全局目录),生成一个链接文件</li><li>一个文件项目中可能包含多个bin文件,一般通常只有一个lib文件</li></ol><ul><li>通过<code>npm config get prefix</code>命令获取到prefix的值</li></ul><blockquote><p><code>npm unlink &lt;package&gt;</code>:解除链接</p></blockquote><ol><li>如果是bin文件,解除的是bin配置的脚本名称,而不是项目的包名<ul><li>例如上面的脚本<code>npm unlink v-vli</code>.将全局的<code>v-vli</code>脚本移除</li></ul></li><li>如果是<code>lib</code>文件,他本质就是一个软链接,直接移除项目的包名<ul><li><code>npm unlink &lt;package&gt;</code>:将lib下的全局链接移除</li></ul></li></ol><blockquote><p>例子:例如需要开发一个module模块,并且在本地example项目中需要使用module包</p></blockquote><ol><li>在<code>module</code>中使用<code>npm link</code>被链接到全局的lib目录下</li><li>在<code>example</code>项目中使用<code>npm link module</code>后,此项目会软链接到<code>example/node_modules</code></li><li>这种软链接的形式,在module的修改同样会同步到<code>example/modules</code>中的软链接部分</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;bin&quot;&gt;&lt;a href=&quot;#bin&quot; class=&quot;headerlink&quot; title=&quot;bin&quot;&gt;&lt;/a&gt;bin&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;bin文件是一个二进制的脚本文件&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;一般文件内会</summary>
      
    
    
    
    <category term="config" scheme="http://mail.zyjcould.ltd/categories/config/"/>
    
    
    <category term="JS" scheme="http://mail.zyjcould.ltd/tags/JS/"/>
    
    <category term="config" scheme="http://mail.zyjcould.ltd/tags/config/"/>
    
    <category term="npm" scheme="http://mail.zyjcould.ltd/tags/npm/"/>
    
  </entry>
  
  <entry>
    <title>发布npm</title>
    <link href="http://mail.zyjcould.ltd/2022/04/15/fa-bu-npm/"/>
    <id>http://mail.zyjcould.ltd/2022/04/15/fa-bu-npm/</id>
    <published>2022-04-15T14:32:15.000Z</published>
    <updated>2022-04-22T14:17:22.888Z</updated>
    
    <content type="html"><![CDATA[<h2 id="字段"><a href="#字段" class="headerlink" title="字段"></a>字段</h2><ol><li><p>首先需要登录自己的npm账号<code>npm login</code></p></li><li><p>初始化一个项目<code>npm init</code></p><ul><li>最重要的两个字段<code>name</code>和<code>version</code></li></ul><blockquote><p><code>name</code></p></blockquote><ul><li>不要在name中包含js,node字样</li><li>这个名字最终会是URL的一部分,命令行的参数,目录名,所以不能以点号或下划线开头</li><li>这个名字可能在require()方法中被调用,所以应该尽可能短</li><li>并且包的名字不能与npm中的其他包的名字一致</li></ul><blockquote><p><code>version</code>:版本号.版本号基本是由三位数字组成</p></blockquote><ul><li><code>MAJOR</code>:进行不兼容的API更改时的版本</li><li><code>MINOR</code>:以向后兼容的方式添加功能时的版本</li><li><code>PATCH</code>:向后兼容的错误修复程序的版本</li></ul><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token number">1</span>   .   <span class="token number">0</span>   .   <span class="token number">0</span><span class="token punctuation">[</span>MAJOR<span class="token punctuation">]</span>.<span class="token punctuation">[</span>MINOR<span class="token punctuation">]</span>.<span class="token punctuation">[</span>PATCH<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">npm</span> version <span class="token punctuation">[</span><span class="token operator">&lt;</span>newversion<span class="token operator">></span> <span class="token operator">|</span> major <span class="token operator">|</span> minor <span class="token operator">|</span> patch <span class="token operator">|</span> premajor <span class="token operator">|</span> preminor <span class="token operator">|</span> prepatch <span class="token operator">|</span> prerelease <span class="token punctuation">[</span>--preid-<span class="token operator">&lt;</span>prerelease-id<span class="token operator">></span><span class="token punctuation">]</span> <span class="token operator">|</span> from-git<span class="token punctuation">]</span><span class="token string">'npm [-v | --version]'</span> to print <span class="token function">npm</span> version<span class="token string">'npm view &lt;pkg> version'</span> to view a package<span class="token string">'s published version'</span><span class="token function">npm</span> ls' to inspect current package/dependency versions<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><table><thead><tr><th>选项</th><th>描述</th><th>例子</th><th>说明</th></tr></thead><tbody><tr><td>major</td><td>重大更新版本</td><td>npm version major</td><td>0.2.0 -&gt;1.0.0</td></tr><tr><td>minor</td><td>主要更新版本</td><td>npm version minor</td><td>0.2.0 -&gt;0.3.0</td></tr><tr><td>patch</td><td>补丁更新版本</td><td>npm version patch</td><td>0.2.0 -&gt;0.2.1</td></tr><tr><td>premajor</td><td>重大更新预发布版本</td><td>npm version premajor</td><td>0.2.0 -&gt;1.0.0-0</td></tr><tr><td>preminor</td><td>主要更新预发布版本</td><td>npm version preminor</td><td>0.2.0 -&gt;0.3.0-0</td></tr><tr><td>prepatch</td><td>补丁更新预发布版本</td><td>npm version prepatch</td><td>0.2.0 -&gt;0.2.1-0</td></tr><tr><td>prerelease</td><td>预发布版本</td><td>npm version prerelease</td><td>当前版本不是预发布版本的会出错</td></tr><tr><td>from-git</td><td>取git的tag作为版本号设置至<code>package.json</code></td><td>npm version from-git</td><td>git的tag标签没有设置的情况下,会抛出错误</td></tr></tbody></table><blockquote><p><code>description</code>:对包进行描述,便于<code>npm search</code></p><p><code>repository</code>:本项目中代码的源地址位置</p></blockquote><ol><li><p>可以分层写出项目地址</p><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token punctuation">&#123;</span>  <span class="token property">"repository"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>    <span class="token property">"type"</span><span class="token operator">:</span> <span class="token string">"git"</span><span class="token punctuation">,</span>    <span class="token property">"url"</span><span class="token operator">:</span> <span class="token string">"https://github.com/npm/cli.git"</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>同时可以指定仓库名的形式</p><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token punctuation">&#123;</span>  <span class="token property">"repository"</span><span class="token operator">:</span> <span class="token string">"npm/npm"</span><span class="token punctuation">,</span>  <span class="token property">"repository"</span><span class="token operator">:</span> <span class="token string">"github:user/repo"</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ol><blockquote><p><code>keywords</code>:将关键字放入其中.它是一个字符串数组.便于使用<code>npm search</code></p></blockquote><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token punctuation">&#123;</span>   <span class="token property">"keywords"</span><span class="token operator">:</span> <span class="token punctuation">[</span>   <span class="token string">"test"</span><span class="token punctuation">,</span>   <span class="token string">"npm"</span><span class="token punctuation">,</span>   <span class="token string">"app"</span>   <span class="token punctuation">]</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><code>homepage</code>:项目的主页.用于展示项目</p></blockquote><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token property">"homepage"</span><span class="token operator">:</span> <span class="token string">"https://github.com/owner/project#readme"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p><code>main</code>:程序的主要入口点.一般用于require的引入</p></blockquote><ul><li>也就是说,如果您的包被命名为foo,并且用户安装了它,然后会执行<code>require(&quot;foo&quot;)</code>,则将返回主模块的exports 对象</li></ul><blockquote><p><code>module</code>:一般是esm模块的入口点,用于import的引入</p></blockquote><ul><li>如果包module被命名为foo,用户安装之后,然后执行<code>import...from &quot;foo&quot;</code>,会返回主模块</li></ul><blockquote><p><code>author</code>:作者信息</p></blockquote><ol><li><p>每个字段的形式分开展现</p><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token punctuation">&#123;</span>  <span class="token property">"name"</span> <span class="token operator">:</span> <span class="token string">"Barney Rubble"</span><span class="token punctuation">,</span>  <span class="token property">"email"</span> <span class="token operator">:</span> <span class="token string">"b@rubble.com"</span><span class="token punctuation">,</span>  <span class="token property">"url"</span> <span class="token operator">:</span> <span class="token string">"http://barnyrubble.tumblr.com/"</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>以<code>author</code>合并展示</p><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token punctuation">&#123;</span>  <span class="token property">"author"</span><span class="token operator">:</span> <span class="token string">"Barney Rubble &lt;b@rubble.com> (http://barnyrubble.tumblr.com/)"</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ol><blockquote><p><code>license</code>:许可证.让人知道使用的权利和限制的</p></blockquote><ul><li><a href="https://docs.github.com/en/communities/setting-up-your-project-for-healthy-contributions/adding-a-license-to-a-repository">参考github</a></li></ul></li></ol><h3 id="发布javascript版本的包"><a href="#发布javascript版本的包" class="headerlink" title="发布javascript版本的包"></a>发布javascript版本的包</h3><ol><li><p><code>name</code>:字段必须是仓库拥有者的名称,即<code>npm login</code>的名称</p><ul><li>由于作用域内包安装到作用域文件夹中,因此在代码中需要作用域时,必须包含作用域的名称</li><li>每个 npm 用户&#x2F;组织都有自己的作用域,只有你可以在作用域中添加包</li></ul><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'@myorg/mypackage'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p><code>npm publish</code>:npm中发布<strong>公共的作用域包</strong>需要使用<code>npm publish --access=public</code>(私有是收费的)</p></li><li><p><code>npm unpublish 包名</code>:即可将 npm 上的包删除</p></li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">npm</span> publish <span class="token punctuation">[</span><span class="token operator">&lt;</span>tarball<span class="token operator">>|</span><span class="token operator">&lt;</span>folder<span class="token operator">></span><span class="token punctuation">]</span> <span class="token punctuation">[</span>--tag <span class="token operator">&lt;</span>tag<span class="token operator">></span><span class="token punctuation">]</span> <span class="token punctuation">[</span>--access <span class="token operator">&lt;</span>public<span class="token operator">|</span>restricted<span class="token operator">></span><span class="token punctuation">]</span> <span class="token punctuation">[</span>--otp otpcode<span class="token punctuation">]</span> <span class="token punctuation">[</span>--dry-run<span class="token punctuation">]</span>Publishes <span class="token string">'.'</span> <span class="token keyword">if</span> no argument suppliedSets tag <span class="token string">'latest'</span> <span class="token keyword">if</span> no --tag specified<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>&lt;folder&gt;</code>:包含<code>package.json</code>文件的文件夹</li><li><code>&lt;tarball&gt;</code>:指向gzip压缩tar存档的url或文件路径,其中包含一个包含package.json文件的文件夹.</li><li><code>[--tag &lt;tag&gt;]</code>:使用给定标记注册已发布的包,以便安装此版本.默认情况下,更新并安装标记(参考<code>npm-dist-tag</code>)</li><li><code>[--access &lt;public|restricted&gt;]</code>:告知注册表此包是应发布为公共包还是受限制程序包.仅适用于作用域内包,缺省为<code>restricted --access</code>.如果没有付费帐户,则必须发布<code>public</code>方式才能发布作用域内的程序包.</li><li><code>[--otp &lt;otpcode&gt;]</code>:启用了双因素身份验证,则可以使用此代码提供来自身份验证器的代码.否则系统将提示<code>auth-and-writes</code></li><li><code>[--dry-run]</code>:截至npm@6,除了实际发布到注册表之外,是否所有发布都会执行.报告将要发布的内容的详细信息.</li><li><code>[--workspaces]</code>:在发布时启用工作区上下文.将发布所有工作区包.</li><li><code>[--workspace]</code>:启用工作区上下文,并将结果限制为此配置项指定的结果.将仅发布给定工作区中的包.</li></ul><blockquote><p>发布一个公共的包,不包含私有作用域</p></blockquote><ol><li>设置npm的proxy代理<code>npm config set proxy=&quot;代理地址(如127.0.0.1:7890)&quot;</code></li><li>检查自己的包名,不能与其他人的包名一样</li><li>使用<code>npm publish</code>发布自己的包</li></ol><h3 id="打包typescript版本的包"><a href="#打包typescript版本的包" class="headerlink" title="打包typescript版本的包"></a>打包typescript版本的包</h3><ol><li>下载<code>npm install typescript -D</code></li><li>初始化一个<code>tsconfig.json</code>文件<code>tsc --init</code></li><li>在scripts中添加脚本:<code>npx tsc -p .</code>.打包当前目录下的所有文件</li></ol><blockquote><p>一些typescript中特有的配置</p></blockquote><ol><li><p><code>package.json</code>中的<code>types</code>字段</p><ul><li>这是一个只在TypeScript中生效的字段,如果您的包有一个main.js文件,您还需要在<code>package.json</code>文件中指明主声明文件.将types属性设置为指向捆绑(bundled指main.js)的声明文件</li></ul><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token punctuation">&#123;</span>  <span class="token property">"types"</span><span class="token operator">:</span> <span class="token string">"./lib/main.d.ts"</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p><code>package.json</code>中的<code>typesVersions</code>字段</p><ul><li>控制typescript的版本号</li></ul> <pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token property">"typesVersions"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>    <span class="token property">">=3.1"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span> <span class="token property">"*"</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">"ts3.1/*"</span><span class="token punctuation">]</span> <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>在<code>.d.ts</code>文件中的<code>/// &lt;reference types=&quot;...&quot; /&gt;</code></p><ul><li>当前库依赖于全局库,会导入全局库的<code>.d.ts</code>的名称</li><li>在声明文件里包含<code>/// &lt;reference types=&quot;node&quot; /&gt;</code>，表明这个文件使用了<code>@types/node/index.d.ts</code>里面声明的名字.并且,这个包要在编译阶段与声明文件一起被包含进来</li><li>解析@types包的名字的过程与解析import语句里模块名的过程类似.所以可以简单的把三斜线类型引用指令想像成针对包的import声明</li><li>对于那些<strong>在编译阶段生成的声明文件</strong>,编译器会自动地添加<code>/// &lt;reference types=&quot;...&quot; /&gt;</code>;当且仅当结果文件中使用了引用的<code>@types</code>包里的声明时才会在生成的声明文件里添加<code>/// &lt;reference types=&quot;...&quot; /&gt;</code>语句</li></ul></li></ol><blockquote><p>配置<code>tsconfig.json</code>.</p></blockquote><ol><li>初始化一个tsconfig.json文件:<code>npx tsc --init</code></li><li>介绍几个重要的配置项<ul><li><code>target</code>: 将项目打包成目标兼容的版本</li><li><code>module</code>: 指定要用的模块化标准</li><li><code>lib</code>: lib用于指定要包含在编译中的库文件<ul><li>例如dom中的一些类型所需要的声明文件.或者使用<code>Array&lt;T&gt;</code>指定数组类型</li><li><a href="https://stackoverflow.com/questions/43874096/difference-in-the-lib-property-in-tsconfig-json-between-es6-and-es2017">可以看下这篇文章</a></li></ul></li><li><code>declaration</code>: 为ts或者js项目生成定义文件(<code>.d.ts</code>)</li><li><code>sourceMap</code>: 为源码生成映射文件,方便调试</li><li><code>rootDir</code>: 指定根目录的源文件位置</li><li><code>outDir</code>: 指定根目录的打包位置</li><li><code>esModuleInterop</code>: 是commonjs模块兼容esm模块(意味着两者的方式都可以导出)<ul><li>参考:<a href="https://zhuanlan.zhihu.com/p/148081795">https://zhuanlan.zhihu.com/p/148081795</a></li></ul></li></ul></li></ol><ul><li>最终形成的tsconfig.json文件</li></ul><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token punctuation">&#123;</span>  <span class="token property">"compilerOptions"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>    <span class="token property">"target"</span><span class="token operator">:</span> <span class="token string">"es2016"</span><span class="token punctuation">,</span>      <span class="token property">"module"</span><span class="token operator">:</span> <span class="token string">"CommonJS"</span><span class="token punctuation">,</span>                                    <span class="token property">"rootDir"</span><span class="token operator">:</span> <span class="token string">"./src"</span><span class="token punctuation">,</span>                                     <span class="token property">"declaration"</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>                                  <span class="token property">"sourceMap"</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>                                    <span class="token property">"outDir"</span><span class="token operator">:</span> <span class="token string">"./dist"</span><span class="token punctuation">,</span>     <span class="token property">"esModuleInterop"</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>                                 <span class="token property">"forceConsistentCasingInFileNames"</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>               <span class="token property">"strict"</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>    <span class="token property">"skipLibCheck"</span><span class="token operator">:</span> <span class="token boolean">true</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>对于<code>package.json</code>文件最好把项目放置在源文件<code>src</code>中,此时只需要配置打包生成的目录上传包就可以了</li></ul><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token property">"main"</span><span class="token operator">:</span> <span class="token string">"dist/index.js"</span><span class="token punctuation">,</span><span class="token property">"types"</span><span class="token operator">:</span> <span class="token string">"dist/index.d.ts"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;字段&quot;&gt;&lt;a href=&quot;#字段&quot; class=&quot;headerlink&quot; title=&quot;字段&quot;&gt;&lt;/a&gt;字段&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;首先需要登录自己的npm账号&lt;code&gt;npm login&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;初始化一个项目</summary>
      
    
    
    
    <category term="config" scheme="http://mail.zyjcould.ltd/categories/config/"/>
    
    
    <category term="JS" scheme="http://mail.zyjcould.ltd/tags/JS/"/>
    
    <category term="config" scheme="http://mail.zyjcould.ltd/tags/config/"/>
    
    <category term="npm" scheme="http://mail.zyjcould.ltd/tags/npm/"/>
    
  </entry>
  
  <entry>
    <title>video</title>
    <link href="http://mail.zyjcould.ltd/2022/04/06/video/"/>
    <id>http://mail.zyjcould.ltd/2022/04/06/video/</id>
    <published>2022-04-06T03:52:39.000Z</published>
    <updated>2022-04-06T13:43:04.462Z</updated>
    
    <content type="html"><![CDATA[<h2 id="video标签"><a href="#video标签" class="headerlink" title="video标签"></a>video标签</h2><blockquote><p>&lt;video&gt;实现了HTMLVideoElement这个接口.该接口继承了<code>HTMLMediaElement</code>和<code>HTMLElement</code>的属性和方法</p></blockquote><ul><li>浏览器并不都是支持相同的视频格式,你可以在&lt;source&gt;中提供多个源,浏览器会使用他所支持的那个<ul><li>&lt;video&gt;标签的中间内容,是针对浏览器不支持此内容的降级处理</li></ul></li></ul><blockquote><p>&lt;video&gt;标签的属性</p></blockquote><ol><li><code>src</code>:该属性指向你想要嵌入的网页当中的视频,与&lt;img&gt;标签的src相同</li><li><code>width</code>和<code>height</code>:设置视频的宽度和高度</li><li><code>controls</code>:<code>bool</code>.浏览器提供的控件界面,用户可以通过控件视频的回放功能</li><li><code>autoplay</code>:<code>bool</code>.设置此元素视频会自动播放.但是也必须设置<code>muted</code></li><li><code>muted</code>:<code>bool</code>.默认值是false,意味着视频播放的时候音频也会播放.设置为true,音频会初始化为静音<ul><li>浏览器为了用户的体验考虑,限制了音视频的自动播放,最大限度地减少广告或者噪音等骚扰</li></ul></li><li><code>loop</code>:<code>bool</code>.指定后,会在视频结尾的地方自动返回视频开始的地方</li><li><code>poster</code>:视频播放前显示的图像.封面图像</li><li><code>preload</code>:浏览器是否需要缓存该视频<ul><li><code>none</code>:浏览器不会缓存该视频</li><li><code>auto</code>:当页面加载后缓存该视频</li><li><code>metadata</code>:仅缓存原视频的数据</li></ul></li><li><code>controlslist</code>(实验):用户在显示其自己的控件集时选择要在媒体元素上显示的控件<ul><li><code>nodownload</code>:禁止下载.隐藏下载的小控件</li><li><code>nofullscreen</code>:隐藏全屏小控件</li><li><code>noremoteplayback</code>:隐藏小窗口控件</li></ul></li></ol><h3 id="HTMLVideoElement"><a href="#HTMLVideoElement" class="headerlink" title="HTMLVideoElement"></a>HTMLVideoElement</h3><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>pay<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>开始播放<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>pau<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>暂停播放<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>video</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>video<span class="token punctuation">"</span></span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>https://zyjcould.ltd/mv/player.mp4<span class="token punctuation">"</span></span> <span class="token attr-name">height</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>300px<span class="token punctuation">"</span></span> <span class="token attr-name">controls</span> <span class="token attr-name">autoplay</span> <span class="token attr-name">muted</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>video</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p>该接口提供了用于操作视频对象的特殊属性和方法</p></blockquote><ul><li>由于不同的浏览器会支持不同的媒体格式.因此在提供媒体文件的时候,提供一种所有浏览器都支持的格式,或者提供格式不同的多个视频源来支持不同浏览器.</li></ul><blockquote><p>除了继承父对象<code>HTMLMediaElement</code>的属性之外,同时自己也实现了自身的属性</p></blockquote><ol><li><code>height,width,preload</code>:看上文</li><li><code>videoWidth,videoHeight</code>:只读.以<code>css pixels</code>单位给出的视频资源本身的大小.这个值考虑了大小,对比度,明度等等.而height,width只给出视频显示区域的大小</li></ol><h4 id="HTMLMediaElement对象的属性"><a href="#HTMLMediaElement对象的属性" class="headerlink" title="HTMLMediaElement对象的属性"></a><code>HTMLMediaElement</code>对象的属性</h4><ul><li>除了支持<strong>src,controls,autoplay,muted,loop,poster等</strong>之外还支持以下属性(并不完全)</li><li>详细请看:<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/HTMLMediaElement">https://developer.mozilla.org/zh-CN/docs/Web/API/HTMLMediaElement</a></li></ul><ol><li><p><code>duration</code>:只读.媒体以秒为单位的总长度时间.视频的总时长</p><ul><li>如果媒体不可用,则为0</li><li>如果媒体可用,但时间长度未知,值为NAN(可能未完全加载媒体)</li><li>如果媒体是以stream形式传输并且没有预定长度,则值为Inf</li></ul><pre class="line-numbers language-js" data-language="js"><code class="language-js">video<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">"loadeddata"</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>target<span class="token punctuation">.</span>duration<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p><code>currentTime</code>:获取当前位置的播放时间,或者设置从某个位置开始播放</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">video<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">"loadeddata"</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>target<span class="token punctuation">.</span>currentTime <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//0</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p><code>volume</code>:音量.表示音频的音量.值从0.0(静音)到1.0(最大音量)</p><ul><li><code>muted</code>属性和<code>volume</code>属性没有关联关系,改变其中一个值另一个也不会改变</li></ul><pre class="line-numbers language-js" data-language="js"><code class="language-js">video<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">"loadeddata"</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>target<span class="token punctuation">.</span>volume<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//1</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p><code>ended</code>:只读.表示媒体是否已经播放完毕</p></li><li><p><code>error</code>:只读,返回一个<a href="https://developer.mozilla.org/en-US/docs/Web/API/MediaError"><code>MediaError</code></a>.表示对象最近的错误,没有错误返回error</p></li><li><p><code>paused</code>:指示媒体元素是否被暂停</p></li><li><p><code>defaultPlaybackRate</code>:控制媒体的播放速度.</p><ul><li>1.0表示正常的播放速度,如果值小于1.0,则播放速度会比”正常速度”慢,如果值大于1.0,则播放速度会比”正常速度”快</li><li>如果是<code>0.0</code>是一个无效的值,并且会抛出错误</li></ul></li></ol><blockquote><p><code>TimeRangs</code>:该接口用来表示一组时间范围,主要目的是跟踪供&lt;audio&gt;和&lt;video&gt;元素加载使用的媒体哪些部分已经被缓冲</p></blockquote><ul><li><p>一个TimeRangs对象包括一个或多个时间范围,其中每个都由一个开始偏移量和结束偏移量指定</p><ul><li>可以将你想要检索的时间范围的索引值传递给end()和start()方法来引用每个时间范围</li></ul></li><li><p>视频一般情况下只有一个时间段,即<code>TimeRanges.length</code>值为1;如果进行了跳跃观看(例如3-&gt;4分钟这个时间段),并且跳跃内容并没有缓冲完毕,则会出现两个时间段,这时TimeRanges的length为2</p><ul><li>TimeRanges个数会随着跳跃观看未缓冲完成的内容而增加,随着缓冲的完成而减少,最少为1个,即从开头到结尾</li><li>参考:<a href="https://developer.mozilla.org/zh-CN/docs/Web/Guide/Audio_and_video_delivery/buffering_seeking_time_ranges">https://developer.mozilla.org/zh-CN/docs/Web/Guide/Audio_and_video_delivery/buffering_seeking_time_ranges</a></li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">------------------------------------------------------<span class="token operator">|</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">=</span><span class="token operator">|</span>                    <span class="token operator">|</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">=</span><span class="token operator">|</span>     <span class="token operator">|</span>------------------------------------------------------<span class="token number">0</span>             <span class="token number">5</span>                    <span class="token number">15</span>          <span class="token number">19</span>    <span class="token number">21</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>属性值:<code>length</code>:返回对象中时间范围的个数</p></li><li><p>方法:</p><ul><li><code>end(index)</code>:指定索引的范围的开始时间</li><li><code>start(index)</code>:指定索引的范围的结束时间</li></ul></li><li><p>以下三个属性皆实现了<code>TimeRangs</code>这个接口</p><ol><li><code>buffered</code>:只读.buffered属性会告诉浏览器哪一部分的媒体已经被下载(返回一个TimeRangs对象)</li><li><code>played</code>:只读.媒体可被播放的范围</li><li><code>seekable</code>:(如果有)用户可以试图找到的寻求范围</li></ol></li><li><p>何通过TimeRanges来判断video是否已经完全加载</p></li></ul><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">const</span> buf <span class="token operator">=</span> video<span class="token punctuation">.</span>bufferedconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>buf<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token keyword">if</span> <span class="token punctuation">(</span>buf<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// only one range</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>buf<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> buf<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">==</span> v<span class="token punctuation">.</span>duration<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span>    <span class="token comment">// The one range starts at the beginning and ends at</span>    <span class="token comment">// the end of the video, so the whole thing is loaded</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><code>readyState</code>:媒体的就绪状态</p></blockquote><table><thead><tr><th>常量</th><th>值</th><th>描述</th></tr></thead><tbody><tr><td>HAVE_NOTHING</td><td>0</td><td>没有关于媒体资源的可用信息</td></tr><tr><td>HAVE_METADATA</td><td>1</td><td>已检索到足够的媒体资源,因此已初始化元数据属性寻求将不再引发异常</td></tr><tr><td>HAVE_CURRENT_DATA</td><td>2</td><td>数据可用于当前播放位置,但不足以实际播放多个帧</td></tr><tr><td>HAVE_FUTURE_DATA</td><td>3</td><td>当前播放位置以及至少一点点未来的数据是可用的(换句话说,至少两帧视频)</td></tr><tr><td>HAVE_ENOUGH_DATA</td><td>4</td><td>有足够的数据可用,下载速率足够高,媒体可以不间断地播放到底</td></tr></tbody></table><blockquote><p><code>networkState</code>:获取媒体时的网络状态</p></blockquote><table><thead><tr><th>常量</th><th>值</th><th>描述</th></tr></thead><tbody><tr><td>NETWORK_EMPTY</td><td>0</td><td>还没数据.readyState是HAVE_NOTHING</td></tr><tr><td>NETWORK_IDLE</td><td>1</td><td>是有效的并且已经选择了一个资源,但是还没有使用网络</td></tr><tr><td>NETWORK_LOADING</td><td>2</td><td>正在下载HTMLMediaElement 数据.</td></tr><tr><td>NETWORK_NO_SOURCE</td><td>3</td><td>没有找到 HTMLMediaElement src</td></tr></tbody></table><h4 id="HTMLMediaElement方法"><a href="#HTMLMediaElement方法" class="headerlink" title="HTMLMediaElement方法"></a>HTMLMediaElement方法</h4><blockquote><p>由于HTMLVideoElement本身的方法还在实验性中,这里使用HTMLMediaElement父元素的方法</p></blockquote><ul><li><code>play()</code>:开始播放</li><li><code>pause()</code>:暂停播放</li></ul><pre class="line-numbers language-js" data-language="js"><code class="language-js">pay<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">"click"</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  video<span class="token punctuation">.</span><span class="token function">play</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span>pau<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">"click"</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  video<span class="token punctuation">.</span><span class="token function">pause</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>canPlayType(in DOMString type)</code>:返回以下属性<ul><li><code>probably</code>:如果指定的类型似乎可以播放</li><li><code>maybe</code>:如果不播放就无法判断该类型是否可播放</li><li><code>空字符串</code>:如果指定的类型肯定不能播放</li></ul></li></ul><pre class="line-numbers language-js" data-language="js"><code class="language-js">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>video<span class="token punctuation">.</span><span class="token function">canPlayType</span><span class="token punctuation">(</span><span class="token string">'video/webm'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">//maybe</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><code>load()</code>:重置媒体元素并重新选择媒体资源.任何未决事件都将被丢弃.获取多少媒体数据仍受<code>preload</code>属性的影响<ul><li>此方法可用于在删除任何<code>src</code>属性和&lt;source&gt;来放资源</li><li>通常不需要使用此方法,除非需要在动态更改后重新扫描&lt;source&gt;元素</li></ul></li></ul><h2 id="video事件"><a href="#video事件" class="headerlink" title="video事件"></a>video事件</h2><ol><li><p><code>loadstart</code>:浏览器开始寻找指定的音频&#x2F;视频时触发</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">video<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">"loadstart"</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">//由于没有视频资源,所以duration是null</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"loadstart"</span><span class="token punctuation">,</span> e<span class="token punctuation">.</span>target<span class="token punctuation">.</span>duration<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><code>durationchange</code>:时长变化的时候.音频&#x2F;视频的时长数据发生变化时触发,时长由NaN变为音频&#x2F;视频的实际时长</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">video<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">"durationchange"</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"durationchange"</span><span class="token punctuation">,</span> e<span class="token punctuation">.</span>target<span class="token punctuation">.</span>duration<span class="token punctuation">)</span><span class="token comment">//视频总时长</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p><code>loadedmetadata</code>:元数据加载的时候.音频&#x2F;视频的元数据已加载时触发,元数据包括:时长,尺寸(仅视频)以及文本轨道</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">video<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">"loadedmetadata"</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"loadedmetadata"</span><span class="token punctuation">,</span> e<span class="token punctuation">.</span>target<span class="token punctuation">.</span>duration<span class="token punctuation">)</span><span class="token comment">//视频总时长</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p><code>progress</code>:浏览器下载监听.当浏览器正在下载指定的音频&#x2F;视频时触发</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">video<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">"progress"</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"progress"</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p><code>loadeddata</code>:视频的首帧已经加载时,但没有足够的数据来播放指定音频&#x2F;视频的下一帧时触发</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">video<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">"loadeddata"</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"loadeddata"</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p><code>canplay</code>:可播放监听.当浏览器能够开始播放指定的音频&#x2F;视频时触发</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">video<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">"canplay"</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"canplay"</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p><code>canplaythrough</code>:可流畅播放.在不停下来进行缓冲的情况下持续播放指定的音频&#x2F;视频时触发</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">video<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">"canplaythrough"</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"canplaythrough"</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p><code>play</code>:播放监听.</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">video<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">"play"</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"play"</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p><code>pause</code>:暂停监听</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">video<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">"pause"</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"pause"</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p><code>seeking</code>:当用户开始移动&#x2F;跳跃到音频&#x2F;视频中新的位置时触发</p></li></ol>   <pre class="line-numbers language-js" data-language="js"><code class="language-js">video<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">"seeking"</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"seeking"</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ol start="11"><li><code>seeked</code>:当用户已经移动&#x2F;跳跃到视频中新的位置时触发</li></ol>   <pre class="line-numbers language-js" data-language="js"><code class="language-js">video<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">"seeked"</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"seeked"</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ol start="12"><li><code>waiting</code>:视频加载等待.当视频由于需要缓冲下一帧而停止,等待时触发<ul><li>当触发play事件的时候,如果视频还没有加载好,就会触发waiting</li></ul></li></ol>   <pre class="line-numbers language-js" data-language="js"><code class="language-js">video<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">"waiting"</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"waiting"</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ol start="13"><li><code>playing</code>:当视频在已因缓冲而暂停或停止后已就绪时触发</li></ol>   <pre class="line-numbers language-js" data-language="js"><code class="language-js">video<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">"playing"</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"playing"</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ol start="14"><li><code>timeupdate</code>:当播放位置已更改,播放时间更新</li></ol>   <pre class="line-numbers language-js" data-language="js"><code class="language-js">video<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">"timeupdate"</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"timeupdate"</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ol start="15"><li><code>ended</code>:播放结束的时候</li></ol>   <pre class="line-numbers language-js" data-language="js"><code class="language-js">video<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">"ended"</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"ended"</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ol start="16"><li><code>error</code>:播放错误</li></ol>   <pre class="line-numbers language-js" data-language="js"><code class="language-js">video<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'error'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'error'</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ol start="17"><li><code>volumechange</code>:当音量更改时</li></ol>   <pre class="line-numbers language-js" data-language="js"><code class="language-js">video<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'volumechange'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'volumechange'</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ol start="18"><li><code>stalled</code>:当浏览器尝试获取媒体数据,但数据不可用时</li></ol>   <pre class="line-numbers language-js" data-language="js"><code class="language-js">video<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'stalled'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'stalled'</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ol start="19"><li><code>ratechange</code>:当视频的播放速度已更改时</li></ol>   <pre class="line-numbers language-js" data-language="js"><code class="language-js">video<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'ratechange'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'ratechange'</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ol start="20"><li><code>emptied</code>:媒体内容为空时触发.例如,当这个<code>media</code>已经加载完成(或者部分加载完成).<code>load()</code>被用来进行重新加载</li></ol><blockquote><p>注意点:</p></blockquote><ul><li>你可以用CSS属性<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/object-position"><code>object-position</code></a> 来调整视频在元素内部的位置,它可以控制视频尺寸适应于元素外框的方式.</li><li>如果想在视频里展示字幕或者标题,你可以在 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/track"><code>&lt;track&gt;</code></a> 元素和 <a href="https://developer.mozilla.org/en-US/docs/Web/API/WebVTT_API">WebVTT</a> 格式的基础上使用 JavaScript 来实现.详情请见 <a href="https://developer.mozilla.org/en-US/docs/Web/Apps/Fundamentals/Audio_and_video_delivery/Adding_captions_and_subtitles_to_HTML5_video">Adding captions and subtitles to HTML5 video</a></li></ul><h2 id="画中画"><a href="#画中画" class="headerlink" title="画中画"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/PictureInPictureWindow">画中画</a></h2><ul><li><p>HTML中的属性:</p><ul><li><code>autoPictureInPicture</code>:该属性指示视频是否应自动进入或离开画中画模式<ul><li>如果是<code>true</code>:视频在更改选项卡和&#x2F;或应用程序时应自动进入或离开画中画模式</li></ul></li><li><code>disablePictureInPicture</code>:阻止用户代理(<code>User-Agent</code>)是否应该向用户建议画中画功能,或者请求它自动<ul><li>如果是<code>true</code>,表示用户代理(请求头中的<a href="https://developer.mozilla.org/en-US/docs/Glossary/User_agent"><code>User-Agent</code></a>)不应向用户建议该功能(就是画中画不能播放)</li></ul></li></ul></li><li><p>方法:</p><ol><li><code>HTMLVideoElement.requestPictureInPicture()</code>:异步请求,以画中画模式显示视频<ul><li>如果成功进入画中画了.会触发<code>enterpictureinpicture</code>事件,让它知道它现在处于画中画状态</li><li>返回一个<code>PictureInPictureWindow</code>对象</li></ul></li><li><code>Document.exitPictureInPicture()</code>将此文档中包含的视频(当前处于浮动状态)从画中画模式中取出,从而恢复屏幕的先前状态<ul><li>返回值一个Promise,一旦用户代理完成退出画中画模式,就会解析.如果发生错误,那么会调用promise处理</li><li>语法:<code>exitPromise = document.exitPictureInPicture();</code></li></ul></li></ol></li><li><p>属性:<code>Document.pictureInPictureEnabled</code>.指示画中画模式是否可用.默认情况下,画中画模式可用</p></li><li><p>事件:</p><ul><li><code>enterpictureinpicture</code>:当视频成功进入画中画模式时,将触发该事件.<code>enterpictureinpicture</code>此事件不可取消,也不会冒泡</li><li><code>leavepictureinpicture</code>:当视频元素成功离开画中画模式时,将触发该事件.<code>leavepictureinpicture</code>此事件不可取消,也不会冒泡</li></ul></li><li><p><code>PictureInPictureWindow</code>接口是一个对象,它可以通过编程的方式获得浮动视频窗口的宽度和高度,并调整浮动视频窗口的大小.</p><ul><li>使用<code>HTMLVideoElement.requestPictureInPicture()</code>返回一个具有此接口的promise</li><li><code>width,height</code>:只读.返回小窗口的高度和宽度</li><li><code>resize</code>:监听小窗口调整大小的事件</li></ul></li></ul><pre class="line-numbers language-js" data-language="js"><code class="language-js">video<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'enterpictureinpicture'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">event</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">const</span> smallWindow <span class="token operator">=</span> event<span class="token punctuation">.</span>pictureInPictureWindow<span class="token punctuation">;</span>  <span class="token comment">// smallWindow就是一个PictureInPictureWindow对象</span>  smallWindow<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'resize'</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">event</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">//event.targe就是smallWidth</span>    <span class="token comment">// event.target.width是小视频窗口的宽度</span>    <span class="token comment">// event.target.width是小视频窗口的高度</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="实现画中画"><a href="#实现画中画" class="headerlink" title="实现画中画"></a>实现画中画</h3><blockquote><p>实现画中画不可缺少的就是观察者模式(IntersectionObserver)的使用<br>.<br>如果对观察者不熟,可以看<a href="https://juejin.cn/post/7075666393508773895">https://juejin.cn/post/7075666393508773895</a></p></blockquote><ul><li><p>第一种方式使用vue的<code>teleport</code>组件<a href="http://mail.zyjcould.ltd/player/#/player">http://mail.zyjcould.ltd/player/#/player</a>.</p></li><li><p><a href="https://github.com/Jack-Zhang-1314/player">仓库地址</a></p></li><li><p>第二种就是使用<code>autoPictureInPicture</code>实现小窗口传送</p></li><li><p>由于谷歌浏览器原生的政策,画中画暂时还是不能使用原生很好的支持</p></li></ul><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span> <span class="token special-attr"><span class="token attr-name">style</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span><span class="token value css language-css"><span class="token property">height</span><span class="token punctuation">:</span> 2000px<span class="token punctuation">;</span></span><span class="token punctuation">"</span></span></span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>video</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>video<span class="token punctuation">"</span></span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>https://zyjcould.ltd/mv/player.mp4<span class="token punctuation">"</span></span> <span class="token attr-name">autoPictureInPicture</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span> <span class="token attr-name">height</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>300px<span class="token punctuation">"</span></span>    <span class="token attr-name">controls</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>video</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>module<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript">  <span class="token keyword">const</span> v <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">"#video"</span><span class="token punctuation">)</span>  <span class="token keyword">const</span> observe <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">IntersectionObserver</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">entries<span class="token punctuation">,</span> observe</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>    entries<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token parameter">entry</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"jinru"</span><span class="token punctuation">)</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>entry<span class="token punctuation">.</span>intersectionRatio<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        v<span class="token punctuation">.</span><span class="token function">requestPictureInPicture</span><span class="token punctuation">(</span><span class="token punctuation">)</span>      <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>v<span class="token punctuation">.</span>readyState <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> entry<span class="token punctuation">.</span>intersectionRatio<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        document<span class="token punctuation">.</span><span class="token function">exitPictureInPicture</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>          <span class="token parameter">value</span> <span class="token operator">=></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">,</span>          <span class="token parameter">error</span> <span class="token operator">=></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span>        <span class="token punctuation">)</span>      <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">)</span>  observe<span class="token punctuation">.</span><span class="token function">observe</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol><li><p>第一个错误是由于为使用用户手势,也就是必须要点击视频(可以是任何位置)才可以触发小窗口</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Uncaught <span class="token punctuation">(</span>in promise<span class="token punctuation">)</span> DOMException: Failed to execute <span class="token string">'requestPictureInPicture'</span> on <span class="token string">'HTMLVideoElement'</span><span class="token builtin class-name">:</span> Must be    handling a user gesture <span class="token keyword">if</span> there isn't already an element <span class="token keyword">in</span> Picture-in-Picture.<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>第二个错误,是因为,用户代理事件是有生命周期的,触发小窗口切换来回之后(或者在可能是5s)内会死亡</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">DOMException: Failed to execute <span class="token string">'exitPictureInPicture'</span> on <span class="token string">'Document'</span><span class="token builtin class-name">:</span> There is no Picture-in-Picture element <span class="token keyword">in</span>    this document.<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol><ul><li>这里有详解的错误原因</li><li><a href="https://stackoverflow.com/questions/56252108/why-video-requestpictureinpicture-works-only-once">https://stackoverflow.com/questions/56252108/why-video-requestpictureinpicture-works-only-once</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;video标签&quot;&gt;&lt;a href=&quot;#video标签&quot; class=&quot;headerlink&quot; title=&quot;video标签&quot;&gt;&lt;/a&gt;video标签&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&amp;lt;video&amp;gt;实现了HTMLVideoElement这个接口.</summary>
      
    
    
    
    <category term="JS" scheme="http://mail.zyjcould.ltd/categories/JS/"/>
    
    
    <category term="JS" scheme="http://mail.zyjcould.ltd/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>URL</title>
    <link href="http://mail.zyjcould.ltd/2022/03/28/url/"/>
    <id>http://mail.zyjcould.ltd/2022/03/28/url/</id>
    <published>2022-03-28T15:46:36.000Z</published>
    <updated>2022-03-29T05:16:40.651Z</updated>
    
    <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><blockquote><p>URL用于解析,构造,规范化和编码urls.如果浏览器不支持<code>new URL()</code>构造函数.可以使用<code>new window.URL()</code></p></blockquote><h3 id="new-URL"><a href="#new-URL" class="headerlink" title="new URL()"></a>new URL()</h3><blockquote><p>构造函数:new URL(url[,base])</p></blockquote><ul><li><code>url</code>:表示绝对或者相对的url.如果是绝对的url,无论baseurl有没有参数都会被忽略.如果是相对的url,则参数会添加到baseurl后</li><li><code>base</code>:可选的,表示基准的url.只有url是带协议才可以生效.<span style="color:red">否则报一个TypeError</span></li></ul><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">let</span> baseurl <span class="token operator">=</span> <span class="token string">"https://www.baidu.com/laji"</span><span class="token comment">//忽略参数</span><span class="token keyword">new</span> <span class="token class-name">URL</span><span class="token punctuation">(</span><span class="token string">"/zhenlan"</span><span class="token punctuation">,</span>baseurl<span class="token punctuation">)</span><span class="token comment">//https://www.baidu.com/zhenlan</span><span class="token comment">//TypeError</span><span class="token keyword">new</span> <span class="token class-name">URL</span><span class="token punctuation">(</span><span class="token string">"www.baidu.com"</span><span class="token punctuation">)</span><span class="token keyword">new</span> <span class="token class-name">URL</span><span class="token punctuation">(</span><span class="token string">"https://www.baidu.com"</span><span class="token punctuation">)</span><span class="token comment">//https://www.baidu.com</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>属性</p></blockquote><ul><li><code>hash</code>:返回包含URL标识中的’#’和fragment标识符</li><li><code>host</code>:返回一个主机信息.即<code>hostname</code>,如果URL接口有端口号(如果是默认端口号,则不会包含),也会包含端口号</li><li><code>hostname</code>:不包含端口号的主机信息</li><li><code>href</code>:返回一个完整的url</li><li><code>origin</code>:只读属性.<ul><li>如果是<code>http</code>或者是<code>https</code>,返回<code>协议名+&#39;://&#39;+域名+&#39;:&#39;+端口号</code></li><li>如果是ftp协议,视浏览器而定</li><li>如果是<code>blob:</code>协议,返回的是<code>blob:</code>紧跟的源地址<ul><li><code>&quot;blob:https://mozilla.org&quot;</code>返回<code>https://mozilla.org</code></li></ul></li></ul></li><li><code>pathname</code>返回一个初始<code>/</code>和URL的路径(如果没有路径,则为空字符串)</li><li><code>port</code>:如果url中包含明确的端口信息,则返回一个端口号.否则返回<code>&quot;&quot;</code></li><li><code>protocol</code>:返回一个url的协议值</li><li><code>search</code>:返回一个查询字符串.<code>?</code>紧跟的</li><li><code>searchParams</code>:返回一个<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/URLSearchParams">URLSearchParams</a>.这个对象包含当前URL中解码后的GET查询参数</li></ul><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">const</span> url <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">URL</span><span class="token punctuation">(</span><span class="token string">'https://developer.mozilla.org:3300/en-US/docs/Web/API/URL/href?q=123#Examples'</span><span class="token punctuation">)</span><span class="token keyword">const</span> hash <span class="token operator">=</span> url<span class="token punctuation">.</span>hash <span class="token comment">//#Examples</span><span class="token keyword">const</span> host <span class="token operator">=</span> url<span class="token punctuation">.</span>host <span class="token comment">//developer.mozilla.org:3300</span><span class="token keyword">const</span> host <span class="token operator">=</span> url<span class="token punctuation">.</span>hostname <span class="token comment">//developer.mozilla.org</span><span class="token keyword">const</span> host <span class="token operator">=</span> url<span class="token punctuation">.</span>href <span class="token comment">//https://developer.mozilla.org:3300/en-US/docs/Web/API/URL/href#Examples</span><span class="token keyword">const</span> origin <span class="token operator">=</span> url<span class="token punctuation">.</span>origin <span class="token comment">//https://developer.mozilla.org</span><span class="token keyword">const</span> pathname <span class="token operator">=</span> url<span class="token punctuation">.</span>pathname <span class="token comment">///en-US/docs/Web/API/URL/href</span><span class="token keyword">const</span> port <span class="token operator">=</span> url<span class="token punctuation">.</span>port <span class="token comment">//3300</span><span class="token keyword">const</span> protocol <span class="token operator">=</span> url<span class="token punctuation">.</span>protocol <span class="token comment">//https</span><span class="token keyword">const</span> search <span class="token operator">=</span> url<span class="token punctuation">.</span>search <span class="token comment">//?q=123</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>username</code>:包含域名前指定的username</li><li><code>password</code>:返回域名之前指定的密码</li></ul><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">const</span> url <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">URL</span><span class="token punctuation">(</span><span class="token string">'https://anonymous:flabada@developer.mozilla.org/en-US/docs/Web/API/URL/password'</span><span class="token punctuation">)</span><span class="token keyword">const</span> password <span class="token operator">=</span> url<span class="token punctuation">.</span>password <span class="token comment">//flabada</span><span class="token keyword">const</span> username <span class="token operator">=</span> url<span class="token punctuation">.</span>username <span class="token comment">//anonymous</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p>静态方法</p></blockquote><ol><li><code>URL.createObjectURL(object)</code>:创建一个表示参数中给出的对象的URL<ul><li>这个新的URL对象表示指定的<code>File</code>对象或<code>Blob</code>对象</li><li><code>object</code>:用于创建URL的<code>File</code>对象,<code>Blob</code>对象或者<code>MediaSource</code>对象</li><li>返回一个用于指定源的URL</li></ul></li><li><code>URL.revokeObjectURL(objectURL)</code>:释放一个之前已经存在的,通过调用<code>URL.createObjectURL()</code>创建的URL对象<ul><li><code>objectURL</code>:通过调用<code>URL.createObjectURL()</code>方法产生的URL对象</li></ul></li><li><code>URL.toString()</code>与<code>URL.toJSON()</code>与<code>url.href</code>一样,返回序列化的url</li></ol><h3 id="URLSearchParams"><a href="#URLSearchParams" class="headerlink" title="URLSearchParams"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/URLSearchParams/append">URLSearchParams</a></h3><blockquote><p>接口定义了一些实用的方法来处理URL的查询字符串</p></blockquote><h4 id="new-URLSearchParams"><a href="#new-URLSearchParams" class="headerlink" title="new URLSearchParams()"></a>new URLSearchParams()</h4><blockquote><p><code>URLSearchParams()</code>构造器创建并返回一个新的<code>URLSearchParams</code>对象.并且会忽略<code>?</code></p></blockquote><ul><li><code>const URLSearchParams = new URLSearchParams(init)</code></li><li><code>init</code>:需要USVString(对应 unicode 标量值的所有可能序列的集合)</li></ul><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">new</span> <span class="token class-name">URLSearchParams</span><span class="token punctuation">(</span><span class="token string">'?foo=1&amp;bar=2'</span><span class="token punctuation">)</span><span class="token keyword">new</span> <span class="token class-name">URLSearchParams</span><span class="token punctuation">(</span>url<span class="token punctuation">.</span>search<span class="token punctuation">)</span><span class="token keyword">new</span> <span class="token class-name">URLSearchParams</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token string">"foo"</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token string">"bar"</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">new</span> <span class="token class-name">URLSearchParams</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span><span class="token string">"foo"</span> <span class="token operator">:</span> <span class="token number">1</span> <span class="token punctuation">,</span> <span class="token string">"bar"</span> <span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>方法</p></blockquote><ul><li><code>append(name, value)</code>:可以插入一个新搜索参数</li><li><code>getAll(name)</code>:以数组的形式返回与指定搜索参数对应的所有值</li><li><code>get(name)</code>:返回第一个与搜索参数对应的值</li><li><code>has(name)</code>:返回一个布尔值,表示查找的键名是否存在</li><li><code>set()</code>:设置和搜索参数相关联的值.如果设置前已经存在匹配的值,该方法会删除多余的,如果将要设置的值不存在,则创建它</li><li><code>delete(name)</code>:可以删除指定名称的所有搜索参数</li><li><code>sort()</code>:对对象中的所有键&#x2F;值对进行排序.按unicode编码</li><li><code>entries()</code>:返回一个<code>iterator</code>,允许遍历该对象中包含的所有键&#x2F;值对</li><li><code>forEach(callback)</code>:该回调函数可以接收到3个参数value,key,searchParams</li><li><code>keys()</code>:返回一个iterator,遍历器允许遍历对象中包含的所有键</li><li><code>values()</code>:返回一个iterator,遍历器允许遍历对象中包含的所有值</li><li><code>toString()</code>:返回适用在URL中的查询字符串</li></ul><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">let</span> url <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">URL</span><span class="token punctuation">(</span><span class="token string">'https://example.com?foo=1&amp;bar=2'</span><span class="token punctuation">)</span><span class="token keyword">let</span> params <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">URLSearchParams</span><span class="token punctuation">(</span>url<span class="token punctuation">.</span>search<span class="token punctuation">)</span>params<span class="token punctuation">.</span><span class="token function">getAll</span><span class="token punctuation">(</span><span class="token string">"foo"</span><span class="token punctuation">)</span> <span class="token comment">//['1', '4']</span>params<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"foo"</span><span class="token punctuation">)</span> <span class="token comment">//'1'</span>params<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">'foo'</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token comment">//foo=1&amp;bar=2&amp;foo=4</span>params<span class="token punctuation">.</span><span class="token function">has</span><span class="token punctuation">(</span><span class="token string">'bar'</span><span class="token punctuation">)</span> <span class="token comment">// true</span>params<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">"foo"</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token comment">//foo=2&amp;bar=2</span>params<span class="token punctuation">.</span><span class="token function">delete</span><span class="token punctuation">(</span><span class="token string">"foo"</span><span class="token punctuation">)</span><span class="token comment">//bar=2</span>params<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">'foo'</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token comment">//entries</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">[</span>key<span class="token punctuation">,</span>value<span class="token punctuation">]</span> <span class="token keyword">of</span> params<span class="token punctuation">.</span><span class="token function">entries</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span>value<span class="token punctuation">)</span>  <span class="token comment">//bar 2</span>  <span class="token comment">//foo 4   </span><span class="token punctuation">&#125;</span><span class="token comment">//forEach</span>params<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">item<span class="token punctuation">,</span>key</span><span class="token punctuation">)</span><span class="token operator">=></span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>item<span class="token punctuation">,</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment">//bar 2</span>  <span class="token comment">//foo 4  </span><span class="token comment">//keys()</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token operator">...</span>params<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">//bar foo</span><span class="token comment">//values()</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token operator">...</span>params<span class="token punctuation">.</span><span class="token function">values</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">//2 4</span>params<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">//'bar=2&amp;foo=4'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;URL&quot;&gt;&lt;a href=&quot;#URL&quot; class=&quot;headerlink&quot; title=&quot;URL&quot;&gt;&lt;/a&gt;URL&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;URL用于解析,构造,规范化和编码urls.如果浏览器不支持&lt;code&gt;new URL()&lt;/code&gt;构</summary>
      
    
    
    
    <category term="JS" scheme="http://mail.zyjcould.ltd/categories/JS/"/>
    
    
    <category term="JS" scheme="http://mail.zyjcould.ltd/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>drag</title>
    <link href="http://mail.zyjcould.ltd/2022/03/28/drag/"/>
    <id>http://mail.zyjcould.ltd/2022/03/28/drag/</id>
    <published>2022-03-28T08:59:44.000Z</published>
    <updated>2022-04-08T02:04:34.090Z</updated>
    
    <content type="html"><![CDATA[<h2 id="draggable"><a href="#draggable" class="headerlink" title="draggable"></a>draggable</h2><blockquote><p>该属性是一个<strong>全局属性</strong>.是枚举类型,用于表示元素是否允许使用拖放操作</p></blockquote><ul><li><code>true</code>:可以拖动</li><li><code>false</code>:禁止拖动</li><li><code>auto</code>:跟随浏览器定义是否可以拖动</li></ul><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">draggable</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="HTML拖拽API"><a href="#HTML拖拽API" class="headerlink" title="HTML拖拽API"></a>HTML拖拽API</h2><blockquote><p>拖放(<code>Drag</code>和<code>Drop</code>)接口使应用能够在浏览器使用拖放功能,并且继承了<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Event">DOM event model</a>以及从<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/MouseEvent">mouse events</a>继承而来,得到<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/DragEvent">drag events</a>.</p></blockquote><h3 id="DragEvent"><a href="#DragEvent" class="headerlink" title="DragEvent"></a>DragEvent</h3><blockquote><p><code>DragEvent</code>的所有事件都是全局事件</p></blockquote><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token comment">//可以直接在document上使用</span>document<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span>  <span class="token string">"drag"</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">event</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>event<span class="token punctuation">.</span>target<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>在操作期间,有一些事件的类型可能会被多次触发(例如<code>drag</code>和<code>dragover</code>)</li></ul><table><thead><tr><th>事件</th><th>On型事件处理程序</th><th>触发时刻</th></tr></thead><tbody><tr><td>dragstart</td><td>ondragstart</td><td>当用户开始拖拽一个元素或选中的文本时触发</td></tr><tr><td>drag</td><td>ondrag</td><td>当拖拽元素或选中的文本时触发或者到达可放置区域触发</td></tr><tr><td>dragend</td><td>ondragend</td><td>当拖拽操作结束时触发(<strong>比如松开鼠标按键或敲Esc键</strong>)</td></tr><tr><td>dragexit</td><td>ondragexit</td><td>当元素变得不再是拖拽操作的选中目标时触发(官网并没有详细说明)</td></tr><tr><td>dragenter</td><td>ondragenter</td><td>当拖拽元素或选中的文本<strong>刚进入</strong>到一个可释放目标时触发</td></tr><tr><td>dragover</td><td>ondragover</td><td>当元素或选中的文本被<strong>拖入到一个可释放目标内时触发</strong>(每100毫秒触发一次)</td></tr><tr><td>dragleave</td><td>ondragleave</td><td>当拖拽元素或选中的文本离开一个可释放目标时触发</td></tr><tr><td>drop</td><td>ondrop</td><td>当元素放置在可放置区域时触发(此时可以取消浏览器的默认行为)</td></tr></tbody></table><ul><li><p>被拖动的元素事件有:<code>drag</code>,<code>dragstart</code>,<code>dragend</code>,<code>dragexit</code></p></li><li><p>目的地对象事件有:<code>dragenter</code>,<code>dragover</code>,<code>dragleave</code>,<code>drop</code></p></li><li><p><code>dragenter</code>和<code>dragover</code>事件的默认行为是拒绝接受任何被拖放的元素.</p><ul><li>需要使用<code>event.preventDefault()</code>阻止默认行为</li></ul></li><li><p>默认触发的顺序就是:<code>dragstart-&gt;dragenter-&gt;dragleave-&gt;dragend</code></p></li></ul><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">></span></span><span class="token style"><span class="token language-css">  <span class="token selector">.box</span> <span class="token punctuation">&#123;</span>    <span class="token property">width</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>    <span class="token property">height</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>    <span class="token property">background-color</span><span class="token punctuation">:</span> <span class="token function">rgb</span><span class="token punctuation">(</span>153<span class="token punctuation">,</span> 80<span class="token punctuation">,</span> 202<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token selector">.container</span> <span class="token punctuation">&#123;</span>    <span class="token property">width</span><span class="token punctuation">:</span> 400px<span class="token punctuation">;</span>    <span class="token property">height</span><span class="token punctuation">:</span> 400px<span class="token punctuation">;</span>    <span class="token property">margin</span><span class="token punctuation">:</span> 100px auto<span class="token punctuation">;</span>    <span class="token property">border</span><span class="token punctuation">:</span> 3px solid <span class="token function">rgb</span><span class="token punctuation">(</span>40<span class="token punctuation">,</span> 180<span class="token punctuation">,</span> 127<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>box<span class="token punctuation">"</span></span> <span class="token attr-name">draggable</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>container<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript">  <span class="token keyword">const</span> box <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementsByClassName</span><span class="token punctuation">(</span><span class="token string">"box"</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token keyword">const</span> container <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementsByClassName</span><span class="token punctuation">(</span><span class="token string">"container"</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  box<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">"drag"</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">//console.log(e.target, "drop")</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">)</span>  box<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">"dragstart"</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>target<span class="token punctuation">,</span> <span class="token string">"dragstart"</span><span class="token punctuation">)</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">)</span>  box<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">"dragend"</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>target<span class="token punctuation">,</span> <span class="token string">"dragend"</span><span class="token punctuation">)</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">)</span>  box<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">"dragexit"</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>target<span class="token punctuation">,</span> <span class="token string">"dragexit"</span><span class="token punctuation">)</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">)</span>  container<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">"dragenter"</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    e<span class="token punctuation">.</span><span class="token function">preventDefault</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>target<span class="token punctuation">,</span> <span class="token string">"dragenter"</span><span class="token punctuation">)</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">)</span>  container<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">"dragover"</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">//e.preventDefault()</span>    <span class="token comment">//console.log(e.target, "dragover")</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">)</span>  container<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">"dragleave"</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>target<span class="token punctuation">,</span> <span class="token string">"dragleave"</span><span class="token punctuation">)</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">)</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="DataTransfer"><a href="#DataTransfer" class="headerlink" title="DataTransfer"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/DataTransfer">DataTransfer</a></h4><ul><li><code>DataTransfer()</code>是一个构造函数,返回一个新的<code>DataTransfer</code>对象</li></ul><blockquote><p><code>DataTransfer</code>对象用于保存拖动并放下(drag and drop)过程中的数据.它可以报存一项或者多项的数据和每个拖拽项的类型(MIME类型)</p></blockquote><ul><li><p><code>DataTransfer</code>对象包含拖拽事件的状态(例如事件的拷贝(copy)或者移动(move)).并且可以向拖拽数据中添加或删除项目的方法</p></li><li><p>在<code>DragEvent</code>接口有一个<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/DragEvent/DragEvent">构造函数</a>和一个<code>dataTransfer</code>(dataTransfer属性就是一个DataTransfer对象)属性</p></li></ul><blockquote><p>方法</p></blockquote><ol><li><code>getData(format)</code>:接受指定类型的拖放.如果拖放行为没有操作任何数据,会返回一个空字符串<ul><li>数据类型:<code>text/plain</code>,<code>text/uri-list</code></li></ul></li><li><code>setData()</code>:设置拖放操作的drag data到指定的数据和类型(一般设置MIME类型)<ul><li>如果给定类型的数据不存在,则将其添加到拖动数据存储的末尾,使得<code>types</code>列表中的最后一个项目将是新类型</li><li>如果数据已经存在,则会替换当前位置的数据</li></ul></li><li><code>setDragImage(img, xOffset, yOffset)</code>:设置为自定义图像.通常在<code>dragstart</code>中使用此方法<ul><li>图像通常是一个&lt;image&gt;元素,也可以是&lt;canvas&gt;或者其他图像元素</li><li><code>xOffset</code>指示相对于图片的横向偏移量;<code>yOffset</code>指向相对于图片的纵向偏移量</li></ul></li><li><code>clearData([format])</code>:删除给定类型的拖动操作的.如果该数据不存在,不会进行任何操作<ul><li><code>format</code>:如果不指定数据类型,为空字符串或者空白.则会删除所有数据类型</li></ul></li></ol><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token comment">//使用dragover阻止浏览器的默认行为.</span><span class="token comment">//不能使用drapstart.drop需要拖拽元素在目标元素内才能完全触发</span>container<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">"dragover"</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  e<span class="token punctuation">.</span><span class="token function">preventDefault</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span>box<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">"dragstart"</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  e<span class="token punctuation">.</span>dataTransfer<span class="token punctuation">.</span><span class="token function">setData</span><span class="token punctuation">(</span><span class="token string">"text/plain"</span><span class="token punctuation">,</span> <span class="token string">"www.google.com"</span><span class="token punctuation">)</span>  <span class="token keyword">const</span> img <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Image</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  img<span class="token punctuation">.</span>src <span class="token operator">=</span> <span class="token string">"https://zyjcould.ltd/erciyuan/diana.png"</span>  e<span class="token punctuation">.</span>dataTransfer<span class="token punctuation">.</span><span class="token function">setDragImage</span><span class="token punctuation">(</span>img<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span>container<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">"drop"</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">let</span> ele <span class="token operator">=</span> e<span class="token punctuation">.</span>dataTransfer<span class="token punctuation">.</span><span class="token function">getData</span><span class="token punctuation">(</span><span class="token string">"text/plain"</span><span class="token punctuation">)</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>ele<span class="token punctuation">,</span> <span class="token string">"drop"</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>属性</p></blockquote><ol><li><p><code>dropEffect</code>:用于控制在拖放过程中给用户的反馈(视觉上的),他会影响过程中光标手势.并且始终设置成effectAllowed的可能值之一</p><ul><li><code>copy</code>:操作用于指示被拖动的数据将从当前位置复制到放置位置</li><li><code>move</code>:操作用于指定被拖动的数据将被移动</li><li><code>link</code>:操作用于指示将在源和放置位置之间创建某种形式的关系或连接</li><li><code>none</code>:项目可能禁止拖放</li></ul></li><li><p><code>effectAllowed</code>:指定拖放操作所允许的一个效果</p><ul><li><code>none</code>:此项表示不允许放下</li><li><code>copy</code>:源项目的复制项可能会出现在新位置</li><li><code>copyLink</code>:允许 copy 或者 link 操作</li><li><code>copyMove</code>:允许 copy 或者 move 操作</li><li><code>link</code>:可以在新地方建立与源的链接</li><li><code>linkMove</code>:允许 link 或者 move 操作</li><li><code>move</code>:一个项目可能被移动到新位置</li><li><code>all</code>允许所有的操作</li><li><code>uninitialized</code>效果没有设置时的默认值,则等同于all</li></ul><pre class="line-numbers language-js" data-language="js"><code class="language-js">box<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">"dragstart"</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  e<span class="token punctuation">.</span>dataTransfer<span class="token punctuation">.</span>effectAllowed <span class="token operator">=</span> <span class="token string">"move"</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span>container<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">"dragover"</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  e<span class="token punctuation">.</span><span class="token function">preventDefault</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  ev<span class="token punctuation">.</span>dataTransfer<span class="token punctuation">.</span>dropEffect <span class="token operator">=</span> <span class="token string">"move"</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span>container<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">"drop"</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  e<span class="token punctuation">.</span>target<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>box<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><code>fills</code>:属性在拖动操作中表示<strong>文件列表</strong>.如果操作不包含文件,则此列表为空</p><ul><li>所有type属性(attribute)为file的&lt;input&gt;元素都有一个files属性(property),用来存储用户所选择的文件</li></ul><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>fileItem<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>file<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p><code>types</code>:只读属性.返回一个我们在事件中设置的拖动数据格式(setData()).格式顺序与拖动操作中包含的数据顺序相同</p></li><li><p><code>items</code>:DataTransfer的items属性只读,是拖动操作中<code>DataTransferItem</code>的<code>DataTransferItemList</code>.</p><ul><li>一个<code>DataTransferItemList</code>对象,包含了表示拖动操作中被拖动项的DataTransferItem对象,每一个拖动项对应一个列表项</li><li>该列表包含了操作中每一项目的对应项,如果操作没有项目,则列表为空</li></ul></li></ol><h5 id="DataTransferItem"><a href="#DataTransferItem" class="headerlink" title="DataTransferItem"></a>DataTransferItem</h5><blockquote><p>每个<code>DataTransfer</code>都包含一个items属性,这个属性是DataTransferItem对象的list(列表).即(DataTransferItemList)</p></blockquote><ul><li><code>DataTransferItem</code>描述了一个拖拽项.在一个拖拽中,每一个<code>drag event</code>都有一个dataTransfer属性,它包含存有拖拽属性的<code>list</code>,每一项都是一个DataTransferItem</li></ul><blockquote><p>属性</p></blockquote><ol><li><code>kind</code>:拖拽项的种类,<code>string</code>或者是<code>file</code></li><li><code>type</code>:拖拽想的类型.一般是MIME类型</li></ol><ul><li><p>由于items并不是一个数组,这里使用的是<code>Array.from()</code>转换</p><ul><li>阻止了浏览器默认直接大开图片,拖动图片或者其他类型文件.可以在控制台看到打印</li></ul><pre class="line-numbers language-js" data-language="js"><code class="language-js">container<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">"drop"</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  e<span class="token punctuation">.</span><span class="token function">preventDefault</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  Array<span class="token punctuation">.</span><span class="token function">from</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>dataTransfer<span class="token punctuation">.</span>items<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token parameter">item</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><blockquote><p>方法</p></blockquote><ol><li><code>getAsFile()</code>:<code>DataTransferItem</code>是一个文件,那此方法将返回拖拽项数据的File对象.否则返回null</li><li><code>getAsString(callback)</code>:当<code>kind</code>属性是一个普通Unicode字符串时,该方法会用<code>DataTransferItem</code>对象的kind属性作为实参来执行传入的回调函数<ul><li>该回调函数有权访问<code>DataTransferItem</code>的字符串数据</li></ul></li></ol><pre class="line-numbers language-js" data-language="js"><code class="language-js">container<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">"drop"</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  e<span class="token punctuation">.</span><span class="token function">preventDefault</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  Array<span class="token punctuation">.</span><span class="token function">from</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>dataTransfer<span class="token punctuation">.</span>items<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token parameter">item</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>item<span class="token punctuation">.</span>kind <span class="token operator">===</span> <span class="token string">"file"</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">const</span> file <span class="token operator">=</span> item<span class="token punctuation">.</span><span class="token function">getAsFile</span><span class="token punctuation">(</span><span class="token punctuation">)</span>      <span class="token keyword">const</span> url <span class="token operator">=</span> <span class="token constant">URL</span><span class="token punctuation">.</span><span class="token function">createObjectURL</span><span class="token punctuation">(</span>file<span class="token punctuation">)</span>      <span class="token keyword">const</span> img <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Image</span><span class="token punctuation">(</span><span class="token punctuation">)</span>      img<span class="token punctuation">.</span>src <span class="token operator">=</span> url      e<span class="token punctuation">.</span>target<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>img<span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>拖拽实现图片的上传功能</li></ul><h5 id="DataTransferItemList"><a href="#DataTransferItemList" class="headerlink" title="DataTransferItemList"></a>DataTransferItemList</h5><blockquote><p><code>DataTransferItemList</code>对象是<code>DataTransferItem</code>对象的列表.该属性可以向列表中添加拖拽项,从列表中移除拖拽项和清空列表中所有的拖拽项</p></blockquote><ul><li><code>DataTransferItemList</code>对象就是每个<code>DragEvent</code>属性都有的<code>dataTransfer</code>属性中的<code>items</code>属性</li></ul><blockquote><p>属性</p></blockquote><ul><li><code>length</code>:李彪拖动项的数量</li></ul><blockquote><p>方法</p></blockquote><ol><li><code>add()</code>指定数据创建新的<code>DataTransferItem</code>,并将其添加到拖动的<code>DataTransferItemList</code>中<ul><li><code>add(data, type)</code>.type是MIME类型.例如<code>text/html</code>或者<code>text/plain</code></li><li><code>add(file)</code>.文件对象,不需要给出任何类型</li><li>如果该项目成功添加到DataTransferItemList中,则返回一个新创建的 <code>DataTransferItem</code>对象.如果关键的DataTransfer对象没有数据存储,则返回null</li></ul></li><li><code>remove(index)</code>:方法从列表中指定删除指定索引处的<code>DataTransferItem</code>.如果越界,则不会更改列表</li><li><code>clear()</code>:将<code>DataTransferItemList</code>中的所有<code>DataTransferItem</code>删除</li></ol><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ol><li><code>DataTransfer</code>和<code>DataTransferItem</code>接口的一个主要的不同是前者使用同步的<code>getData()</code>方法去得到拖拽项的数据,而后者使用异步的<code>getAsString()</code>方法得到拖拽项的数据</li><li>使用<code>e.preventDefault()</code>这个属性可以取消一些不必要的浏览器的默认事件</li></ol><h2 id="mouse"><a href="#mouse" class="headerlink" title="mouse"></a>mouse</h2><blockquote><p>使用<code>mousedown</code>,<code>mousemove</code>,<code>mouseup</code>配合绝对定位<code>absolute</code>来进行拖拽</p></blockquote><p><img src="./mouse.png" alt="mouse"></p><ol><li><code>mousedown</code>:这个阶段首先确定的就是鼠标相对于盒子内部的距离<code>ol = pageX-offsetLeft</code><ul><li>不光是<code>pageX</code>,也可以使用<code>clientX</code>.在合适的情况下选择合适的属性</li></ul></li><li><code>mousemove</code>:在执行阶段,目标是算出偏移量的距离.使用<code>pageX-ol</code>.<ul><li>ol就是鼠标距离拖拽目标的距离(是固定的)</li></ul></li><li><code>mouseup</code>:在抬起阶段,解绑mousemove事事件.</li></ol><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text/css<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token style"><span class="token language-css">  <span class="token selector">#box1</span> <span class="token punctuation">&#123;</span>    <span class="token property">position</span><span class="token punctuation">:</span> absolute<span class="token punctuation">;</span>    <span class="token property">width</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>    <span class="token property">height</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>    <span class="token property">background-color</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span>    <span class="token property">cursor</span><span class="token punctuation">:</span> pointer<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>box1<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript">  box1<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">"mousedown"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>    e<span class="token punctuation">.</span><span class="token function">preventDefault</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    bl <span class="token operator">=</span> e<span class="token punctuation">.</span>pageX <span class="token operator">-</span> box1<span class="token punctuation">.</span>offsetLeft    br <span class="token operator">=</span> e<span class="token punctuation">.</span>pageY <span class="token operator">-</span> box1<span class="token punctuation">.</span>offsetTop    <span class="token keyword">function</span> <span class="token function">move</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      box1<span class="token punctuation">.</span>style<span class="token punctuation">.</span>left <span class="token operator">=</span> e<span class="token punctuation">.</span>pageX <span class="token operator">-</span> bl <span class="token operator">+</span> <span class="token string">"px"</span>      box1<span class="token punctuation">.</span>style<span class="token punctuation">.</span>top <span class="token operator">=</span> e<span class="token punctuation">.</span>pageY <span class="token operator">-</span> br <span class="token operator">+</span> <span class="token string">"px"</span>    <span class="token punctuation">&#125;</span>    document<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">"mousemove"</span><span class="token punctuation">,</span> move<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span>    document<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">"mouseup"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>      document<span class="token punctuation">.</span><span class="token function">removeEventListener</span><span class="token punctuation">(</span><span class="token string">"mousemove"</span><span class="token punctuation">,</span> move<span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">)</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;draggable&quot;&gt;&lt;a href=&quot;#draggable&quot; class=&quot;headerlink&quot; title=&quot;draggable&quot;&gt;&lt;/a&gt;draggable&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;该属性是一个&lt;strong&gt;全局属性&lt;/strong&gt;.是</summary>
      
    
    
    
    <category term="JS" scheme="http://mail.zyjcould.ltd/categories/JS/"/>
    
    
    <category term="JS" scheme="http://mail.zyjcould.ltd/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>Observer</title>
    <link href="http://mail.zyjcould.ltd/2022/03/15/observer/"/>
    <id>http://mail.zyjcould.ltd/2022/03/15/observer/</id>
    <published>2022-03-15T07:05:01.000Z</published>
    <updated>2022-03-19T08:12:04.882Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Observer"><a href="#Observer" class="headerlink" title="Observer"></a>Observer</h2><blockquote><p>网页开发中经常会和用户交互而使用一些监听事件(例如onclick,onchange等).如果对于一些用户不直接触发的元素(例如渐变等),那就需要使用Observer去监听</p></blockquote><ul><li>浏览器为我们提供了五种<code>Observer</code>(观察者)来监听这些变动:<code>MutationObserver</code>,<code>IntersectionObserver</code>,<code>PerformanceObserver</code>,<code>ResizeObserver</code>,<code>ReportingObserver</code></li><li>以下观察者api都是构造函数</li><li>观察者属于微任务,并且优先级小于Promise</li></ul><h3 id="IntersectionObserver"><a href="#IntersectionObserver" class="headerlink" title="IntersectionObserver"></a>IntersectionObserver</h3><blockquote><p><code>IntersectionObserver</code>(交叉观察者)用于观察一个元素是否在视窗可见.构造函数创建并返回一个新的<code>IntersectionObserver</code>对象</p><p>如果未指定或为空字符串,则缺省的值为属性的默认值</p><p>一般用于<strong>无限滚动</strong>,<strong>图片懒加载</strong>,<strong>埋点</strong>,<strong>控制动画&#x2F;视频执行</strong></p></blockquote><ul><li>无论是使用视口(body)还是其他元素作为根,API 的工作方式都相同,并且会<strong>异步</strong>查询观察目标元素的可见性发生变化,就会执行提供的回调函数</li><li>通过提供一种新方法来<strong>异步</strong>查询元素相对于其他元素或全局视口的位置</li><li><strong>异步处理</strong>消除了昂贵的<code>DOM</code>和样式查询,连续轮询以及使用自定义插件的需求</li><li>Intersection Observer的三个步骤<ol><li>创建观察者</li><li>定义回调事件</li><li>定义要观察的目标对象</li></ol></li></ul><h4 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h4><ol><li><code>IntersectionObserver.observe(target)</code>:告诉要观察的目标元素</li><li><code>IntersectionObserver.takeRecords()</code>:从IntersectionObserver的通知队列中删除所有待处理的通知,并将它们返回到IntersectionObserver对象的新Array对象中</li><li><code>IntersectionObserver.unobserve()</code>指定停止观察特定目标元素</li><li><code>IntersectionObserver.disconnect()</code>:停止IntersectionObserver对象观察任何目标</li></ol><h4 id="创建观察者"><a href="#创建观察者" class="headerlink" title="创建观察者"></a>创建观察者</h4><ul><li>接收一个回调函数.只要目标元素发生变化就会触发回调函数</li><li>第二个参数是一个可选项</li></ul><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">let</span> options <span class="token operator">=</span> <span class="token punctuation">&#123;</span>  root<span class="token operator">:</span> document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">'#scrollArea'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  rootMargin<span class="token operator">:</span> <span class="token string">'0px'</span><span class="token punctuation">,</span>  <span class="token comment">//阈值为1.0表示当100%的目标在选项指定的元素中可见时,将调用回调</span>  <span class="token comment">//每个阈值是观测目标的交集区域与边界框区域的比率</span>  threshold<span class="token operator">:</span> <span class="token number">1.0</span><span class="token punctuation">&#125;</span><span class="token keyword">let</span> observer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">IntersectionObserver</span><span class="token punctuation">(</span>callback<span class="token punctuation">,</span> options<span class="token operator">?</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>option字段</p></blockquote><ol><li><code>root</code>:用作检查<strong>目标可见性的视口的元素</strong>.必须是目标的祖先.<span style="color:red">如果未指定或缺省为浏览器视口(html)</span></li><li><code>rootMargin</code><strong>根周围的边距</strong>(默认全部为0).语法类似于<code>margin</code>可以是百分比或者像素,用于在计算交集之前增大或缩小根元素边界框的矩形偏移量,有效的扩大或者缩小根的判定范围从而满足计算要求.(top,right,bottom,left)</li><li><code>threshold</code>:阈值.<strong>单个数字或数字数组</strong>.默认值为 0(这意味着只要有一个像素可见,就会运行回调)阈值是监听对象的交叉区域和边界区域的比例,每当监听对象超过阈值就会触发回调<ul><li>如果只想检测可见性何时超过 50% 标记,则可以使用值 0.5.</li><li>如果希望每次可见性每次超过 25% 时都运行回调,则应指定数组 [0, 0.25, 0.5, 0.75, 1]</li><li>如果值为 1.0 表示在每个像素可见之前,不会认为阈值已通过.</li></ul></li></ol><h4 id="监听观察的目标对象"><a href="#监听观察的目标对象" class="headerlink" title="监听观察的目标对象"></a>监听观察的目标对象</h4><blockquote><p>开启对目标对象的监听,如果没有</p></blockquote><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">const</span> target <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">".target"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> observer<span class="token punctuation">.</span><span class="token function">observe</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h4><blockquote><p>callback是添加监听后,当监听目标发生滚动变化时触发的回调函数.</p></blockquote><ul><li>第一个参数<code>entries</code>(数组),即<code>IntersectionObserverEntry</code>实例.描述了目标元素与root的交叉状态.</li></ul><table><thead><tr><th>属性</th><th align="center">说明</th></tr></thead><tbody><tr><td>boundingClientRect</td><td align="center">返回包含目标元素的边界信息,返回结果与element.getBoundingClientRect() 相同</td></tr><tr><td><strong>intersectionRatio</strong></td><td align="center">返回目标元素出现在可视区的比例</td></tr><tr><td>intersectionRect</td><td align="center">用来描述root和目标元素的相交区域</td></tr><tr><td><strong>isIntersecting</strong></td><td align="center">返回一个布尔值,下列两种操作均会触发回调:1.如果目标元素出现在root可视区,返回true.2. 如果从root可视区消失,返回false</td></tr><tr><td>rootBounds</td><td align="center">用来描述交叉区域观察者(intersection observer)中的根.</td></tr><tr><td>target</td><td align="center">目标元素:与根出现相交区域改变的元素 (Element)</td></tr><tr><td>time</td><td align="center">返回一个记录从 IntersectionObserver 的时间原点到交叉被触发的时间的时间戳</td></tr></tbody></table><ul><li>第二个参数就是<code>IntersectionObserver</code>这个实例对象本身.可以使用实例上的方法.</li></ul><h4 id="图片懒加载"><a href="#图片懒加载" class="headerlink" title="图片懒加载"></a>图片懒加载</h4><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">width</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>200px<span class="token punctuation">"</span></span> <span class="token attr-name">height</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>200px<span class="token punctuation">"</span></span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>logo.png<span class="token punctuation">"</span></span>    <span class="token attr-name">data-src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>0.jpg<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">width</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>200px<span class="token punctuation">"</span></span> <span class="token attr-name">height</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>200px<span class="token punctuation">"</span></span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>logo.png<span class="token punctuation">"</span></span>    <span class="token attr-name">data-src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>1.jpg<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">width</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>200px<span class="token punctuation">"</span></span> <span class="token attr-name">height</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>200px<span class="token punctuation">"</span></span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>logo.png<span class="token punctuation">"</span></span>    <span class="token attr-name">data-src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>2.jpg<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript">  <span class="token keyword">const</span> img <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementsByTagName</span><span class="token punctuation">(</span><span class="token string">'img'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">let</span> observe <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">IntersectionObserver</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">entries<span class="token punctuation">,</span> observe</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>    entries<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token parameter">item</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>item<span class="token punctuation">.</span>isIntersecting<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        item<span class="token punctuation">.</span>target<span class="token punctuation">.</span>src <span class="token operator">=</span> item<span class="token punctuation">.</span>target<span class="token punctuation">.</span>dataset<span class="token punctuation">.</span>src        observe<span class="token punctuation">.</span><span class="token function">unobserve</span><span class="token punctuation">(</span>item<span class="token punctuation">.</span>target<span class="token punctuation">)</span>      <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span> rootMargin<span class="token operator">:</span> <span class="token string">"0px 600px 0px -600px"</span> <span class="token punctuation">&#125;</span><span class="token punctuation">)</span>  <span class="token comment">// observe遍历监听所有img节点</span>  Array<span class="token punctuation">.</span><span class="token function">from</span><span class="token punctuation">(</span>img<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token parameter">img</span> <span class="token operator">=></span> observe<span class="token punctuation">.</span><span class="token function">observe</span><span class="token punctuation">(</span>img<span class="token punctuation">)</span><span class="token punctuation">)</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>先说一下<code>dataset</code>属性,可以在很多网站中看到这个data-为前缀的属性</p></blockquote><ul><li>dataset:浏览器很早就支持以键(data)-值命名的自定义属性了</li><li>设置属性:<code>Element.dataset.dart=&quot;dark&quot;</code>.例如上图代码(<code>item.target.dataset.dart=&quot;dark&quot;</code>)在挂载到标签时,会自动加上<code>data</code>这个键.就像这样<code>data-dart=&quot;dark&quot;</code></li><li>获取属性:<code>Element.dataset.src</code>,不需要加上<code>data-</code>前缀</li><li>删除属性:<code>delete Element.dataset.src</code></li><li>当然我们完全可以使用<code>getAttribute</code>等属性来进行自定义操作</li></ul><blockquote><p><code>HTMLCollectionOf&lt;&gt;</code>和<code>NodeListOf&lt;&gt;</code>的区别</p></blockquote><ul><li>参考:<a href="https://dom.spec.whatwg.org/#interface-htmlcollection">DOM 标准 (whatwg.org)</a></li><li>由于是历史遗留的产物,<code>HTMLCollectionOf</code>他返回的是一个集合,并不支持任何数组的高级api<ul><li>并且一切由<code>getElements...</code>返回的节点都是动态的集合类型,没有实现forEach等方法</li><li>动态的:如果基本的文档改变时.所有<code>HTMLCollection</code>对象会立即改变</li></ul></li><li><code>NodeListOf</code>是静态的.实现了所有的高级数组都有的api,<code>forEach</code>等<ul><li>了解了这些,使用元素选择的时候也可以使用<code>querySelectAll()</code>来选择元素.他会返回一个NodeListOf的类型</li></ul></li></ul><blockquote><p>理解可视区</p></blockquote><ul><li>重要的一点就是可视区的理解<ul><li><strong>intersectionRatio</strong>对应的是<code>threshold</code></li><li><strong>isIntersecting</strong>对应的是<code>rootMargin</code></li></ul></li><li>只要理解了<code>rootMargin</code>就很容易理解threshold的概念</li><li>理解margin,由于文档流的缘故,在设置margin的<code>top</code>或者<code>bottom</code>任意值的时候会移动盒子.如果设置<code>left</code>或者<code>right</code>必须同时设置才会改变盒子原来的位置,只设置一个值只会撑大盒子</li><li>例如上面图中设置的整体元素会向左移动600px.并且目标元素是相对于视口来说,但是理论上所有的图片都应该移动到视口之外的位置.并且不可以看到图片的懒加载.但是由于浏览器本身有一定的默认值,我们会得到最后一个图片是触发观察者实现懒加载的</li><li>明白了这个,就可以明白<code>threshold</code>,只有目标元素的可见性达到视口的一定比例(threshold的属性值)之后才可以触发观察者模式</li></ul><iframe height="300" style="width: 100%;" scrolling="no" title="IntersectionObserver" src="https://codepen.io/jack-zhang-1314/embed/YzYXYrV?default-tab=html%2Cresult" frameborder="no" loading="lazy" allowtransparency="true" allowfullscreen="true">  See the Pen <a href="https://codepen.io/jack-zhang-1314/pen/YzYXYrV">  IntersectionObserver</a> by Jack-Zhang-1314 (<a href="https://codepen.io/jack-zhang-1314">@jack-zhang-1314</a>)  on <a href="https://codepen.io">CodePen</a>.</iframe><h3 id="MutationObserver"><a href="#MutationObserver" class="headerlink" title="MutationObserver"></a>MutationObserver</h3><ul><li><code>Mutation Observer</code>是<strong>异步</strong>触发,DOM的变动并不会马上触发,而是要等到当前所有DOM&#96;操作都结束才触发</li><li>可以通过配置项,监听目标DOM下子元素的变更记录</li><li>构造函数返回一个新的,包含监听 DOM 变化回调函数的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/MutationObserver"><code>MutationObserver</code></a> 对象</li><li>使用用途<ul><li>一般用于更高性能的数据绑定及响应</li><li>实现视觉差滚动</li><li>图片预加载</li><li>实现富文本编辑器</li></ul></li></ul><h4 id="Mutation实例方法"><a href="#Mutation实例方法" class="headerlink" title="Mutation实例方法"></a>Mutation实例方法</h4><ol><li><code>MutationObserver.observe(dom,options)</code>:阻止<code>MutationObserver</code> 实例继续接收的通知,直到再次调用其<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/MutationObserver/observe"><code>observe()</code></a>方法,该观察者对象包含的回调函数都不会再被调用</li><li><code>MutationObserver.takeRecords()</code>:从MutationObserver的通知队列中删除所有待处理的通知,并将它们返回到<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/MutationRecord"><code>MutationRecord</code></a>(保存每次的变化信息)对象的新<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array"><code>Array</code></a></li><li><code>MutationObserver.disconnect()</code>:停止MutationObserver对象观察任何目标</li></ol><h4 id="Mutation创建观察者和监听目标对象"><a href="#Mutation创建观察者和监听目标对象" class="headerlink" title="Mutation创建观察者和监听目标对象"></a>Mutation创建观察者和监听目标对象</h4><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">const</span> MutationObserver <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MutationObserver</span><span class="token punctuation">(</span>callback<span class="token punctuation">)</span>MutationObserver<span class="token punctuation">.</span><span class="token function">observe</span><span class="token punctuation">(</span>dom<span class="token punctuation">,</span> options<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>第一个参数是一个dom对象,被观察子节点(目标元素)的父节点</li><li>第二个参数options是一个[MutationObserverInit | MDN (mozilla.org)](https:&#x2F;&#x2F;  developer.mozilla.org&#x2F;zh-CN&#x2F;docs&#x2F;conflicting&#x2F;Web&#x2F;API&#x2F;MutationObserver&#x2F;observe_2f2addbfa1019c23a6255648d6526387)对象<ul><li><code>attributeFilter</code>:(无默认值)要监视的特定属性名称的<strong>数组</strong>(如<code>[&#39;src&#39;,&#39;class&#39;]</code>).如果未包含此属性,则对所有属性的更改都会触发变动通知</li><li><code>attributes</code>:默认值false.设置true观察受监视元素的属性值变更</li><li><code>characterData</code>:无默认值.设为true监视指定目标节点或者子节点树中节点所包含的字符数据的变化</li><li><code>characterDataOldValue</code>:无默认值.设为true,是否观察文本的内容(文本节点)</li><li><code>childList</code>:默认值为false.设为true,监视木匾检点添加或删除新的子节点(不包括修改子节点以及子节点后代的变化).如果<code>subtree</code>为true,则包含子节点</li><li><code>subtree</code>:默认值为false,设置true,将监视范围扩展到目标节点以及子节点</li></ul></li><li>属性特定项<ul><li>其中调用 <code>observe()</code>方法时<code>childList</code>,<code>attributes</code>,<code>characterData</code> 或者<code>attributeOldValue</code>,<code>characterDataOldValue</code>两组中,至少有一个必须为 <code>true</code>,否则会抛出异常</li><li><code>attributeFilter/attributeOldValue</code> &gt; <code>attributes</code></li><li><code>characterDataOldValue</code> &gt; <code>characterData</code></li><li>避免重复的特定项,不需要同时设置同样的效果</li></ul></li></ul><h4 id="mutation回调函数"><a href="#mutation回调函数" class="headerlink" title="mutation回调函数"></a>mutation回调函数</h4><blockquote><p>同样是接收两个参数</p></blockquote><ul><li>第一个参数是<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/MutationRecord"><code>MutationRecords</code></a>,依然是一个数组.其中每个<code>MutationRecord</code>对象,记录着<code>DOM</code>每次发生变化的变动记录.<code>MutationRecord</code>对象包含了DOM的相关信息</li></ul><table><thead><tr><th>属性</th><th align="left">描述</th></tr></thead><tbody><tr><td><strong>target</strong></td><td align="left">被修改影响的目标 dom 节点</td></tr><tr><td><strong>type</strong></td><td align="left">变化的类型，也就是MutationObserverInit对象中的三种<code>attributes</code>,<code>characterData</code>或<code>childList</code>,并且返回该类型</td></tr><tr><td><strong>attributeName</strong></td><td align="left">针对<code>attributes</code>类型的变化时,返回被修改属性的名字(或者null)</td></tr><tr><td><strong>attributeNamespace</strong></td><td align="left">针对命名空间的<code>attributes</code>类型的变化.返回被修改属性的命名空间,或者null</td></tr><tr><td><strong>oldValue</strong></td><td align="left">如果在<code>MutationObserverInit</code>对象中启用(<code>attributeOldValue</code>或<code>characterDataOldValue</code>为true).则<code>attributes</code>或<code>characterData</code>的变化事件会返回变化之值或数据.<code>childList</code>类型的变化始终将这个属性设置为null</td></tr><tr><td><strong>addedNodes</strong></td><td align="left">针对<code>childList</code>的变化,返回包含变化中添加节点的<code>NodeList</code>,没有节点被添加,返回空<code>NodeList</code>数组</td></tr><tr><td><strong>previousSibling</strong></td><td align="left">对于<code>childList</code>变化.返回被添加或移除的节点之前的兄弟节点,或者null</td></tr><tr><td><strong>nextSibling</strong></td><td align="left">对于<code>childList</code>变化,返回被添加或移除的节点之后的兄弟节点.或者null</td></tr><tr><td><strong>removedNodes</strong></td><td align="left">对于<code>childList</code>变化,返回被移除的节点(没有则为null)</td></tr></tbody></table><ul><li>第二个参数就是<code>MutationObserver</code>这个实例对象本身.可以使用实例上的方法.</li></ul><blockquote><p><a href="https://juejin.cn/post/7036733000565915655"><code>MutationObserver</code>的引用</a></p></blockquote><ul><li><code>MutationObserver</code>对要观察的目标节点的引用属于<strong>弱引用</strong>,所以不会妨碍垃圾回收程序回收目标节点</li><li>目标节点对于<code>MutationObserver</code>是强引用.如果目标节点从DOM中被移除,随后被垃圾回收,则关联的 MutationObserver 也会被垃圾回收</li></ul><blockquote><p><code>MutationRecord</code>的引用</p></blockquote><ul><li><p><code>MutationRecord</code>实例至少包含对已有DOM节点的一个引用,即里面的target属性,如果变化是<code>childList</code>类型,则会包含多个节点的引用</p></li><li><p>记录队列和回调处理的默认行为是耗尽这个队列,处理每个<code>MutationRecord</code>,然后让它们超出作用域并被垃圾回收</p><ul><li><code>MutationObserver</code>核心是异步回调与记录队列模型.为了在大量变化事件发生时不影响性能,每次变化的信息<strong>由oberver实例决定</strong>.保存在<strong>MutationRecord</strong>实例中,然后添加到记录队列</li><li>记录队列对每个 <strong>MutationObserver</strong> 实例都是唯一的,是所有 <strong>DOM</strong> 变化事件的有序列表(DOM变化事件都会以数组的形式存在MutationRecord中),多次修改的信息会在一次回调中执行</li></ul></li><li><p>有时候需要保存某个观察者的完整变化记录,那么就保存所有的<code>MutationRecord</code> 实例,也就会保存它们引用的节点,而这会妨碍这些节点被回收</p></li><li><p>如果需要尽快地释放内存,可以从每个<code>MutationRecord</code>中抽取出最有用的信息,保存到一个新对象,然后释放<code>MutationRecord</code>中的引用</p></li></ul><h3 id="ResizeObserver-尚在开发"><a href="#ResizeObserver-尚在开发" class="headerlink" title="ResizeObserver(尚在开发)"></a>ResizeObserver(尚在开发)</h3><ul><li><p><strong><code>ResizeObserver</code></strong> 构造器创新一个新的<code>ResizeObserver</code>对象,用于接收<code>Element</code>内容区域的改变或<code>SVGElement</code>的边界框改变改变</p></li><li><p>用途:更智能的响应式布局(取代@media)以及响应式组件</p></li><li><p>由于resize事件会监听视窗的变化而不是元素的大小发生变化.可能一秒内会触发几十次,导致性能问题</p></li></ul><h4 id="Resize实例方法"><a href="#Resize实例方法" class="headerlink" title="Resize实例方法"></a>Resize实例方法</h4><ol><li><code>observe(target,options?)</code>:用于指定观察一个指定的<code>Element</code>或者<code>SVGElement</code></li><li><code>disconnect()</code>:停止和取消目标对象上所有对<code>Element</code>或者<code>SVGElement</code>监视</li><li><code>unobserve()</code>:用于结束一个指定的<code>Element</code>或者<code>SVGElement</code>监视</li></ol><h4 id="创建Resize实例"><a href="#创建Resize实例" class="headerlink" title="创建Resize实例"></a>创建Resize实例</h4><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">const</span> ResizeObserver <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ResizeObserver</span><span class="token punctuation">(</span>callback<span class="token punctuation">)</span>resizeObserver<span class="token punctuation">.</span><span class="token function">observe</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span>options<span class="token operator">?</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>options是一个指定观察设置的可选参数对象.目前只有一个可设置的选项<ul><li><code>box</code>:设置观察者将以哪种盒子模型来观察变动</li><li>可以设置为<code>content-box</code>(默认值),<code>border-box</code>或者<code>device-pixel-content-box</code></li></ul></li></ul><h4 id="Resize回调函数"><a href="#Resize回调函数" class="headerlink" title="Resize回调函数"></a>Resize回调函数</h4><ul><li><p>只接收一个<code>ResizeObserverEntry</code>实例<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/ResizeObserverEntry">ResizeObserverEntry - Web API 接口参考(mozilla.org)</a></p></li><li><p>目前只接受两个属性</p><ol><li><code>target</code>:当前改变尺寸大小的元素的引用</li><li><code>contentRect</code>:对改变尺寸大小的元素的<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/DOMRectReadOnly"><code>DOMRectReadOnly</code></a>引用(包含x,y(坐标),width,height,top,right,bottom,left属性)</li></ol></li></ul><h3 id="PerformanceObserver"><a href="#PerformanceObserver" class="headerlink" title="PerformanceObserver"></a>PerformanceObserver</h3><blockquote><p><strong><code>PerformanceObserver</code></strong> 用于监测性能度量事件,在浏览器的性能时间轴记录下一个新的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/PerformanceEntry">performance entries</a> 的时候将会被通知</p></blockquote><ul><li><p>用途:更细颗粒的性能监控.分析新跟那个对业务的影响(交互快&#x2F;慢是否会影响销量)</p></li><li><p>尽可能使用<code>PerformanceObserver</code>,而不是通过<code>Performance</code>获取性能参数及指标</p><ul><li><p>避免不知道性能事件啥时候会发生,需要重复轮训<code>timeline</code>获取记录。</p></li><li><p>避免产生重复的逻辑去获取不同的性能数据指标</p></li><li><p>避免其他资源需要操作浏览器性能缓冲区时产生竞态关系</p></li></ul></li></ul><blockquote><p>实例方法和MutationsObserver一样,但是<code>observe()</code>只接受<code>options</code></p></blockquote><h4 id="创建Performance实例"><a href="#创建Performance实例" class="headerlink" title="创建Performance实例"></a>创建Performance实例</h4><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">const</span> PerformanceObserver <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PerformanceObserver</span><span class="token punctuation">(</span>callback<span class="token punctuation">)</span>PerformanceObserver<span class="token punctuation">.</span><span class="token function">observe</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>entryTypes<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">"measure"</span><span class="token punctuation">]</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li><code>options</code>只接收一个entryTypes的键,值为一个性能检测数组</li></ul><table><thead><tr><th align="left">属性</th><th align="left">别名</th><th align="left">类型</th><th align="center">描述</th></tr></thead><tbody><tr><td align="left"><code>frame</code>, <code>navigation</code></td><td align="left">&#96;PerformanceFrameTiming, PerformanceNavigationTiming</td><td align="left">URL</td><td align="center">文件的地址</td></tr><tr><td align="left"><code>resource</code></td><td align="left">PerformanceResourceTiming</td><td align="left">URL</td><td align="center">文件请求资源解析的URL.只有在资源加载完毕后才会创建</td></tr><tr><td align="left"><code>mark</code></td><td align="left">PerformanceMark</td><td align="left">DOMString</td><td align="center">通过调用创建标记使用的名称.会在资源获取开始时创建(<code>performance.mark(name)</code>)</td></tr><tr><td align="left"><code>measure</code></td><td align="left">PerformanceMeasure</td><td align="left">DOMString</td><td align="center">通过调用创建度量时使用的名称.会在对资源操作时创建(<code>performance.measure(name)</code>)</td></tr><tr><td align="left"><code>paint</code></td><td align="left">PerformancePaintTiming</td><td align="left">DOMString</td><td align="center">渲染时间点的信息接口.找出那些花费太多时间去绘制的区域</td></tr></tbody></table><h4 id="Performance回调函数"><a href="#Performance回调函数" class="headerlink" title="Performance回调函数"></a>Performance回调函数</h4><blockquote><p>回调函数只接受一个参数,该参数是<code>PerformanceObserverEntryList</code>对象.该对象有三个接口</p></blockquote><ol><li><code>getEntries()</code>:返回所有的<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/PerformanceEntry"><code>PerformanceEntry</code></a>对象组成的数组</li><li><code>getEntriesByType(entryType)</code>:返回指定的<code>entryType</code>类型组合成的<code>PerformanceEntry</code>对象数组</li><li><code>getEntriesByName(name)</code>:返回通过指定的属性名(例如<code>performance.measure(name)</code>的name)组合成<code>PerformanceEntry</code>对象的数组</li></ol><blockquote><p><code>PerformanceEntry</code>对象</p></blockquote><ul><li>属性值:<ul><li><code>name</code>:该性能条目的名字.例如mark,measure通过指定名称name</li><li><code>entryType</code>:上述的options包含所有的entryType属性</li><li><code>startTime</code>:返回<code>PorformanceEntry</code>的第一个时间戳<ol><li><code>frame</code>:当页面开始加载时,返回的时间戳</li><li><code>mark</code>:当使用<code>performance.mark(name)</code>创建mark标记之后返回的时间戳</li><li><code>measure</code>:当使用<code>performance.measure(name)</code>创建measure标记之后返回的时间戳</li><li><code>navigation</code>:返回值为0的时间戳</li><li><code>resource</code>:返回浏览器开始获取资源的时间戳</li></ol></li><li><code>duration</code>:该资源的耗时时间</li></ul></li><li>方法:<code>toJSON()</code>:返回 JSON 格式数据的PerformanceEntry对象</li></ul><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token special-attr"><span class="token attr-name">onclick</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span><span class="token value javascript language-javascript"><span class="token function">measureClick</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span><span class="token punctuation">"</span></span></span><span class="token punctuation">></span></span>Measure<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://zyjcould.ltd/blog/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%A7%86%E5%8F%A3.png<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript">    <span class="token keyword">const</span> performanceObserver <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PerformanceObserver</span><span class="token punctuation">(</span><span class="token parameter">list</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>      list<span class="token punctuation">.</span><span class="token function">getEntries</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token parameter">entry</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>entry<span class="token punctuation">.</span>entryType<span class="token punctuation">)</span><span class="token punctuation">;</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>entry<span class="token punctuation">.</span>startTime<span class="token punctuation">)</span><span class="token punctuation">;</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>entry<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>entry<span class="token punctuation">.</span>duration<span class="token punctuation">)</span><span class="token punctuation">;</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>entry<span class="token punctuation">.</span><span class="token function">toJSON</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    performanceObserver<span class="token punctuation">.</span><span class="token function">observe</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span> entryTypes<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">'resource'</span><span class="token punctuation">,</span> <span class="token string">'mark'</span><span class="token punctuation">,</span> <span class="token string">'measure'</span><span class="token punctuation">]</span> <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    performance<span class="token punctuation">.</span><span class="token function">mark</span><span class="token punctuation">(</span><span class="token string">'registered-observer'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">function</span> <span class="token function">measureClick</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      performance<span class="token punctuation">.</span><span class="token function">measure</span><span class="token punctuation">(</span><span class="token string">'button clicked'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>  </span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="ReportingObserver-实验"><a href="#ReportingObserver-实验" class="headerlink" title="ReportingObserver(实验)"></a>ReportingObserver(实验)</h3><blockquote><p><code>ReportingObserver()</code> 构造函数会创建一个新的 <a href="https://developer.mozilla.org/en-US/docs/Web/API/ReportingObserver"><code>ReportingObserver</code></a> 对象实,该实例可用于收集和获取reports</p></blockquote><ul><li>使用:将浏览器弃用的<code>API</code>或者运行时<strong>浏览器的干预行为</strong>由自己约束<ul><li>违反浏览器的选项时</li><li>JS的异常和错误(替代<code>window.onerror</code>)</li><li>未处理的promise的<code>reject</code>(替代<code>window.onunhandledrejection</code>)</li></ul></li></ul><blockquote><p>ReportingObserver实例方法和<code>MutationObserver</code>的实例方法一样.但是<code>observer()</code>不需要任何参数</p></blockquote><h4 id="创建Reporting实例"><a href="#创建Reporting实例" class="headerlink" title="创建Reporting实例"></a>创建Reporting实例</h4><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">let</span> options <span class="token operator">=</span> <span class="token punctuation">&#123;</span>  types<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">'deprecation'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  buffered<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">&#125;</span><span class="token keyword">const</span> reportingObserver<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">ReportingObserver</span><span class="token punctuation">(</span>callback<span class="token punctuation">,</span> options<span class="token operator">?</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>options提供两个属性,<code>types</code>和<code>buffered</code></li></ul><ol><li><p><code>types</code>:提供三个属性值</p><ul><li><code>deprecation</code>:浏览器运行时遇到弃用的api会打印这个选项</li><li><code>intervention</code>:浏览器自己的干预行为.可能遇到一些不安全的行为(如带有不安全的iframe,过时的api等)</li><li><code>crash</code>:浏览器崩溃时的行为</li></ul></li><li><p><code>buffered</code>:布尔值,如果时true,可以查看创建观察者之前生成的报告(使用于延迟加载的情况,不会错过页面加载之前发生的事情)</p></li></ol><h4 id="Reporting回调函数"><a href="#Reporting回调函数" class="headerlink" title="Reporting回调函数"></a>Reporting回调函数</h4><blockquote><p>提供两个参数,第一个参数是一个<code>reports</code>数组对象.同样也可以通过<code>takeRecords()</code>实例方法获取这些数组</p></blockquote><ul><li><code>report</code>对象有三个属性:<code>body</code>,<code>type</code>,<code>url</code><ul><li><code>type</code>:返回的是report类型,即options选项中的types</li><li><code>url</code>:返回的是生成report的文档</li><li><code>body</code>:返回report正文,包含详细的report对象,目前只有两种<strong>body对象</strong>(却决于type的返回值)<ol><li><a href="https://developer.mozilla.org/en-US/docs/Web/API/DeprecationReportBody"><code>DeprecationReportBody、InterventionReportBody</code></a><ul><li><code>id</code>:已弃用的功能或 API 的字符串</li><li><code>anticipatedRemoval</code>:Data对象,表示应从浏览器中要删除的日期.如果日期位置,返回null</li><li><code>message</code>:字符串,api的弃用说明.包括新功能的取代说明</li><li><code>sourceFile</code>:string类型,使用已弃用api的源文件路径.已知或其他返回null</li><li><code>lineNumber</code>:number类型,表示源文件中使用已弃用的功能的行.已知或其他返回null</li><li><code>columnNumber</code>:number类型,表示源文件中使用已弃用的功能的行&#x3D;列.已知或其他返回null</li></ul></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/API/CrashReportBody"><code>CrashReportBody</code></a><ul><li><code>reason</code>:表示崩溃原因的字符串.如果返回的是<code>oom</code>:浏览器内存不足.如果返回的是<code>unresponsive</code>:页面由于无响应而被终止</li></ul></li></ol></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Observer&quot;&gt;&lt;a href=&quot;#Observer&quot; class=&quot;headerlink&quot; title=&quot;Observer&quot;&gt;&lt;/a&gt;Observer&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;网页开发中经常会和用户交互而使用一些监听事件(例如onclick,</summary>
      
    
    
    
    <category term="JS" scheme="http://mail.zyjcould.ltd/categories/JS/"/>
    
    
    <category term="JS" scheme="http://mail.zyjcould.ltd/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>blob</title>
    <link href="http://mail.zyjcould.ltd/2022/03/07/blob/"/>
    <id>http://mail.zyjcould.ltd/2022/03/07/blob/</id>
    <published>2022-03-07T12:32:14.000Z</published>
    <updated>2022-03-26T10:37:34.051Z</updated>
    
    <content type="html"><![CDATA[<h2 id="blob"><a href="#blob" class="headerlink" title="blob"></a>blob</h2><blockquote><p>blob对象使用不可变的,原始数据的类文件对象.他的数据可以是文本或者二进制的格式进行读取,同时也可以转换成<code>ReadableStream</code>来读取操作</p></blockquote><ol><li>Blob不一定表示js的原生格式的数据.<code>File</code>接口基于Blob,继承了blob的功能,并将起扩展使其支持用于系统上的文件</li><li>要从其他非blob对象和数据构造一个 <code>Blob</code>,请使用 <code>Blob()</code> 构造函数</li><li>要创建一个 blob 数据的子集 blob,请使用<code>slice()</code>方法</li><li>要获取用户文件系统上的文件对应的Blob对象,请参阅<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/File">File</a>文档</li></ol><h3 id="Blob"><a href="#Blob" class="headerlink" title="Blob()"></a>Blob()</h3><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">const</span> aBlob <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Blob</span><span class="token punctuation">(</span> array<span class="token punctuation">,</span> options <span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><strong>array</strong>是由:<code>ArrayBuffer</code>, <code>ArrayBufferView</code>, <code>Blob</code>, <code>DOMString</code> 等对象构成的 Array ,或者其他类似对象的混合体,它将会被放进 Blob</li><li><strong>options</strong>施一公可选的<code>BlobPropertyBag</code>字典:<ol><li><code>type</code>,默认值为 “”,为<strong>数组内容的MIME类型</strong></li><li><code>endings</code>,默认值为”transparent”,用于指定包含行结束符\n的字符串如何被写入<ul><li><code>&quot;native&quot;</code>,代表行结束符会被更改为适合宿主操作系统文件系统的换行符</li><li><code>&quot;transparent&quot;</code>,代表会保持blob中保存的结束符不变</li></ul></li></ol></li></ul><blockquote><p>属性(只读)</p></blockquote><ul><li><code>Blob.size</code>:Blob 对象中所包含数据的大小(字节)</li><li><code>Blob.type</code>:一个字符串,表明该Blob对象所包含数据的<strong>MIME</strong>类型.(未知则是<code>&quot;&quot;</code>)</li></ul><h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><ul><li><code>blob.text()</code>:返回一个 promise 对象,以 <code>resolve</code> 状态返回一个以文本形式包含 blob 中数据的 <code>USVString</code></li></ul><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">let</span> str <span class="token operator">=</span> <span class="token string">"xhr"</span><span class="token keyword">const</span> blob <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Blob</span><span class="token punctuation">(</span><span class="token punctuation">[</span>str<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span>  type<span class="token operator">:</span> <span class="token string">"text/plain"</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span>blob<span class="token punctuation">.</span><span class="token function">text</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">res</span> <span class="token operator">=></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>blob.stream()</code>:方法返回一个<strong>ReadableStream</strong>对象,读取它将返回包含在Blob中的数据</li><li><code>blob.slice()</code>:方法创建并返回一个新对象,该对象包含来自调用它的<code>blob</code>子集的数据<ol><li><code>start</code>可选.默认值为 0.<span style="color:red">Blob中的索引,指示要包含在新 Blob 中的第几个字节</span>.指定的值大于源Blob的大小,默认为0,并且不包含任何数据.如果指定负值,则会将其视为从 Blob 末尾到开头的偏移量.例如,-10 将是 Blob 中距离最后一个字节的第 10 个字节.</li><li><code>end</code>可选.缺省值为<strong>size</strong>lob 中的索引,指示 Blob 中的末尾字节(不包含此索引中的字节).如果指定负值,和start一样.</li><li><code>contentType</code>可选.默认值为空字符串.要分配给新 Blob 的内容类型</li></ol></li><li><code>blob.arrayBuffer()</code>:返回一个 Promise,该 Promise 将 blob 的内容解析为<code>ArrayBuffer</code>中包含的二进制数据</li></ul><blockquote><p>文件的下载.&lt;a&gt;中在h5中有一个新属性<code>download</code>(可以设置下载的名称),当链接的地址是同源的时候会进行下载</p></blockquote><ul><li>windows上的<code>URL.createObjectURL()</code>静态方法创建一个<code>DOMString</code>,其中返回值表示参数中给定对象的URL.</li><li>URL 生存期与创建文档的窗口中的文档相关联.新对象 URL 表示指定的<code>File对象</code>或<code>Blob 对象</code>.</li><li>要释放URL对象,请调用<code>revokeObjectURL()</code></li></ul><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>btn<span class="token punctuation">"</span></span> <span class="token attr-name">download</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>index.html<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>下载<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript">  <span class="token keyword">const</span> str <span class="token operator">=</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">&lt;div style="color: red;font-size:5rem">hello world&lt;/div></span><span class="token template-punctuation string">`</span></span>  <span class="token keyword">const</span> blob <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Blob</span><span class="token punctuation">(</span><span class="token punctuation">[</span>str<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span> type<span class="token operator">:</span> <span class="token string">'text/html'</span> <span class="token punctuation">&#125;</span><span class="token punctuation">)</span>  document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"btn"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function-variable function">onclick</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setAttribute</span><span class="token punctuation">(</span><span class="token string">'href'</span><span class="token punctuation">,</span> <span class="token constant">URL</span><span class="token punctuation">.</span><span class="token function">createObjectURL</span><span class="token punctuation">(</span>blob<span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token punctuation">&#125;</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="File"><a href="#File" class="headerlink" title="File()"></a>File()</h3><blockquote><p>首先了解<code>Filelist</code>,此类型是由HTML&lt;input type&#x3D;”file”&gt;元素的属性返回</p></blockquote><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>fileItem<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>file<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>File对象:文件列表会放在在files数组中</li></ul><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">var</span> file <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'fileItem'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>files<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>常情况下,<code>File</code>对象是来自用户在一个<input>元素上选择文件后返回的 <code>FileList</code> 对象</p></blockquote><ul><li>由于<code>File</code>对象是特殊类型的<code>Blob</code>,且可以用在任意的<code>Blob</code>类型的<code>context</code>中</li><li>File对象同样是构造函数(<code>new File()</code>).除了继承了Blob的方法属性以外,还有以下方法</li></ul><blockquote><p>属性</p></blockquote><ol><li><code>file.lastModified</code>:返回所引用文件最后修改日期, 为自 1970年1月1日0:00 以来的毫秒数</li><li><code>file.lastModified</code>返回当前文件的最后修改日期,如果无法获取到文件的最后修改日期,则使用当前日期来替代</li><li><code>file.name</code>:返回文件的名称.由于安全原因,返回的值并不包含文件路径.</li></ol><h3 id="FileReader"><a href="#FileReader" class="headerlink" title="FileReader()"></a>FileReader()</h3><blockquote><p><code>FileReader</code>对象允许网络程序或异步读取存储在计算机上应用的数据文件(或原始数据用户)的内容,使用File或Blob 指定要读取的文件</p></blockquote><ul><li>通常情况下:文件对象可以是来自其中一个&lt;input&gt;元素上选择文件的<code>FileList</code>对象</li><li>同样这是一个构造函数<code>new FileReader()</code></li></ul><blockquote><p>属性</p></blockquote><ol><li><p><code>FileReader.error</code>:只读.表示在读取文件时发生的错误</p></li><li><p><code>FileReader.readyState</code>:只读.表示FileReader状态的数字</p><table><thead><tr><th>特征名</th><th>值</th><th>描述</th></tr></thead><tbody><tr><td>EMPTY</td><td>0</td><td>还没有加载数据</td></tr><tr><td>LOADING</td><td>1</td><td>数据正在被加载</td></tr><tr><td>DONE</td><td>2</td><td>已完成全部的读取请求</td></tr></tbody></table></li><li><p><code>FileReader.result</code>:只读.该属性仅在读取操作完成才有效,数据格式的使用后的方法来启动读取操作.</p></li></ol><blockquote><p>FileReader接口的事件</p></blockquote><table><thead><tr><th>事件</th><th>描述</th></tr></thead><tbody><tr><td>onabort</td><td>中断</td></tr><tr><td>onerror</td><td>出错</td></tr><tr><td>onloadstart</td><td>开始</td></tr><tr><td>onprogress</td><td>正在读取</td></tr><tr><td>onload</td><td>成功读取</td></tr><tr><td>onloadend</td><td>读取完成,无论成功失败</td></tr></tbody></table><blockquote><p>FileReader接口有4个方法,其中3个用来读取文件,另一个用来中断读取.无论读取成功或失败,方法并不会返回读取结果,这一结果存储在result属性中</p></blockquote><table><thead><tr><th>方法名</th><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>readAsArrayBuffer</td><td>file&#x2F;blob</td><td>读取指定Blob  或文件的内容.完成后<code>readyState</code>变为Done,并且触发<code>loadend</code>.<code>result</code>以<code>ArrayBufer</code>返回文件的数据</td></tr><tr><td>readAsText</td><td>file&#x2F;blob</td><td><code>result</code>以文本字符串的形式返回文件内容.其余与上个属性相同</td></tr><tr><td>readAsDataURL</td><td>file&#x2F;blob</td><td><code>result</code>以url的形式返回文件的数据(文件的数据会以base64的编码表示).其余与上个属性相同</td></tr><tr><td>abort</td><td>(none)</td><td>终端读取操作</td></tr></tbody></table><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>file<span class="token punctuation">"</span></span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>input<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript">document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"input"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function-variable function">onchange</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">let</span> file <span class="token operator">=</span> e<span class="token punctuation">.</span>target<span class="token punctuation">.</span>files<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>  <span class="token keyword">let</span> img <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Image</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token keyword">let</span> fileReader <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileReader</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  document<span class="token punctuation">.</span>body<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>img<span class="token punctuation">)</span>  fileReader<span class="token punctuation">.</span><span class="token function">readAsDataURL</span><span class="token punctuation">(</span>file<span class="token punctuation">)</span>  fileReader<span class="token punctuation">.</span><span class="token function-variable function">onload</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    img<span class="token punctuation">.</span>src <span class="token operator">=</span> fileReader<span class="token punctuation">.</span>result    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>fileReader<span class="token punctuation">.</span>result<span class="token punctuation">)</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;blob&quot;&gt;&lt;a href=&quot;#blob&quot; class=&quot;headerlink&quot; title=&quot;blob&quot;&gt;&lt;/a&gt;blob&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;blob对象使用不可变的,原始数据的类文件对象.他的数据可以是文本或者二进制的格式进行读取,同时也</summary>
      
    
    
    
    <category term="TS" scheme="http://mail.zyjcould.ltd/categories/TS/"/>
    
    
    <category term="JS" scheme="http://mail.zyjcould.ltd/tags/JS/"/>
    
    <category term="TS" scheme="http://mail.zyjcould.ltd/tags/TS/"/>
    
  </entry>
  
  <entry>
    <title>TS装饰器</title>
    <link href="http://mail.zyjcould.ltd/2022/03/05/ts-zhuang-shi-qi/"/>
    <id>http://mail.zyjcould.ltd/2022/03/05/ts-zhuang-shi-qi/</id>
    <published>2022-03-05T04:00:53.000Z</published>
    <updated>2022-03-19T08:12:04.883Z</updated>
    
    <content type="html"><![CDATA[<h2 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h2><blockquote><p>装饰器是一种特殊的类型声明,他能被附加到类声明,方法,访问符,属性或者参数上,可以修改类的行为.装饰器使用<code>@experssion</code>的形式(更像是<code>defineProperty</code>的语法糖)<span style="color:red">他会在运行时被调用,被装饰器的声明信息做为参数传入</span></p></blockquote><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">function test(target: any) &#123;  console.log(&quot;hello world&quot;)&#125;@testclass A &#123;&#125;&#x2F;&#x2F;hello world<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol><li>类(Class)</li><li>类属性(Class Property)</li><li>类方法(Class Method)</li><li>类访问器(Class Accessor)</li><li>类方法参数(Class Method Parameter)</li></ol><ul><li>因此,应用装饰器很像组成一系列函数,非常像高阶函数或类.使用装饰器,我们可以轻松实现代理模式来减少代码</li><li>对于这几种装饰器,都可以使用工厂模式来达到传入想要修改属性的目的(或者其它)</li></ul><h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a><a href="proxy.md">代理模式</a></h3><blockquote><p>代理模式是在访问真正对象时,提供额外的逻辑,检查对真实对象的操作.例如在对真实对象操作占用大量资源时,进行缓存,或者在调用对真实对象的操作之前检查前提条件</p></blockquote><ul><li>例如javascript中的proxy就是一个典型的代理模式</li></ul><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">const</span> target <span class="token operator">=</span> <span class="token punctuation">&#123;</span>  name<span class="token operator">:</span> <span class="token string">'zhangsan'</span><span class="token punctuation">&#125;</span><span class="token keyword">const</span> handler <span class="token operator">=</span> <span class="token punctuation">&#123;</span>  <span class="token function">get</span> <span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>key<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token string"> 被读取</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span>    <span class="token keyword">return</span> target<span class="token punctuation">[</span>key<span class="token punctuation">]</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>  <span class="token function">set</span> <span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>key<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token string"> 被设置为 </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>value<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span>    target<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> value  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">const</span> proxy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> handler<span class="token punctuation">)</span>proxy<span class="token punctuation">.</span>name<span class="token comment">//name 被读取</span>proxy<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'lisi'</span><span class="token comment">//name 被设置为 lisi</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>target<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token comment">//lisi</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="定义装饰器"><a href="#定义装饰器" class="headerlink" title="定义装饰器"></a>定义装饰器</h3><blockquote><p>由于TypeScript中的装饰器还在实验性语法,需要在<code>tsconfig.json</code>编译选项中开启</p></blockquote><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token punctuation">&#123;</span>  <span class="token property">"compilerOptions"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>      <span class="token property">"experimentalDecorators"</span><span class="token operator">:</span> <span class="token boolean">true</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>装饰器的执行时机:装饰器对类的行为的改变,是<strong>代码编译时发生的</strong>(不是TypeScript编译,而是js在执行机中的编译阶段),并不是在运行是.<span style="color:red">本质就是装饰器是编译时执行的函数</span></li></ul><h4 id="类装饰器"><a href="#类装饰器" class="headerlink" title="类装饰器"></a>类装饰器</h4><ul><li>类装饰器在类声明之前绑定,可以用来监视,或者修改或者替换类定义</li><li>在执行类装饰器函数的时候,会把绑定的类作为器唯一的参数传递给装饰器</li><li>参数:<strong>类的构造器</strong><ul><li>如果装饰器返回一个新的类,他会用新的类替换原有的类的定义</li><li><span style="color:red">类装饰器适合用于继承一个现有类并添加一些属性和方法</span></li></ul></li></ul><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">function test() &#123;  return function (target: any) &#123;    person.prototype.name &#x3D; &quot;jack&quot;    person.prototype.say &#x3D; function () &#123;      console.log(this.name)    &#125;  &#125;&#125;@testclass Person &#123;  name: string  constructor(name: string) &#123;    this.name &#x3D; name  &#125;  say() &#123;    console.log(&quot;lisi&quot;)  &#125;&#125;new Person(&quot;fw&quot;).say()&#x2F;&#x2F;fwconsole.log(new Person(&quot;fw&quot;).name)&#x2F;&#x2F;fw<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>name属性并不会像想象中的那样变为:<strong>jack</strong>.那首先我们得明白他的初始化机制<ol><li>在Person类初始化之后,会先执行装饰器,而不是直接使用new关键字</li><li>name首先被初始化为<code>jack</code>,然后使用new产生对象,传入的<code>fw</code>会覆盖<code>jack</code>属性</li></ol></li></ul><h4 id="方法装饰器"><a href="#方法装饰器" class="headerlink" title="方法装饰器"></a>方法装饰器</h4><ul><li><p>方法装饰器写在一个方法的声明之前</p></li><li><p>方法装饰器可以用来监视,修改或者替换方法定义</p></li><li><p>方法装饰器表达式会在运行时当作函数被调用,传入一下三个参数</p><ol><li>对于静态成员来说是类的构造函数,对于实例成员是类的<strong>原型对象</strong></li><li>被绑定方法的名字</li><li>被绑定方法的属性描述符</li></ol></li><li><p>方法装饰器更像是<code>defineProperty</code>的一个语法糖</p></li></ul><table><thead><tr><th>属性</th><th>描述</th><th>默认值</th></tr></thead><tbody><tr><td>value</td><td>当试图获取属性时所返回的值</td><td>undefined</td></tr><tr><td>writable</td><td>该属性是否可写</td><td>false</td></tr><tr><td>enumerable</td><td>该属性在for in循环中是否会被枚举</td><td>false</td></tr><tr><td>configurable</td><td>该属性是否可被删除</td><td>false</td></tr><tr><td>set()</td><td>属性的更新操作所调用的函数</td><td>false</td></tr><tr><td>get()</td><td>获取属性值时所调用的函数</td><td>false</td></tr></tbody></table><ol><li>数据描述符:enumerable,configurable,value,writable</li><li>存取描述符:enumerable,configurable,set(),get()</li><li>如果定义了set(),get()之后,再定义value,writable会<span style="color:red">报错</span></li></ol><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">function test(target: any, key: string, descriptor: PropertyDescriptor) &#123;  console.log(target)  &#x2F;&#x2F;&#123;  &#125;  console.log(key)&#x2F;&#x2F;say  console.log(descriptor)  &#x2F;&#x2F;&#123;  &#x2F;&#x2F;value: [Function (anonymous)],  &#x2F;&#x2F;writable: true,  &#x2F;&#x2F;enumerable: false,  &#x2F;&#x2F;configurable: true  &#x2F;&#x2F;&#125;  descriptor.value &#x3D; function () &#123;    console.log(&quot;test&quot;)  &#125;&#x2F;&#x2F;输出test,而不是&#96;我是fw&#96;&#125;class Person &#123;  @test  say() &#123;    console.log(&quot;我是fw&quot;)  &#125;  sayName() &#123;    console.log(&quot;我是zhangsan&quot;)  &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>当然使用工厂函数会是更好的选择</li></ul><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">function configurable(value: boolean) &#123;  return function (target: any, propertyKey: string, descriptor: PropertyDescriptor) &#123;    descriptor.configurable &#x3D; value;  &#125;;&#125;@configurable(false)...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="访问器装饰器"><a href="#访问器装饰器" class="headerlink" title="访问器装饰器"></a>访问器装饰器</h4><ul><li>访问器装饰器声明在一个访问器的声明之前.</li><li>访问器装饰器应用于访问器的属性描述符并且可以用来监视,修改或替换一个访问器的定义</li><li>访问器装饰器表达式会在运行时当作函数被调用,传入下列3个参数:<ul><li>对于静态成员来说是类的构造函数,对于实例成员是类的<strong>原型对象</strong>.</li><li>成员的名字.</li><li>成员的属性描述符.</li></ul></li></ul><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">function test() &#123;  return function (target: any, key: string, descriptor: PropertyDescriptor) &#123;    console.log(target) &#x2F;&#x2F;&#123;&#125;,原型对象上并没有任何属性    console.log(key) &#x2F;&#x2F;name.构造器的名称    console.log(descriptor)    &#x2F;&#x2F;&#123;    &#x2F;&#x2F;get: [Function: get name],    &#x2F;&#x2F;set: [Function: set name],    &#x2F;&#x2F;enumerable: false,    &#x2F;&#x2F;configurable: true    &#x2F;&#x2F;&#125;    descriptor.set &#x3D; function (value) &#123;      value &#x3D; value + &quot;fw&quot;      target.myName &#x3D; value    &#125;    descriptor.get &#x3D; function () &#123;      return target.myName    &#125;  &#125;&#125;class Person &#123;  private _name: string  myName!: string  constructor(name: string) &#123;    this._name &#x3D; name  &#125;  @test  get name() &#123;    return this._name  &#125;  set name(value) &#123;    this._name &#x3D; value  &#125;&#125;const p &#x3D; new Person(&quot;zhangsan&quot;)p.name &#x3D; &quot;lisi&quot;console.log(p.name)&#x2F;&#x2F;&quot;lisifw&quot;console.log(p)&#x2F;&#x2F; &#123; _name: &#39;zhangsan&#39; &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>注意:<span style="color:red">TypeScript不允许同时装饰一个成员的get和set访问器</span></li></ul><h4 id="参数装饰器"><a href="#参数装饰器" class="headerlink" title="参数装饰器"></a>参数装饰器</h4><ul><li>参数装饰器写在一个参数声明之前.</li><li>参数装饰器表达式会在运行时当作函数被调用,传入下列3个参数:<ul><li>对于静态成员来说是类的构造函数,对于实例成员是类的<strong>原型对象</strong>.</li><li>参数所在的方法名称.</li><li>参数在参数列表中的索引.</li></ul></li></ul><blockquote><p>注意:属性装饰器,参数装饰器最常见的应用场景就是配合元数据(reflect-metadata),在不改变原有结构的同时添加一些额外的信息</p></blockquote><ul><li>但是元数据目前也是在提案中, 也还没有纳入正式的标准.所以对于装饰器而言, 我们只需要了解即可,因为提案中的所有内容将来都是有可能被修改的(可能会被修改)</li></ul><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">function test() &#123;  return function (target: any, proptyName: string, index: number) &#123;    console.log(target)&#x2F;&#x2F;&#123;&#125;    console.log(proptyName)&#x2F;&#x2F;say    console.log(index)&#x2F;&#x2F;1  &#125;&#125;class Person &#123;  say(age: number, @test() name: string): void &#123;    console.log(age + name)  &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="属性装饰器"><a href="#属性装饰器" class="headerlink" title="属性装饰器"></a>属性装饰器</h4><ul><li>属性装饰器写在一个属性声明之前</li><li>属性装饰器表达式会在运行时当作函数被调用,传入下列2个参数:<ul><li>对于静态成员来说是类的构造函数,对于实例成员是类的<strong>原型对象</strong></li><li>成员的名字</li></ul></li></ul><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">function test(flag:string)&#123;  console.log(flag);&#x2F;&#x2F;hello  return (target: any, propertyKey: string) &#x3D;&gt;&#123;      console.log(target);&#x2F;&#x2F;class[person]      console.log(propertyKey);&#x2F;&#x2F;age  &#125;&#125;class Person&#123;  name:string;  @test(&#39;hello&#39;)  static age:number;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="装饰器的执行顺序"><a href="#装饰器的执行顺序" class="headerlink" title="装饰器的执行顺序"></a>装饰器的执行顺序</h3><blockquote><p>不同装饰器的执行顺序是固定的</p></blockquote><ol><li>实例成员:方法&#x2F;访问器&#x2F;属性装饰器-&gt;参数装饰器</li><li>静态成员:方法&#x2F;访问器&#x2F;属性装饰器-&gt;参数装饰器</li><li>类装饰器</li><li>构造器:参数装饰器</li></ol><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">function f(key: string): any &#123;  console.log(&quot;evaluate: &quot;, key)  return function () &#123;    console.log(&quot;call: &quot;, key)  &#125;&#125;@f(&quot;Class Decorator&quot;)class C &#123;  @f(&quot;Static Property&quot;)  static prop?: number  @f(&quot;Static Method&quot;)  static method(@f(&quot;Static Method Parameter&quot;) foo: number) &#123;&#125;  constructor(@f(&quot;Constructor Parameter&quot;) foo: number) &#123;&#125;  @f(&quot;Instance Method&quot;)  method(@f(&quot;Instance Method Parameter&quot;) foo: number) &#123;&#125;  @f(&quot;Instance Property&quot;)  prop?: number&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">&#x2F;&#x2F;实例方法-&gt;参数evaluate:  Instance Methodevaluate:  Instance Method Parametercall:  Instance Method Parametercall:  Instance Method&#x2F;&#x2F;实例属性evaluate:  Instance Propertycall:  Instance Property&#x2F;&#x2F;静态属性evaluate:  Static Propertycall:  Static Property&#x2F;&#x2F;静态方法evaluate:  Static Methodevaluate:  Static Method Parametercall:  Static Method Parametercall:  Static Method&#x2F;&#x2F;类装饰器-&gt;构造函数:参数装饰器evaluate:  Class Decoratorevaluate:  Constructor Parametercall:  Constructor Parametercall:  Class Decorator<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>对于属性访问装饰器(动态&#x2F;静态)而言,会按照声明的顺序声明它们的装饰器的顺序</li></ul><blockquote><p>同样方法中不同参数的装饰器的执行顺序是相反的,最后一个参数的装饰器会最先被执行</p></blockquote><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">class C &#123;  method(@f(&quot;Parameter Foo&quot;) foo: number, @f(&quot;Parameter Bar&quot;) bar: number) &#123;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">evaluate:  Parameter Fooevaluate:  Parameter Barcall:  Parameter Barcall:  Parameter Foo<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>一些可能用到的场景</p></blockquote><ul><li>Before&#x2F;After钩子.</li><li>监听属性改变或者方法调用.</li><li>对方法的参数做转换.</li><li>添加额外的方法和属性.</li><li>运行时类型检查.</li><li>自动编解码.</li><li>依赖注入.</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;装饰器&quot;&gt;&lt;a href=&quot;#装饰器&quot; class=&quot;headerlink&quot; title=&quot;装饰器&quot;&gt;&lt;/a&gt;装饰器&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;装饰器是一种特殊的类型声明,他能被附加到类声明,方法,访问符,属性或者参数上,可以修改类的行为.装饰器使用</summary>
      
    
    
    
    <category term="TS" scheme="http://mail.zyjcould.ltd/categories/TS/"/>
    
    
    <category term="JS" scheme="http://mail.zyjcould.ltd/tags/JS/"/>
    
    <category term="TS" scheme="http://mail.zyjcould.ltd/tags/TS/"/>
    
  </entry>
  
  <entry>
    <title>递归</title>
    <link href="http://mail.zyjcould.ltd/2022/03/04/di-gui/"/>
    <id>http://mail.zyjcould.ltd/2022/03/04/di-gui/</id>
    <published>2022-03-04T14:11:59.000Z</published>
    <updated>2022-03-19T08:12:04.944Z</updated>
    
    <content type="html"><![CDATA[<h2 id="递归-recursion"><a href="#递归-recursion" class="headerlink" title="递归(recursion)"></a>递归(recursion)</h2><blockquote><p>程序调用自身的技巧就被称之为递归(recursion)</p></blockquote><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">function factorial(n: number): number &#123;  if (n &lt;&#x3D; 1) &#123;    return 1  &#125;  return n * factorial(n - 1)&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>从阶乘这里看出,递归是需要条件的</p></blockquote><ul><li>递归序要具备<strong>边界条件</strong>,<strong>递归前进段</strong>以及<strong>递归返回段</strong>.当边界条件不满足时,递归前进,当边界满足时,递归返回.例如阶乘中的<code>n&lt;=1</code>就是边界条件</li><li>如何使用递归  <ol><li>子问题须与原始问题为同样的事,使用递归化繁为简</li><li>不能无限制的调用本身,必须要有一个出口,化简为非递归的状态处理</li></ol></li></ul><blockquote><p>执行上下文栈</p></blockquote><ul><li>当执行一个函数的时候,就会创建一个执行上下文,并且压入执行上下文栈,当函数执行完毕,就会将函数从执行上下文栈中弹出.</li><li>当使用阶乘的时候,ts(或者是说js)会不停的创建执行上下文压入上下文栈中,对于内存而言,这是非常大的消耗</li><li>使用尾调用优化</li></ul><h3 id="尾调用-Tail-Call"><a href="#尾调用-Tail-Call" class="headerlink" title="尾调用(Tail Call)"></a><a href="https://www.ruanyifeng.com/blog/2015/04/tail-call.html">尾调用(Tail Call)</a></h3><blockquote><p>尾调用就是某个函数的最后一步调用另一个函数</p></blockquote><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token parameter">n</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token keyword">return</span> <span class="token function">g</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>但是在最后一步调用函数之后不能有别的操作</li></ul><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token comment">// 调用函数之后有别的操作,即使语义完全一样</span><span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token parameter">x</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token keyword">let</span> y <span class="token operator">=</span> <span class="token function">g</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> y<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 调用函数之后有别的操作</span><span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token parameter">x</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token keyword">return</span> <span class="token function">g</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>尾调用不一定出现在函数尾部,只要是最后一步操作即可</li></ul><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token parameter">x</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token function">m</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">return</span> <span class="token function">n</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>尾调用优化</p></blockquote><ul><li>函数调用会在内存中形成一个<code>调用记录</code>(调用帧).保存调用的位置何内部的变量信息</li><li>如果函数A的内部调用函数B,那么A 的调用记录上当,会形成一个调用记录B.等到B运行结束.才会将结果返回A.如果还有别的的调用记录栈,会依次形成一个调用栈</li><li>由于<strong>尾调用是函数</strong>的最后一步操作,所以是不需要保留外层函数的调用记录,因为调用位置,内部变量等都用不到了,只要直接使用内层函数的调用记录,取代外层函数的调用记录就可以了</li></ul><ol><li><p>尾调用的函数执行上下文的变化</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token comment">// 伪代码</span>ECStack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token operator">&lt;</span>f<span class="token operator">></span> functionContext<span class="token punctuation">)</span><span class="token punctuation">;</span>ECStack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>ECStack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token operator">&lt;</span>g<span class="token operator">></span> functionContext<span class="token punctuation">)</span><span class="token punctuation">;</span>ECStack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>非尾调用的函数执行上下文</p><ul><li>由于返回函数<code>g(x)+1</code>中的g(x)需要执行完之后(执行的环境就是f(x)的上下文),再加1</li></ul><pre class="line-numbers language-js" data-language="js"><code class="language-js">ECStack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token operator">&lt;</span>f<span class="token operator">></span> functionContext<span class="token punctuation">)</span><span class="token punctuation">;</span>ECStack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token operator">&lt;</span>g<span class="token operator">></span> functionContext<span class="token punctuation">)</span><span class="token punctuation">;</span>ECStack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>ECStack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ol><ul><li>那么可以使用尾调用来重写阶乘的递归<ul><li>由于每次调用之后,只会保留一个调用记录,所以复杂度只有O(1)</li></ul></li></ul><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">function factorial(n: number, total: number): number &#123;  if (n &lt;&#x3D; 1) &#123;    return total  &#125;  return factorial(n - 1, n * total)&#125;console.log(factorial(4, 1))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="实现尾递归"><a href="#实现尾递归" class="headerlink" title="实现尾递归"></a>实现尾递归</h4><blockquote><p>尾递归函数确保最后异步只调用自身.需要把所有的内部变量变成函数的参数(这里就可以使用柯里化来增加函数的复用)</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;递归-recursion&quot;&gt;&lt;a href=&quot;#递归-recursion&quot; class=&quot;headerlink&quot; title=&quot;递归(recursion)&quot;&gt;&lt;/a&gt;递归(recursion)&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;程序调用自身的技巧就被称之为递</summary>
      
    
    
    
    <category term="TS" scheme="http://mail.zyjcould.ltd/categories/TS/"/>
    
    
    <category term="JS" scheme="http://mail.zyjcould.ltd/tags/JS/"/>
    
    <category term="TS" scheme="http://mail.zyjcould.ltd/tags/TS/"/>
    
  </entry>
  
  <entry>
    <title>函数组合&amp;记忆</title>
    <link href="http://mail.zyjcould.ltd/2022/02/27/han-shu-zu-he-ji-yi/"/>
    <id>http://mail.zyjcould.ltd/2022/02/27/han-shu-zu-he-ji-yi/</id>
    <published>2022-02-27T11:35:27.000Z</published>
    <updated>2022-03-19T08:12:04.926Z</updated>
    
    <content type="html"><![CDATA[<h2 id="纯函数-Purity"><a href="#纯函数-Purity" class="headerlink" title="纯函数(Purity)"></a>纯函数(Purity)</h2><ol><li>应始终返回相同的值.不管调用该函数多少次,或者什么时候调用都是一样的</li><li>自包含(不包含全局变量)</li><li>不应修改程序的状态或引起副作用(修改全局变量)</li></ol><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">&#x2F;&#x2F;纯函数const greet &#x3D; (name:string) &#x3D;&gt; &#96;hello, $&#123;name&#125;&#96;greet(&#39;world&#39;)&#x2F;&#x2F;不是纯函数,修改了外部的状态let greeting:stringconst greet &#x3D; (name:string) &#x3D;&gt;&#123;   greeting &#x3D; &#96;hello, $&#123;name&#125;&#96;&#125;greet(&#39;world&#39;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>副作用(Side effects):如果函数与外部可变状态进行交互,则它就是具有副作用的</p></blockquote><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">&#x2F;&#x2F;Date对象就是一个很常见的具有副作用的函数const differentEveryTime &#x3D; new Date()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="幂等性"><a href="#幂等性" class="headerlink" title="幂等性"></a>幂等性</h2><blockquote><p>幂等性和纯函数还是有很大区别的,甚至说可以说是毫无无关系</p></blockquote><ol><li>幂等性函数可以具有副作用</li><li>函数执行多次返回相同的结果(<code>f(f(x))=f(x)</code>),则此函数具有幂等性</li></ol><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">Math.abs(Math.abs(-10))<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="函数组合-Function-Composing"><a href="#函数组合-Function-Composing" class="headerlink" title="函数组合(Function Composing)"></a>函数组合(Function Composing)</h2><blockquote><p>接收多个函数作为参数,从右到左,一个函数的输入为以一个函数的输出</p></blockquote><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">const compose &#x3D;  (f: Function, g: Function): Function &#x3D;&gt;  (a: Function): Function &#x3D;&gt;    f(g(a))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li>做一个反转函数,并且获取第一个索引的例子</li></ul><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">&#x2F;&#x2F;不能确定返回索引的类型,可以使用泛型,这里就用any了function first&lt;T&gt;(arr: T[]): any &#123;  return arr[0]&#125;function reverse&lt;T&gt;(arr: T[]): T[] &#123;  return arr.reverse()&#125;let last &#x3D; compose(first, reverse)console.log(last([1, 2, 3, 4, 5]))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>当然redux给出了一个更好的实现(将函数的个数情况也考虑周全了)</p></blockquote><ul><li>其实还有一个问题就是在闭包中写泛型其实是没有检查的效果</li></ul><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">function compose(...fns: Function[]) &#123;  if (fns.length &#x3D;&#x3D;&#x3D; 0) &#123;    return (arg: Function) &#x3D;&gt; arg  &#125;  if (fns.length &#x3D;&#x3D;&#x3D; 1) &#123;    return fns[0]  &#125;  return fns.reduce(    (a, b) &#x3D;&gt;    &#x2F;&#x2F;Writing a type here won&#39;t do any good      &lt;T&gt;(...args: T[]): Function &#x3D;&gt;        a(b(...args))  )&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Pointfree"><a href="#Pointfree" class="headerlink" title="Pointfree"></a><a href="https://www.ruanyifeng.com/blog/2017/03/pointfree.html">Pointfree</a></h3><blockquote><p>这是函数式编程的答案,利用函数组合和柯里化可以达到一个很好的函数式效果</p></blockquote><ul><li><a href="https://ramdajs.com/">ramda</a>中所有的函数都支持柯里化</li><li>阮老师的教程:<a href="https://www.ruanyifeng.com/blog/2017/03/ramda.html">https://www.ruanyifeng.com/blog/2017/03/ramda.html</a></li></ul><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token comment">//ramda</span>fn <span class="token operator">=</span> <span class="token constant">R</span><span class="token punctuation">.</span><span class="token function">pipe</span><span class="token punctuation">(</span>f1<span class="token punctuation">,</span> f2<span class="token punctuation">,</span> f3<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>定义<code>f1</code>,<code>f2</code>,<code>f3</code>可以推算出<code>fn</code>.整个过程中.根本不需要知到其中的参数变化</li><li>换一种当时可以理解为,只需要将一些简单的步骤合成到一起,定义成一种参数无关的合成运算</li><li>这种风格就是<code>Pointfree</code>.例如上面的例子就是一个<code>Pointfree</code></li></ul><blockquote><p><code>Pointfree</code>的本质就是使用一些通用的函数,组合除各种复杂的运算.shang层运算不直接操作数据</p></blockquote><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">interface Iperson &#123;  name: string  role: string&#125;const data: Iperson[] &#x3D; [  &#123; name: &quot;张三&quot;, role: &quot;worker&quot; &#125;,  &#123; name: &quot;李四&quot;, role: &quot;worker&quot; &#125;,  &#123; name: &quot;王五&quot;, role: &quot;manager&quot; &#125;,]type Iper &#x3D; keyof Ipersonconst isWorker &#x3D; (s: string) &#x3D;&gt; s &#x3D;&#x3D;&#x3D; &quot;worker&quot;&#x2F;&#x2F;定义查找角色的函数,在这里嵌套会增加耦合const prop &#x3D; (p: Iper, obj: Iperson) &#x3D;&gt; isWorker(obj[p])&#x2F;&#x2F;指定读取role的值const propRole &#x3D; curry(prop)(&quot;role&quot;)data.filter(propRole)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>如果不适用<code>compose Function</code>会大大增加函数的耦合度.这就可以使用函数组合的思想降低耦合,避免洋葱模型</li></ul><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">const prop &#x3D; (p: Iper, obj: Iperson) &#x3D;&gt; obj[p]console.log(data.filter((_, index) &#x3D;&gt; compose(isWorker, propRole)(data[index])))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="函数记忆"><a href="#函数记忆" class="headerlink" title="函数记忆"></a>函数记忆</h2><blockquote><p>只要把参数和对应的结果数据存到一个对象中,调用时,判断参数对应的数据是否存在,存在就返回对应的值</p></blockquote><ul><li>如果需要大量重复的计算又依赖于之前的计算,可以考虑函数记忆</li><li>利用Map,Set或者是数组做字典都是一种函数记忆</li><li>谨慎使用,消耗性很大</li></ul><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">const memoize &#x3D; function (fn: Function, hasher?: Function) &#123;  let cache: any &#x3D; &#123;&#125;  const menoize &#x3D; function (...args: any[]) &#123;    const address &#x3D; &quot;&quot; + (hasher ? hasher.apply(null, args) : args)    if (!cache[address]) &#123;      cache[address] &#x3D; fn.apply(null, args)    &#125;    return cache[address]  &#125;  return menoize&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>当然,抄袭<code>underscore</code>的使用ts重够了一下很快</p></blockquote><ul><li>当没有hansher(作为键的函数时),会让args作为键</li></ul><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">let add &#x3D; function (a: number, b: number, c: number) &#123;  return a + b + c&#125;let memoizedAdd &#x3D; memoize(add)console.log(memoizedAdd(1, 2, 3))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>测试一下是,没有问题的.但是我们如果想要使用一个生成键的函数<code>hasher</code></p></blockquote><ul><li>如果并不想要数组的全部内容,可以使用slice截取数组中的第一个作为键</li><li>当然也可以使用别的函数作为键</li></ul><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">const memoizedAdd &#x3D; memoize(add, function () &#123;  const args &#x3D; Array.prototype.slice.call(arguments,0,1)  return JSON.stringify(args)&#125;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;纯函数-Purity&quot;&gt;&lt;a href=&quot;#纯函数-Purity&quot; class=&quot;headerlink&quot; title=&quot;纯函数(Purity)&quot;&gt;&lt;/a&gt;纯函数(Purity)&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;应始终返回相同的值.不管调用该函数多少次,或者什么时候调用都</summary>
      
    
    
    
    <category term="TS" scheme="http://mail.zyjcould.ltd/categories/TS/"/>
    
    
    <category term="JS" scheme="http://mail.zyjcould.ltd/tags/JS/"/>
    
    <category term="TS" scheme="http://mail.zyjcould.ltd/tags/TS/"/>
    
  </entry>
  
  <entry>
    <title>迭代器与生成器</title>
    <link href="http://mail.zyjcould.ltd/2022/02/26/die-dai-qi-yu-sheng-cheng-qi/"/>
    <id>http://mail.zyjcould.ltd/2022/02/26/die-dai-qi-yu-sheng-cheng-qi/</id>
    <published>2022-02-26T05:09:57.000Z</published>
    <updated>2022-03-19T08:12:04.944Z</updated>
    
    <content type="html"><![CDATA[<h2 id="迭代-iteration"><a href="#迭代-iteration" class="headerlink" title="迭代(iteration)"></a>迭代(iteration)</h2><blockquote><p>循环时迭代的基础:循环可以指定迭代的次数,以及每次需要执行什么操作</p></blockquote><h3 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h3><blockquote><p>把实现了正式的<code>Iterable</code>接口的,并且可以通过迭代器<code>Iterator</code>使用的称做可选迭代器</p></blockquote><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">&#x2F;&#x2F;集合的元素可以按插入顺序访问每一个元素let set &#x3D; new Set&lt;number&gt;().add(1).add(2).add(3)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><blockquote><p>实现可迭代协议(Iterable接口):要求同时具备两种能力</p></blockquote><ul><li>支持迭代的自我识别能力和创建实现<code>Iterator</code>接口的对象能力</li><li>在ESMA中,必须暴露一个属性<code>Symbol.iterator</code>作为默认迭代器</li><li>这个默认的迭代器属性必须使用一个迭代器工厂函数(调用时返回一个迭代器)</li></ul><blockquote><p>实现<code>Iterable</code>接口的类型</p></blockquote><ul><li>string</li><li>Array</li><li>Map</li><li>Set</li><li>arguments</li><li>NodeList等DOM集合</li></ul><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">&#x2F;&#x2F;可以通过这种方式是否存在默认的迭代器属性console.log([][Symbol.iterator])&#x2F;&#x2F;[Function: values]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p>迭代器对象的原生语言</p></blockquote><ul><li><p><code>for...of</code>循环</p></li><li><p>数组解构</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">const num:number[] &#x3D; [1,2,3];let [a,b,c] &#x3D; num;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>扩展操作符<code>...</code></p></li><li><p><code>Array.from()</code></p></li><li><p><code>new Set()</code></p></li><li><p><code>new Map()</code></p></li><li><p><code>Promise.all()</code>接收promise组成的可迭代对象</p></li><li><p><code>Promise.race()</code>接收有promise组成的可迭代对象</p></li><li><p><code>yield*</code>操作符,在生成器中使用</p></li></ul><blockquote><p>迭代器使用<code>next()</code>方法在可迭代对象中遍历数据.</p></blockquote><ul><li>每成功调用<code>next()</code>都会返回一个<code>IteratorResult</code>对象,其中包含迭代器返回的下一个值</li><li><code>IteratorResult</code>包含两个属性:<code>done</code>和<code>value</code>.<ul><li>done是一个布尔值,表示是否<code>next()</code>还可以再次调用取得下一个值</li><li>value是包含可迭代对象的下一个值(<code>done:false</code>或者undefined),如果done位true表示结束</li></ul></li></ul><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">let num: number[] &#x3D; [1, 2]let arr &#x3D; num[Symbol.iterator]()console.log(arr.next())&#x2F;&#x2F;&#123; value: 1, done: false &#125;console.log(arr.next())&#x2F;&#x2F;&#123; value: 2, done: false &#125;console.log(arr.next())&#x2F;&#x2F;&#123; value: undefined, done: true &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>只要迭代器对象到达<code>done:true</code>状态,后续调用<code>next</code>都是一样的值</li></ul><h2 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h2><blockquote><p>生成器可以在一个函数块内暂停和恢复代码执行的功能(自定义迭代器或者实现协程)</p></blockquote><ul><li>一般只需要在函数名前加一个<code>*</code>表示他是一个生成器.只要是可以定义函数的地方,就可以定义生成器</li><li>调用生成器函数会返回一个<strong>生成器对象</strong>.<ul><li>生成器对象一开始处于暂停执行的状态.与迭代器相似</li><li>生成器对象同样实现了<code>Iterator</code>接口,因此具有next()方法</li><li>在迭代器中,value值是函数的返回值.默认是undefined</li></ul></li></ul><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">function* gen() &#123;  return &quot;value&quot;&#125;console.log(gen().next)&#x2F;&#x2F;[Function: next]console.log(gen().next())&#x2F;&#x2F;&#123; value: &#39;value&#39;, done: true &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><span style="color:red">生成器只会在初次调用<code>next()</code>方法后执行</span>.直接调用(例如<code>gen()</code>)并不会执行</li><li>生成器对象实现了<code>Iterable</code>接口,默认的迭代器是自引用的</li></ul><h3 id="yield"><a href="#yield" class="headerlink" title="yield"></a>yield</h3><blockquote><p>yield可以让生成器停止或者开始执行</p></blockquote><ul><li>生成器函数在遇到<code>yield</code>关键字之前会正常执行.遇到关键字之后,停止执行,函数作用域的状态会被保留</li><li>停止执行的生成器函数只能通过在生成器对象上调用<code>next()</code>方法来恢复执行</li></ul><blockquote><p>通过<code>yield</code>关键字退出的生成器函数会处于<code>done:false</code>状态.而<code>return</code>关键字退出会处于<code>done:true</code></p></blockquote><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">function* gen() &#123;  yield &quot;done&quot;  yield &quot;data&quot;  return &quot;value&quot;&#125;let genObj &#x3D; gen()console.log(genObj.next())&#x2F;&#x2F;&#123; value: &#39;done&#39;, done: false &#125;console.log(genObj.next())&#x2F;&#x2F;&#123; value: &#39;data&#39;, done: false &#125;console.log(genObj.next())&#x2F;&#x2F;&#123; value: &#39;value&#39;, done: true &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>使用yield实现输入输出</p></blockquote><ul><li>yield除了作为中间返回语句使用,还可以作为函数的中间参数使用.</li><li>上一次上生成器函数暂停的<code>yield</code>关键字会接收到传给<code>next()</code>方法的第一个值</li><li>但是第一次调用next()传入的值不会被使用,因为第一次是为了开始执行生成器函数</li></ul><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">function* gen() &#123;  console.log(yield)  console.log(yield)&#125;let genObj &#x3D; gen()genObj.next(1)&#x2F;&#x2F;不会打印任何东西genObj.next(2)&#x2F;&#x2F;2genObj.next(3)&#x2F;&#x2F;3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>实现输入和输出</li></ul><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">function* gen() &#123;  return yield 1&#125;let genObj &#x3D; gen()console.log(genObj.next(3))&#x2F;&#x2F;&#123; value: 1, done: false &#125;console.log(genObj.next(2))&#x2F;&#x2F;&#123; value: 2, done: true &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol><li>因为函数需要对整个表达式求值才能确定需要返回的值,所以在遇到yield关键字暂停并执行计算要产生的值<code>1</code></li><li>下一次调用<code>next()</code>会传入<code>2</code>,作为交给<code>yield</code>的值.确定位本次生成器函数要返回的值</li></ol><blockquote><p>产生可迭代对象:可以使用<code>*</code>加强yield的行为,让他可以迭代一个可迭代对象,从而一次产出一个值</p></blockquote><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">function* gen() &#123;  yield* [1, 2, 3]&#125;for (let x of gen()) &#123;  console.log(x)&#125;&#x2F;&#x2F;1  &#x2F;&#x2F;2  &#x2F;&#x2F;3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>实际上<code>yield*</code>只是将一个可迭代的对象序列化为一连串的可以单独产出的值,所以这跟把<code>yield</code>凡在一个有循环里一样</li></ul><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">function* gen() &#123;  for (let x of [1,2,3])&#123;    yield x  &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>提前终止生成器</p></blockquote><ul><li>一个实现<code>Iterator</code>接口的对象一定有next()方法,还有一个可选的<code>return()</code>方法用于提前终止迭代器.生成器除了有这两个方法,还有第三个方法<code>throw()</code></li></ul><ol><li><p><code>return()</code>:强制生成器进入关闭状态.提供给return()方法的值,就是迭代器对象的值</p><ul><li>在ts中,如果<code>reuturn()</code>需要传入参数,那么返回值return要定义好类型才能使用,否则<code>void</code></li></ul><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">function* gen() &#123;  yield 1  return 3&#125;console.log(gen().return(4))&#x2F;&#x2F;&#123; value: 1, done: true &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><code>throw</code>:会在暂停的时候将一个提供的错误注入到生成器对象.如果错误未被处理,生成器将会关闭</p><ul><li>如果生成器函数内部处理了这个错误,那么生成器就不会关闭,而且还可以恢复执行</li><li>不过错误也会跳过相对应的yield.</li></ul><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">function* gen() &#123;  for (const x of [1, 2, 3]) &#123;    try &#123;      yield x    &#125; catch (e) &#123;&#125;  &#125;&#125;const g &#x3D; gen()console.log(g.next())&#x2F;&#x2F;&#123; value: 1, done: false &#125;g.throw(&quot;foo&quot;)console.log(g.next())&#x2F;&#x2F;&#123; value: 3, done: false &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><ul><li><p>如果生成器对象还没有被执行,那么调用throw()抛出的错误不会在函数内部被捕获.因为这相当于在函数块外抛出了错误</p><ul><li>以下依然会抛出错误</li></ul><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">function* gen() &#123;  for (const x of [1, 2, 3]) &#123;      try &#123;        yield x      &#125; catch (e) &#123;&#125;      yield x    &#125;&#125;const g &#x3D; gen()g.throw(&quot;foo&quot;)console.log(g.next())console.log(g.next())<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><blockquote><p>最后看一下Generator接口的写法</p></blockquote><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">&#x2F;&#x2F;Generatorinterface Generator&lt;T &#x3D; unknown, TReturn &#x3D; any, TNext &#x3D; unknown&gt; extends Iterator&lt;T, TReturn, TNext&gt; &#123;    next(...args: [] | [TNext]): IteratorResult&lt;T, TReturn&gt;;    return(value: TReturn): IteratorResult&lt;T, TReturn&gt;;    throw(e: any): IteratorResult&lt;T, TReturn&gt;;    [Symbol.iterator](): Generator&lt;T, TReturn, TNext&gt;;&#125;&#x2F;&#x2F;Iteratorinterface Iterator&lt;T, TReturn &#x3D; any, TNext &#x3D; undefined&gt; &#123;    next(...args: [] | [TNext]): IteratorResult&lt;T, TReturn&gt;;    return?(value?: TReturn): IteratorResult&lt;T, TReturn&gt;;    throw?(e?: any): IteratorResult&lt;T, TReturn&gt;;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>Generator</code>泛型接收三个类型<ul><li><strong>T</strong>:yield后的参数类型</li><li><strong>Treturn</strong>:return后的返回值类型</li><li><strong>TNext</strong>:next()函数中的实参类型,不过如果指定了类型,可以不写,或者必须写对应的类型</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;迭代-iteration&quot;&gt;&lt;a href=&quot;#迭代-iteration&quot; class=&quot;headerlink&quot; title=&quot;迭代(iteration)&quot;&gt;&lt;/a&gt;迭代(iteration)&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;循环时迭代的基础:循环可以指定</summary>
      
    
    
    
    <category term="TS" scheme="http://mail.zyjcould.ltd/categories/TS/"/>
    
    
    <category term="JS" scheme="http://mail.zyjcould.ltd/tags/JS/"/>
    
    <category term="TS" scheme="http://mail.zyjcould.ltd/tags/TS/"/>
    
  </entry>
  
  <entry>
    <title>函数柯里化&amp;偏函数&amp;惰性函数</title>
    <link href="http://mail.zyjcould.ltd/2022/02/24/han-shu-ke-li-hua-pian-han-shu-duo-xing-han-shu/"/>
    <id>http://mail.zyjcould.ltd/2022/02/24/han-shu-ke-li-hua-pian-han-shu-duo-xing-han-shu/</id>
    <published>2022-02-24T14:34:17.000Z</published>
    <updated>2022-03-19T08:12:04.925Z</updated>
    
    <content type="html"><![CDATA[<h2 id="柯里化"><a href="#柯里化" class="headerlink" title="柯里化"></a>柯里化</h2><blockquote><p>什么是函数柯里化?</p><p>在计算机中,柯里化是将使用多个参数的一个函数转换成一些列使用一个参数的函数</p></blockquote><ul><li>例如:</li></ul><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">function add(a:number,b:number) &#123;  return a+b&#125;&#x2F;&#x2F;执行add函数,依次传入两个参数add(1,2)&#x2F;&#x2F;如果有一个carry函数,可以做到柯里化let addCurry &#x3D; curry(add)addCurry(1)(2)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>柯里化的用途可以理解为参数复用,本质上是降低通用性,提高适用性</p></blockquote><ul><li>例如有一段这样的数据</li></ul><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">const person &#x3D; [&#123;name:&quot;zhangsan&quot;&#125;,&#123;name:&quot;lisi&quot;&#125;]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol><li><p>使用map函数</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">let names &#x3D; person.map(function(item)&#123;  return item.name&#125;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>如果对象中有多个属性,那就要写多个map才行</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">let prop &#x3D;curry((key,obj)&#x3D;&gt;&#123;  obj[key]&#125;)let name &#x3D; person.map(prop(&quot;name&quot;))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ol><ul><li>这样就体现出柯里化的重要性</li></ul><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">function curry&lt;T&gt;(fn: Function): Function &#123;  return function (...args: T[]) &#123;    if (args.length &lt; fn.length) &#123;      return curry(fn.bind(this, ...args))    &#125; else &#123;      return fn(...args)    &#125;  &#125;&#125;function add(a: number, b: number, c: number) &#123;  return a + b + c&#125;let curryAdd &#x3D; curry(add)console.log(curryAdd(1, 3)(3))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>fn.length</code>就是被柯里化函数的</li><li><code>...args</code>是被柯里化函数的返回值(curryAdd)传入的个数.理想状态是只传一个</li><li><code>curryAdd</code>本质上来讲就是curry函数的返回值,只有curryAdd有实参,args才会有值</li></ul><ol><li><p>执行<code>let curryAdd = curry(add)</code>,返回一个闭包</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">function (...args: T[]) &#123;    if (args.length &lt; fn.length) &#123;      return curry(fn.bind(null, ...args))    &#125; else &#123;      return fn(...args)    &#125;  &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>执行<code>curryAdd(1,3)</code>当前的<code>fn.length</code>就是add形参的数量3大于实参的数量2</p><ul><li>同样返回了和1一样的一个闭包,<span style="color">但是fn发生了改变,传入的是<code>fn.bind(null, ...args)</code></span></li><li>执行一个递归,由于bind函数是柯里化的,这里的<code>fn.length</code>在结束的时候就变成了1</li></ul></li><li><p>执行<code>[curryAdd(1,3)](3)</code>当前的<code>fn.length</code>由于是会执行else的内容</p><ul><li><code>add.bind(this, 1 , 3)(3)</code>:这样就利用bind完成了一个柯里化的过程</li></ul></li></ol><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">type IPerson &#x3D; &#123;  name: string  age: number&#125;const person: IPerson[] &#x3D; [  &#123; name: &quot;zhangsan&quot;, age: 12 &#125;,  &#123; name: &quot;lisi&quot;, age: 100 &#125;,]let prop &#x3D; curry((key: keyof IPerson, obj: IPerson) &#x3D;&gt; &#123;  return obj[key]&#125;)console.log(person.map(prop(&quot;name&quot;)))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="偏函数-Partial-Function"><a href="#偏函数-Partial-Function" class="headerlink" title="偏函数(Partial Function)"></a>偏函数(Partial Function)</h2><blockquote><p>在计算机科学中，偏函数是指固定一个函数的一些参数，然后产生另一个更小元的函数。</p><p>什么是元？元是指函数参数的个数，比如一个带有两个参数的函数被称为二元函数。</p></blockquote><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">function add(a, b) &#123;    return a + b;&#125;&#x2F;&#x2F; 执行 add 函数，一次传入两个参数即可add(1, 2) &#x2F;&#x2F; 3&#x2F;&#x2F; 假设有一个 partial 函数可以做到局部应用var addOne &#x3D; partial(add, 1);addOne(2) &#x2F;&#x2F; 3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>和函数柯里化的区别</p></blockquote><ol><li>柯里化是将一个多参数函数转换成多个单参数函数,也就是将一个n元函数转换成n个一元函数</li><li>偏函数则是固定一个函数的一个或者多个参数,也就是将一个n元函数转换成一个n-x元函数</li></ol><ul><li>柯里化和偏函数的关系:<strong>柯里化通过偏函数来实现</strong></li></ul><blockquote><p>当然也可以使用<code>bind</code>函数来实现偏函数</p></blockquote><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">function test(a: number, b: number, c: number) &#123;  return a + b + c&#125;let bindOne &#x3D; test.bind(null, 1)console.log(bindOne(2, 3))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>但是这会直接改变this的指向</li></ul><blockquote><p>手动实现</p></blockquote><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">function partical(fn: Function, ...args: any[]): Function &#123;  return function (...moreArgs: any[]) &#123;    return fn(...args, ...moreArgs)  &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="惰性函数"><a href="#惰性函数" class="headerlink" title="惰性函数"></a>惰性函数</h2><blockquote><p>惰性函数就是说函数执行一次后，之后调用函数都是相同的作用，直接返回第一次执行函数.很多时候只需要执行一次，因为之后每次调用函数执行的结果都一样。所以如果函数语句不必每次执行，我们可以使用称之为惰性函数的技巧来进行优化。</p></blockquote><ul><li>如果我们现在需要写一个 foo 函数，这个函数返回首次调用时的 Date 对象，注意是首次</li></ul><ol><li><p>闭包的写法</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">let foo: () &#x3D;&gt; Function &#x3D; function () &#123;  let time: Date &#x3D; new Date()  return function () &#123;    if (time) time    return time  &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>惰性函数:惰性函数就是解决每次都要进行判断的这个问题，解决原理很简单，重写函数</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">let foo: () &#x3D;&gt; Function | Date &#x3D; function () &#123;  let time: Date &#x3D; new Date()  foo &#x3D; function () &#123;    return time  &#125;  return foo()&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h3 id="惰性求值-Lazy-evaluation"><a href="#惰性求值-Lazy-evaluation" class="headerlink" title="惰性求值(Lazy evaluation)"></a>惰性求值(Lazy evaluation)</h3><blockquote><p>按需求值机制,只有当需要计算所得值时才会计算</p></blockquote><ul><li>利用生成器机制可以很容易写出</li></ul><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">const rand &#x3D; function* () &#123;  while (true) &#123;    yield Math.random()    &#125; &#125;const randIter &#x3D; rand()randIter.next()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;柯里化&quot;&gt;&lt;a href=&quot;#柯里化&quot; class=&quot;headerlink&quot; title=&quot;柯里化&quot;&gt;&lt;/a&gt;柯里化&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;什么是函数柯里化?&lt;/p&gt;
&lt;p&gt;在计算机中,柯里化是将使用多个参数的一个函数转换成一些列使用一个参数的函</summary>
      
    
    
    
    <category term="TS" scheme="http://mail.zyjcould.ltd/categories/TS/"/>
    
    
    <category term="JS" scheme="http://mail.zyjcould.ltd/tags/JS/"/>
    
    <category term="TS" scheme="http://mail.zyjcould.ltd/tags/TS/"/>
    
  </entry>
  
</feed>
